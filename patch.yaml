commit_message: "feat(ui): Implement inline rest editing and re-enable pause"
rationale: |
  Questo patch introduce un'importante miglioria UX per la gestione dei recuperi, corregge un bug visivo nel trainer e, fondamentalmente, ripristina la piena funzionalità di pausa/ripresa.

  1.  **Editing Inline del Recupero:** L'interazione con il `prompt()` del browser è stata rimossa e sostituita da un sistema di modifica inline, come suggerito dall'utente. Cliccando "Aggiungi Recupero", viene inserito un blocco di riposo di default la cui durata può essere modificata direttamente nella lista, offrendo un'esperienza utente molto più fluida.

  2.  **Correzione Dimensione Font:** È stato corretto un problema di layout per cui testi lunghi ("Inizia Allenamento") potevano sbordare dal cerchio del trainer. Una classe CSS dinamica, `.trainer-main-text--small`, viene ora applicata da `ui.js` per ridurre la dimensione del font quando necessario.

  3.  **Pausa/Ripresa Funzionante:** La funzionalità di pausa/ripresa, persa in un precedente refactoring, è stata completamente re-implementata in `trainer.js` e riattivata in `ui.js`. La logica ora "congela" e "scongela" correttamente lo stato del timer e dell'animazione, permettendo di interrompere e continuare il workout con precisione.
patches:
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       */
      import * as ui from './ui.js';
      import { showDebriefing } from './debriefing.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        ACTION: 'action',
        PAUSED: 'paused',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '',
        totalDuration: 0,
        animationFrameId: null,
        // --- Pause/Resume State ---
        timerStartTime: 0,
        timeOffsetMs: 0,
        onTimerComplete: null,
        pausedState: null,
      };

      function clearTimers() {
        cancelAnimationFrame(state.animationFrameId);
        state.animationFrameId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState };
        // Do not update UI when pausing, as pauseOrResumeTrainer will handle it
        if (newState !== STATES.PAUSED) {
            ui.updateTrainerUI(state);
        }
      }

      function transitionTo(phaseText, duration, onCompleteAction) {
        setState(STATES.ANNOUNCING, { phase: phaseText, totalDuration: duration, onTimerComplete: onCompleteAction });
        // Use a standard timeout for the announcing phase delay
        setTimeout(() => {
          if (state.currentState === STATES.ANNOUNCING) {
             if (state.onTimerComplete) state.onTimerComplete();
          }
        }, 750);
      }

      function runCountdown(duration, phaseText, onComplete, timeOffsetMs = 0) {
          setState(STATES.ACTION, { phase: phaseText, totalDuration: duration, onTimerComplete: onComplete });
          state.timeOffsetMs = timeOffsetMs;
          state.timerStartTime = Date.now();
          const tick = () => {
              const elapsedMs = (Date.now() - state.timerStartTime) + state.timeOffsetMs;
              const progress = Math.min(100, (elapsedMs / (duration * 1000)) * 100);
              ui.updateProgressOnly(progress);
              if (elapsedMs >= duration * 1000) {
                  clearTimers();
                  if (state.onTimerComplete) state.onTimerComplete();
              } else {
                  state.animationFrameId = requestAnimationFrame(tick);
              }
          };
          tick();
      }
      
      function runTempoCycle() {
          const tempo = state.exercise.tempo;
          const executePhase = (phaseName, duration, nextPhase) => {
              if (duration > 0) transitionTo(phaseName.toUpperCase(), duration, () => runCountdown(duration, phaseName.toUpperCase(), nextPhase));
              else nextPhase();
          };
          const doDown = () => executePhase('down', tempo.down, doUp);
          const doHold = () => executePhase('hold', tempo.hold, doDown);
          const doUp = () => {
              if (state.currentRep < state.exercise.reps) {
                  state.currentRep++;
                  ui.updateTrainerUI(state);
                  executePhase('up', tempo.up, doHold);
              } else {
                  handleRestBetweenSeries();
              }
          };
          doUp();
      }

      function handleRestBetweenSeries() {
        const isLastSeries = state.currentSeries >= state.exercise.series;
        if (isLastSeries) {
            advanceToNextWorkoutItem();
            return;
        }
        
        const onRestComplete = () => {
            state.currentSeries++;
            startExercisePhase();
        };
        
        transitionTo('Riposo', state.exercise.rest, () => runCountdown(state.exercise.rest, 'Riposo', onRestComplete));
      }

      function advanceToNextWorkoutItem() {
        const isLastExercise = state.currentExerciseIndex >= state.workout.length - 1;
        if(isLastExercise) {
            setState(STATES.FINISHED);
            const result = { ...state, wasTerminated: false };
            showDebriefing(result);
        } else {
            state.currentExerciseIndex++;
            startExercisePhase();
        }
      }

      function startExercisePhase() {
        state.exercise = state.workout[state.currentExerciseIndex];
        // For reps-based exercises, series is now handled by handleRestBetweenSeries.
        // For time-based exercises, they are always 1 series.
        if (state.exercise.type === 'reps' && !state.currentSeries) {
            state.currentSeries = 1;
        }
        state.currentRep = 0;
        
        if(state.exercise.type === 'rest') {
            transitionTo('Recupero', state.exercise.duration, () => runCountdown(state.exercise.duration, 'Recupero', advanceToNextWorkoutItem));
            return;
        }

        transitionTo("Pronti?", 3, () => {
            runCountdown(3, 'VIA!', () => {
                if (state.exercise.type === 'reps') {
                    runTempoCycle();
                } else { // time
                    transitionTo("Azione", state.exercise.duration, () => runCountdown(state.exercise.duration, "Azione", advanceToNextWorkoutItem));
                }
            });
        });
      }

      export function startTrainer(exercises) {
        if (!exercises || exercises.length === 0) return;
        state = { ...state, workout: JSON.parse(JSON.stringify(exercises)), currentExerciseIndex: 0, currentSeries: 1, currentRep: 0 };
        ui.showView('trainer');
        setState(STATES.READY, {phase: "Inizia Allenamento"});
      }

      export function confirmStart() {
        if (state.currentState === STATES.READY) startExercisePhase();
      }

      export function pauseOrResumeTrainer() {
        if (state.currentState === STATES.PAUSED) {
            // RESUMING
            const ps = state.pausedState;
            // Restore the state machine to where it was
            state.currentState = ps.currentState; 
            runCountdown(ps.totalDuration, ps.phase, ps.onTimerComplete, ps.timeOffsetMs);
        } else {
            // PAUSING
            clearTimers();
            const elapsed = (Date.now() - state.timerStartTime) + state.timeOffsetMs;
            // Save all context needed to resume the countdown
            const pausedContext = {
                totalDuration: state.totalDuration,
                phase: state.phase,
                onTimerComplete: state.onTimerComplete,
                timeOffsetMs: elapsed,
                // also save visual state
                exercise: state.exercise,
                currentSeries: state.currentSeries,
                currentRep: state.currentRep,
                currentState: state.currentState
            };
            setState(STATES.PAUSED, { pausedState: pausedContext });
            ui.updateTrainerUI(state); // Explicitly update UI for pause state
        }
      }

      export function terminateTrainer() {
          clearTimers();
          const result = { ...state, wasTerminated: true };
          showDebriefing(result);
          setState(STATES.IDLE, { phase: '' });
      }
  - file: src/modal.js
    content: |
      /**
       * @file modal.js
       * Handles all logic for the workout editor and exercise library modals.
       */
      import * as storage from './storage.js';
      import { ALL_EXERCISES } from './workouts.js';
      import { renderCalendar } from './calendar.js';
      import { startTrainer } from './trainer.js';

      // DOM Elements
      const dayModal = document.getElementById('day-modal');
      const libraryModal = document.getElementById('library-modal');
      const modalDateTitle = document.getElementById('modal-date-title');
      const modalExerciseList = document.getElementById('modal-exercise-list');
      const libraryExerciseList = document.getElementById('library-exercise-list');
      const addExerciseBtn = document.getElementById('add-exercise-btn');
      const addRestBtn = document.getElementById('add-rest-btn');
      const startFromModalBtn = document.getElementById('start-from-modal-btn');
      const closeDayModalBtn = document.getElementById('close-day-modal-btn');
      const closeLibraryModalBtn = document.getElementById('close-library-modal-btn');

      let currentEditingDateKey = null;

      function renderDayExercises() {
        modalExerciseList.innerHTML = '';
        const exercises = storage.getWorkoutsForDate(currentEditingDateKey);
        
        startFromModalBtn.disabled = exercises.length === 0;

        if (exercises.length === 0) {
          modalExerciseList.innerHTML = `<li class="empty-list-item">Aggiungi un esercizio o un recupero.</li>`;
          return;
        }

        exercises.forEach((exercise, index) => {
          const li = document.createElement('li');
          li.className = 'modal-list-item';
          
          let content;
          if (exercise.type === 'rest') {
            content = `
              <span>Recupero</span>
              <div class="inline-input-group">
                <input type="number" value="${exercise.duration}" min="1" class="inline-duration-input" data-index="${index}" />
                <span>s</span>
              </div>
            `;
          } else {
            content = `<span>${exercise.name}</span>`;
          }

          li.innerHTML = `
            <div class="item-name">${content}</div>
            <button class="btn btn-danger remove-exercise-btn" data-index="${index}">Rimuovi</button>
          `;
          modalExerciseList.appendChild(li);
        });
      }

      function renderLibrary() {
        libraryExerciseList.innerHTML = '';
        ALL_EXERCISES.forEach(exercise => {
          const li = document.createElement('li');
          li.className = 'modal-list-item';
          li.innerHTML = `
            <span>${exercise.name}</span>
            <button class="btn btn-success add-from-library-btn" data-id="${exercise.id}">Aggiungi</button>
          `;
          libraryExerciseList.appendChild(li);
        });
      }

      export function openDayModal(dateKey) {
        currentEditingDateKey = dateKey;
        const date = new Date(dateKey + 'T00:00:00');
        modalDateTitle.textContent = `Allenamento per ${date.toLocaleDateString('it-IT', { weekday: 'long', day: 'numeric', month: 'long' })}`;
        renderDayExercises();
        dayModal.style.display = 'flex';
      }

      function closeDayModal() {
        dayModal.style.display = 'none';
        renderCalendar();
      }

      function openLibraryModal() {
        renderLibrary();
        libraryModal.style.display = 'flex';
      }

      function closeLibraryModal() {
        libraryModal.style.display = 'none';
      }

      export function initModals() {
        closeDayModalBtn.addEventListener('click', closeDayModal);
        closeLibraryModalBtn.addEventListener('click', closeLibraryModal);
        addExerciseBtn.addEventListener('click', openLibraryModal);

        addRestBtn.addEventListener('click', () => {
          const currentExercises = storage.getWorkoutsForDate(currentEditingDateKey);
          currentExercises.push({ id: `rest_${Date.now()}`, type: 'rest', name: 'Recupero', duration: 60 });
          storage.saveWorkoutsForDate(currentEditingDateKey, currentExercises);
          renderDayExercises();
        });

        startFromModalBtn.addEventListener('click', () => {
            const exercises = storage.getWorkoutsForDate(currentEditingDateKey);
            if(exercises.length > 0) {
                closeDayModal();
                startTrainer(exercises);
            }
        });

        modalExerciseList.addEventListener('click', (event) => {
          if (event.target.matches('.remove-exercise-btn')) {
            const indexToRemove = parseInt(event.target.dataset.index, 10);
            const exercises = storage.getWorkoutsForDate(currentEditingDateKey);
            exercises.splice(indexToRemove, 1);
            storage.saveWorkoutsForDate(currentEditingDateKey, exercises);
            renderDayExercises();
          }
        });

        modalExerciseList.addEventListener('change', (event) => {
            if (event.target.matches('.inline-duration-input')) {
                const indexToUpdate = parseInt(event.target.dataset.index, 10);
                const newDuration = parseInt(event.target.value, 10);
                const exercises = storage.getWorkoutsForDate(currentEditingDateKey);
                if (exercises[indexToUpdate] && exercises[indexToUpdate].type === 'rest' && !isNaN(newDuration) && newDuration > 0) {
                    exercises[indexToUpdate].duration = newDuration;
                    storage.saveWorkoutsForDate(currentEditingDateKey, exercises);
                }
            }
        });

        libraryExerciseList.addEventListener('click', (event) => {
          if (event.target.matches('.add-from-library-btn')) {
            const exerciseId = event.target.dataset.id;
            const exerciseToAdd = ALL_EXERCISES.find(ex => ex.id === exerciseId);
            if (exerciseToAdd) {
              const currentExercises = storage.getWorkoutsForDate(currentEditingDateKey);
              currentExercises.push(JSON.parse(JSON.stringify(exerciseToAdd)));
              storage.saveWorkoutsForDate(currentEditingDateKey, currentExercises);
            }
            renderDayExercises();
            closeLibraryModal();
          }
        });
      }
  - file: style.css
    content: |
      :root {
        --bg-color: #1a1a1d;
        --card-color: #2c2c34;
        --primary-color: #9575cd;
        --secondary-color: #4db6ac;
        --text-color: #f4f4f9;
        --text-secondary: #b3b3b3;
        --danger-color: #ef5350;
        --success-color: #66bb6a;
        --border-color: #4a4a52;
      }
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body { font-family: "Roboto Condensed", sans-serif; background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; padding: 1rem; }
      #app-container { width: 100%; max-width: 1200px; position: relative; }
      #app-header {
        text-align: center;
        padding-bottom: 1rem;
        margin-bottom: 2rem;
        border-bottom: 1px solid var(--border-color);
      }
      #app-header h1 {
        font-size: 2rem;
        margin: 0;
        color: var(--text-color);
      }
      h1, h2 { font-family: "Teko", sans-serif; font-weight: 600; color: var(--primary-color); text-align: center; margin-bottom: 1.5rem; }
      .view { display: none; }
      .view--active { display: flex; flex-direction: column; align-items: center; }
      #calendar-view { display: none; }
      #calendar-view.view--active { display: block; }
      #calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; }
      #calendar-header h2 { margin: 0; font-size: 2rem; padding: 0 1rem; text-align: center; }
      #calendar-header .btn {
        width: auto;
        flex-shrink: 0;
        margin-top: 0;
      }
      #calendar-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
      }
      .day-cell { background-color: var(--card-color); border-radius: 8px; padding: 1rem; display: flex; flex-direction: column; justify-content: space-between; border-left: 4px solid transparent; transition: transform 0.2s ease-out, border-color 0.2s ease-out; cursor: pointer; }
      .day-cell:hover { transform: translateY(-4px); border-left-color: var(--primary-color); }
      .day-name { font-weight: bold; text-transform: capitalize; font-size: 1.1rem; color: var(--text-secondary); }
      .day-number { font-family: "Teko", sans-serif; font-size: 3rem; font-weight: 700; text-align: center; margin: 0.5rem 0; }
      .day-summary { font-size: 0.9rem; color: var(--text-secondary); min-height: 2.5em; text-align: center; }
      .btn { background-color: var(--card-color); color: var(--text-color); border: 1px solid var(--border-color); padding: 0.75rem 1.5rem; border-radius: 6px; font-family: "Roboto Condensed", sans-serif; font-weight: bold; text-transform: uppercase; cursor: pointer; transition: background-color 0.2s, transform 0.2s; display: block; width: 100%; text-align: center; margin-top: 1rem; text-decoration: none; }
      .btn:hover:not(:disabled) { transform: scale(1.02); }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .btn.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); }
      .btn.btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--bg-color); }
      .btn.btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); }
      .btn.btn-success { background-color: var(--success-color); border-color: var(--success-color); }
      .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
      .modal-content { background-color: var(--card-color); padding: 2rem; border-radius: 8px; width: 90%; max-width: 500px; max-height: 80vh; display: flex; flex-direction: column; }
      .modal-content h2 { margin-top: 0; }
      .modal-content ul { list-style: none; padding: 0; overflow-y: auto; flex-grow: 1; margin: 1rem 0; }
      .modal-list-item { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; border-bottom: 1px solid var(--border-color); gap: 1rem; }
      .modal-list-item .item-name { flex-grow: 1; }
      .modal-list-item:last-child { border-bottom: none; }
      .modal-list-item .btn { width: auto; max-width: 120px; margin-top: 0; flex-shrink: 0; }
      .inline-input-group { display: flex; align-items: center; gap: 0.5rem; }
      .inline-duration-input { width: 60px; background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.25rem; text-align: center; }
      .empty-list-item { color: var(--text-secondary); text-align: center; padding: 2rem; }
      .modal-actions { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center; margin-top: 1.5rem; }
      .modal-actions .btn { width: auto; margin-top: 0; flex-shrink: 0; }
      #trainer-view, #debriefing-view { gap: 1rem; }
      #trainer-exercise-title { font-size: 2.5rem; text-align: center; }
      #trainer-series-counter { font-size: 1.5rem; color: var(--text-secondary); min-height: 1.5rem; }
      #trainer-description { color: var(--text-secondary); text-align: center; padding: 0 1rem; }
      #trainer-full-description { font-size: 0.9rem; max-width: 400px; text-align: center; color: var(--text-secondary); margin-top: 1rem; }
      #trainer-main-display { width: 300px; height: 300px; margin: 1rem 0; position: relative; display: flex; justify-content: center; align-items: center; }
      #trainer-main-text { font-family: 'Teko', sans-serif; font-size: 5.5rem; line-height: 1; text-align: center; }
      #trainer-main-text.trainer-main-text--small { font-size: 4.5rem; }
      #trainer-main-text small { font-size: 2.5rem; color: var(--text-secondary); }
      #trainer-progress-ring-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
      .progress-ring-bg { fill: transparent; stroke: var(--card-color); stroke-width: 8; }
      .progress-ring-fg { fill: transparent; stroke: var(--primary-color); stroke-width: 8; stroke-linecap: round; transform: rotate(-90deg); transform-origin: 50% 50%; stroke-dasharray: 100; stroke-dashoffset: 100; }
      #trainer-controls { display: flex; gap: 1rem; }
      #trainer-controls .btn { width: 150px; }
      #debriefing-summary { list-style: none; padding: 0; width: 100%; max-width: 500px; background-color: var(--card-color); border-radius: 8px; }
      .debrief-exercise-name small { color: var(--text-secondary); display: block; font-size: 0.8rem; }
      #debriefing-report-container { width: 100%; max-width: 500px; }
      #debriefing-report-container textarea { width: 100%; min-height: 150px; background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.5rem; font-family: monospace; }
      .debriefing-actions { display: flex; gap: 1rem; width: 100%; max-width: 500px; }
      .debriefing-actions .btn { flex-grow: 1; margin-top: 0; }
      @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
      .is-flashing { animation: flash 0.75s infinite; }