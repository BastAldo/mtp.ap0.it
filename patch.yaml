commit_message: "refactor(store): Riprogettazione definitiva della macchina a stati con azioni atomiche"
rationale: |
  Questa è la riscrittura architetturale definitiva per risolvere i problemi di loop e di pausa, basata sul principio della semplicità e su azioni atomiche e prevedibili, come richiesto.

  1.  **Eliminazione Causa dei Loop**: L'architettura precedente, con le sue azioni a cascata, è stata smantellata. Ora esiste un'unica azione di controllo, `SET_TRAINER_PHASE`, che previene i loop fermando sempre il timer precedente prima di impostare un nuovo stato.

  2.  **Flusso Semplificato**: L'azione `TIMER_TICK` ora ha un solo compito: contare. Alla scadenza, calcola la fase successiva e invia una singola, chiara azione `SET_TRAINER_PHASE`. Questo flusso lineare elimina le "race condition" e rende il sistema robusto.

  3.  **Pausa Affidabile**: La logica di `PAUSE_TRAINER` è ora banale: ferma il timer e imposta lo stato. Funziona in modo affidabile perché non deve più competere con una catena di eventi incontrollata.

  Questa soluzione è strutturalmente solida e corregge i difetti di progettazione alla radice.
patches:
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const TICK_INTERVAL = 100;

      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      function createStore() {
        let timerInterval = null;

        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          activeWorkout: null,
          completedWorkout: null,
          trainerState: 'idle',
          trainerContext: {},
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        function logState(actionType, state) {
            if (actionType.startsWith('@@')) return;
            const { activeWorkout, trainerState, trainerContext } = state;
            if (!activeWorkout) return;
            const currentItem = activeWorkout.items[trainerContext.itemIndex];
            const exerciseName = currentItem?.name || 'Riposo';
            const series = `${trainerContext.currentSeries || '-'}/${currentItem?.series || '-'}`;
            const reps = `${trainerContext.currentRep || '-'}/${currentItem?.reps || '-'}`;
            let status = trainerState.toUpperCase();
            if (trainerState === 'announcing' || trainerState === 'action') { status += ` (${trainerContext.currentPhase || 'N/A'})`; }
            const logString = `Esercizio: ${exerciseName} | Serie: ${series} | Rep: ${reps} | Stato: ${status}`;
            console.log(`%c[${actionType}]`, 'color: #88aaff; font-weight: bold;', logString);
        }

        const stopTimer = () => {
          if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
          }
        };

        const startTimer = () => {
          stopTimer();
          timerInterval = setInterval(() => {
            dispatch({ type: 'TIMER_TICK' });
          }, TICK_INTERVAL);
        };

        const dispatch = (action) => {
          const oldState = { ...state };
          let newState = { ...state };
          let shouldNotify = true;

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() - 7); newState = { ...state, focusedDate: d }; break; }
            case 'NEXT_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() + 7); newState = { ...state, focusedDate: d }; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'SHOW_NOTICE': newState = { ...state, notice: { message: action.payload.message, id: Date.now() } }; break;
            case 'ADD_EXERCISE_ITEM': {
                const { date, exerciseId } = action.payload;
                const dateKey = `workout-${date}`;
                const exercise = getExerciseById(exerciseId);
                if (!exercise) break;
                const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } };
                break;
            }
            case 'ADD_REST_ITEM': {
                const { date } = action.payload;
                const dateKey = `workout-${date}`;
                const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'REMOVE_WORKOUT_ITEM': {
                const { date, itemId } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId);
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'UPDATE_REST_DURATION': {
                const { date, itemId, newDuration } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                const itemIndex = dayWorkout.findIndex(item => item.id === itemId);
                if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') {
                    dayWorkout[itemIndex].duration = newDuration;
                    newWorkouts[dateKey] = dayWorkout;
                    newState = { ...state, workouts: newWorkouts };
                }
                break;
            }
            case 'REORDER_WORKOUT_ITEMS': {
                const { date, draggedItemId, targetItemId } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                const items = newWorkouts[dateKey] || [];
                const draggedIndex = items.findIndex(item => item.id === draggedItemId);
                const targetIndex = items.findIndex(item => item.id === targetItemId);
                if (draggedIndex > -1 && targetIndex > -1) {
                    const [draggedItem] = items.splice(draggedIndex, 1);
                    items.splice(targetIndex, 0, draggedItem);
                    newWorkouts[dateKey] = items;
                    newState = { ...state, workouts: newWorkouts };
                }
                break;
            }
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const dateKey = `workout-${date}`;
              const workoutItems = state.workouts[dateKey];
              if (!workoutItems || workoutItems.length === 0) break;
              stopTimer();
              newState = {
                ...state,
                currentView: 'trainer',
                activeWorkout: { date, items: workoutItems, completed: false, fullPlan: workoutItems },
                completedWorkout: null,
                trainerState: 'ready',
                trainerContext: { itemIndex: 0, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0, duration: 0, remaining: 0 }
              };
              break;
            }
            case 'FINISH_WORKOUT': {
              stopTimer();
              newState = { ...state, currentView: 'debriefing', completedWorkout: { ...state.activeWorkout, completed: true }, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'TERMINATE_WORKOUT': {
              stopTimer();
              const { activeWorkout, trainerContext } = state;
              const partialWorkout = { date: activeWorkout.date, fullPlan: activeWorkout.fullPlan, completed: false, terminationPoint: trainerContext };
              newState = { ...state, currentView: 'debriefing', completedWorkout: partialWorkout, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'PAUSE_TRAINER': {
              if (state.trainerState === 'paused' || state.trainerState === 'ready' || state.trainerState === 'finished') break;
              stopTimer();
              newState = { ...state, trainerState: 'paused', trainerContext: { ...state.trainerContext, stateBeforePause: state.trainerState } };
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState !== 'paused') break;
              newState = { ...state, trainerState: state.trainerContext.stateBeforePause };
              startTimer();
              break;
            }
            case 'TIMER_TICK': {
              if (state.trainerState === 'paused') { shouldNotify = false; break; }
              
              const newRemaining = state.trainerContext.remaining - TICK_INTERVAL;

              if (newRemaining > 0) {
                newState = { ...state, trainerContext: { ...state.trainerContext, remaining: newRemaining } };
              } else {
                const { trainerState, activeWorkout, trainerContext } = state;
                const currentItem = activeWorkout.items[trainerContext.itemIndex];
                let nextState = trainerState;
                let nextContext = { ...trainerContext };
                let workoutFinished = false;

                if (trainerState === 'preparing') {
                    const firstItem = activeWorkout.items[0];
                    nextState = firstItem.type === 'rest' ? 'rest' : 'announcing';
                    if (nextState === 'announcing') {
                        nextContext.currentPhase = firstItem.type === 'time' ? 'Esegui' : (Object.keys(firstItem.tempo || {})[0] || 'up');
                    }
                } else if (trainerState === 'announcing') {
                    nextState = 'action';
                } else if (trainerState === 'action' || trainerState === 'rest') {
                    let itemIsComplete = false;
                    if (trainerState === 'rest') {
                        itemIsComplete = true;
                    } else if (currentItem.type === 'time') {
                        itemIsComplete = (nextContext.currentSeries >= currentItem.series);
                        if (!itemIsComplete) nextContext.currentSeries++;
                    } else if (currentItem.type === 'exercise') {
                        const tempo = currentItem.tempo || {};
                        const phases = Object.keys(tempo);
                        if (nextContext.currentPhaseIndex < phases.length - 1) {
                            nextContext.currentPhaseIndex++;
                            nextContext.currentPhase = phases[nextContext.currentPhaseIndex];
                        } else {
                            nextContext.currentPhaseIndex = 0;
                            if (nextContext.currentRep < currentItem.reps) {
                                nextContext.currentRep++;
                                nextContext.currentPhase = phases[0] || 'up';
                            } else if (nextContext.currentSeries < currentItem.series) {
                                nextContext.currentSeries++;
                                nextContext.currentRep = 1;
                                nextContext.currentPhase = phases[0] || 'up';
                            } else {
                                itemIsComplete = true;
                            }
                        }
                    }
                    
                    if(itemIsComplete) {
                        if (trainerContext.itemIndex < activeWorkout.items.length - 1) {
                            const nextItemIndex = trainerContext.itemIndex + 1;
                            const nextItem = activeWorkout.items[nextItemIndex];
                            nextContext = { itemIndex: nextItemIndex, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0 };
                            if(nextItem.type === 'rest') {
                                nextState = 'rest';
                            } else {
                                nextState = 'announcing';
                                nextContext.currentPhase = nextItem.type === 'time' ? 'Esegui' : (Object.keys(nextItem.tempo || {})[0] || 'up');
                            }
                        } else {
                            workoutFinished = true;
                        }
                    } else {
                        nextState = 'announcing';
                    }
                }

                if (workoutFinished) {
                    dispatch({ type: 'SET_TRAINER_PHASE', payload: { nextState: 'finished', nextContext: {} } });
                } else {
                    dispatch({ type: 'SET_TRAINER_PHASE', payload: { nextState, nextContext } });
                }
                shouldNotify = false;
              }
              break;
            }
            case 'SET_TRAINER_PHASE': {
                stopTimer(); // Regola d'oro: ferma sempre il timer prima di impostare una nuova fase.
                const { nextState, nextContext } = action.payload;
                let duration = 0;

                if (nextState !== 'finished' && state.activeWorkout) {
                    const itemForDuration = state.activeWorkout.items[nextContext.itemIndex];
                    switch(nextState) {
                        case 'preparing': duration = 3000; break;
                        case 'announcing': duration = 750; break;
                        case 'action':
                            if (itemForDuration.type === 'time') { duration = (itemForDuration.duration || 10) * 1000; }
                            else { const tempo = itemForDuration.tempo || {}; duration = (tempo[nextContext.currentPhase] || 1) * 1000; }
                            break;
                        case 'rest':
                            duration = (itemForDuration.duration || 60) * 1000;
                            break;
                    }
                }
                
                newState = { ...state, trainerState: nextState, trainerContext: { ...nextContext, duration, remaining: duration } };
                if (duration > 0) startTimer();
                break;
            }
            default:
              action.type = '@@UNKNOWN';
              shouldNotify = false;
              break;
          }

          state = newState;
          if (shouldNotify && state !== oldState) {
            logState(action.type, state);
            if (state.workouts !== oldState.workouts) {
              saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
            }
            notify();
          }
        };

        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      const store = createStore();
      export default store;
  - file: src/views/TrainerView.js
    content: |
      import store from '../modules/store.js';

      function render(element) {
          const { activeWorkout, trainerState, trainerContext } = store.getState();
          if (!activeWorkout) {
              element.innerHTML = '<h2>Nessun workout attivo.</h2>';
              return;
          }

          const currentItem = activeWorkout.items[trainerContext.itemIndex];
          const radius = 90;
          const circumference = 2 * Math.PI * radius;

          let phaseText = '', instructionText = '', buttonText = '', timerText = '', phaseClass = '';
          let ringOffset = circumference;
          const isExercise = currentItem.type === 'exercise' || currentItem.type === 'time';
          let terminateButtonHidden = trainerState === 'finished' || trainerState === 'ready';

          const { duration, remaining } = trainerContext;
          if (duration > 0 && remaining >= 0) {
              const progress = (duration - remaining) / duration;
              ringOffset = circumference * (1 - progress);
          }

          switch (trainerState) {
              case 'ready':
                  phaseText = 'PRONTO'; instructionText = `Premi INIZIA per cominciare`; buttonText = 'INIZIA';
                  break;
              case 'preparing':
                  phaseText = 'PREPARATI'; instructionText = 'Inizia il movimento...'; buttonText = 'PAUSA'; timerText = Math.ceil(remaining / 1000);
                  break;
              case 'rest':
                  phaseText = 'RIPOSO'; instructionText = 'Recupera'; buttonText = 'PAUSA'; timerText = Math.ceil(remaining / 1000);
                  break;
              case 'announcing':
                  phaseText = trainerContext.currentPhase?.toUpperCase() || ''; instructionText = `Prossima fase: ${phaseText}`; buttonText = 'PAUSA'; phaseClass = 'is-flashing';
                  break;
              case 'action':
                  phaseText = trainerContext.currentPhase?.toUpperCase() || ''; instructionText = 'Esegui il movimento'; buttonText = 'PAUSA'; timerText = Math.ceil(remaining / 1000);
                  break;
              case 'paused':
                  const prevState = trainerContext.stateBeforePause;
                  if(prevState === 'preparing') { phaseText = 'PREPARATI'; }
                  else if(prevState === 'rest') { phaseText = 'RIPOSO'; }
                  else if(prevState === 'announcing' || prevState === 'action') {
                      phaseText = trainerContext.currentPhase?.toUpperCase() || '';
                      if (prevState === 'announcing') { phaseClass = 'is-flashing'; }
                  }
                  instructionText = 'Pausa'; buttonText = 'RIPRENDI';
                  if(prevState !== 'announcing') { timerText = Math.ceil(remaining / 1000); }
                  break;
              case 'finished':
                  phaseText = 'FINE'; instructionText = 'Workout completato!'; buttonText = 'DEBRIEFING';
                  break;
              default:
                  phaseText = 'IDLE'; instructionText = 'Stato non riconosciuto'; buttonText = 'RESET';
          }

          const headerTitle = currentItem.name || 'Riposo';
          const seriesText = isExercise ? `SERIE ${trainerContext.currentSeries} / ${currentItem.series || 1}` : '';
          const repsText = currentItem.type === 'exercise' ? `REP ${trainerContext.currentRep} / ${currentItem.reps || 1}` : '';

          element.innerHTML = `
              <div class="trainer-container">
                  <header class="trainer-header">
                      <h2>${headerTitle}</h2>
                      <p>${seriesText} ${repsText ? `| ${repsText}` : ''}</p>
                  </header>
                  <div class="progress-ring">
                      <svg>
                          <circle class="progress-ring__background" stroke-width="10" r="${radius}" cx="50%" cy="50%"></circle>
                          <circle class="progress-ring__foreground" style="stroke-dashoffset: ${ringOffset};" stroke-width="10" r="${radius}" cx="50%" cy="50%" stroke-dasharray="${circumference}"></circle>
                      </svg>
                      <div class="progress-ring__text">
                          <div class="progress-ring__phase ${phaseClass}">${phaseText}</div>
                          <div class="progress-ring__timer">${timerText}</div>
                      </div>
                  </div>
                  <footer class="trainer-footer">
                      <p class="trainer-instruction">${instructionText}</p>
                      <div class="trainer-controls">
                          <button class="trainer-main-btn">${buttonText}</button>
                          <button class="trainer-terminate-btn" ${terminateButtonHidden ? 'hidden' : ''}>Termina</button>
                      </div>
                  </footer>
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              const mainButton = event.target.closest('.trainer-main-btn');
              const terminateButton = event.target.closest('.trainer-terminate-btn');

              if (terminateButton) {
                  store.dispatch({ type: 'PAUSE_TRAINER' });
                  store.dispatch({ type: 'OPEN_MODAL', payload: { type: 'CONFIRM_TERMINATION' } });
                  return;
              }

              if (!mainButton) return;

              const { trainerState, trainerContext } = store.getState();
              switch (trainerState) {
                  case 'ready':
                      store.dispatch({ type: 'SET_TRAINER_PHASE', payload: { nextState: 'preparing', nextContext: trainerContext } });
                      break;
                  case 'paused':
                      store.dispatch({ type: 'RESUME_TRAINER' });
                      break;
                  case 'finished':
                      store.dispatch({ type: 'FINISH_WORKOUT' });
                      break;
                  case 'preparing':
                  case 'action':
                  case 'rest':
                  case 'announcing':
                      store.dispatch({ type: 'PAUSE_TRAINER' });
                      break;
              }
          });

          store.subscribe(() => {
              if(element.classList.contains('view--active')) {
                  render(element);
              }
          });
          render(element);
      }
commands:
  - "echo 'Riprogettazione architetturale completata. Il sistema è ora basato su azioni atomiche e dovrebbe essere stabile.'"