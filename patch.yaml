commit_message: "fix(trainer): Fix NaN bug, incorrect rest time, and restore logging"
rationale: |
  This commit addresses a cascade of failures in the trainer view by fixing three root causes:

  1.  **Fix NaN Bug in View:** `TrainerView.js` was modified to only render the timer when the trainer state is 'running' or 'paused'. This prevents it from trying to calculate the timer in the 'ready' state, where the `remaining` value is undefined, thus fixing the `NaN` error.

  2.  **Correct Mock Data:** The initial data in `src/modules/_mockData.js` was missing the `defaultRest` property on its exercise items. This caused inter-set rests to fall back to 60s instead of the intended 3s. The data has been corrected.

  3.  **Restore State Logging:** The `logState` utility function was re-introduced into `src/modules/store.js` and is now called on every dispatch. This restores the detailed console logs crucial for debugging state transitions.

  Resolving these core issues also fixes the symptomatic problems of unresponsive buttons and apparently missing phases, as the application state now progresses correctly.
patches:
  - file: src/views/TrainerView.js
    content: |
      import store from '../modules/store.js';

      function render(element) {
          const { trainerState, trainerContext } = store.getState();
          const { executionPlan, currentStepIndex, remaining } = trainerContext;

          if (!executionPlan || executionPlan.length === 0) {
              element.innerHTML = '<h2>Nessun piano di workout attivo.</h2>';
              return;
          }

          const currentStep = executionPlan[currentStepIndex];
          const { type, duration, headerTitle, mainText, context = {} } = currentStep;

          const radius = 90;
          const circumference = 2 * Math.PI * radius;
          let ringOffset = circumference;
          
          let timerText = '', buttonText = '', instructionText = '';
          const isFlashing = type === 'announcing';
          const terminateButtonHidden = trainerState === 'finished' || trainerState === 'ready';

          // Corrected condition: Only show timer when running or paused.
          if (duration > 0 && (trainerState === 'running' || trainerState === 'paused')) {
              timerText = Math.ceil(remaining / 1000);
          }

          switch (trainerState) {
              case 'ready': buttonText = 'INIZIA'; instructionText = 'Premi INIZIA per cominciare'; break;
              case 'running': buttonText = 'PAUSA'; instructionText = 'Esegui'; break;
              case 'paused': buttonText = 'RIPRENDI'; instructionText = 'Pausa'; break;
              case 'finished': buttonText = 'DEBRIEFING'; instructionText = 'Ben fatto!'; break;
              default: buttonText = '...';
          }
          
          let subHeaderText = '';
          if (context.totalSeries) {
              subHeaderText = `SERIE ${context.currentSeries}/${context.totalSeries}`;
              if (context.totalReps) {
                  subHeaderText += ` | REP ${context.currentRep}/${context.totalReps}`;
              }
          }

          element.innerHTML = `
              <div class="trainer-container">
                  <header class="trainer-header">
                      <h2>${headerTitle}</h2>
                      <p>${subHeaderText}</p>
                  </header>
                  <div class="progress-ring">
                      <svg>
                          <circle class="progress-ring__background" stroke-width="10" r="${radius}" cx="50%" cy="50%"></circle>
                          <circle class="progress-ring__foreground" style="stroke-dashoffset: ${ringOffset};" stroke-width="10" r="${radius}" cx="50%" cy="50%" stroke-dasharray="${circumference}"></circle>
                      </svg>
                      <div class="progress-ring__text">
                          <div class="progress-ring__phase ${isFlashing ? 'is-flashing' : ''}">${mainText}</div>
                          <div class="progress-ring__timer">${timerText}</div>
                      </div>
                  </div>
                  <footer class="trainer-footer">
                      <p class="trainer-instruction">${instructionText}</p>
                      <div class="trainer-controls">
                          <button class="trainer-main-btn">${buttonText}</button>
                          <button class="trainer-terminate-btn" ${terminateButtonHidden ? 'hidden' : ''}>Termina</button>
                      </div>
                  </footer>
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              const mainButton = event.target.closest('.trainer-main-btn');
              const terminateButton = event.target.closest('.trainer-terminate-btn');

              if (terminateButton) {
                  store.dispatch({ type: 'PAUSE_TRAINER' });
                  store.dispatch({ type: 'OPEN_MODAL', payload: { type: 'CONFIRM_TERMINATION' } });
                  return;
              }

              if (!mainButton) return;
              const { trainerState } = store.getState();

              switch (trainerState) {
                  case 'ready': store.dispatch({ type: 'START_TRAINER' }); break;
                  case 'running': store.dispatch({ type: 'PAUSE_TRAINER' }); break;
                  case 'paused': store.dispatch({ type: 'RESUME_TRAINER' }); break;
                  case 'finished': store.dispatch({ type: 'FINISH_WORKOUT' }); break;
              }
          });

          store.subscribe(() => {
              if (element.classList.contains('view--active')) {
                  render(element);
              }
          });

          if (element.classList.contains('view--active')) {
            render(element);
          }
      }
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';
      import { generatePlan } from './planGenerator.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      // --- Logger di Stato (Reintrodotto) ---
      function logState(actionType, state) {
          if (actionType.startsWith('@@')) return;
          console.groupCollapsed(`%c[${actionType}]`, 'color: #88aaff; font-weight: bold;');
          console.log(state);
          console.groupEnd();
      }

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          activeWorkout: null, 
          completedWorkout: null,
          trainerState: 'idle', 
          trainerContext: {}, 
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        const dispatch = (action) => {
          const oldState = { ...state };
          let newState = { ...state };
          let shouldNotify = true;

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() - 7); newState = { ...state, focusedDate: d }; break; }
            case 'NEXT_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() + 7); newState = { ...state, focusedDate: d }; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'SHOW_NOTICE': newState = { ...state, notice: { message: action.payload.message, id: Date.now() } }; break;
            case 'ADD_EXERCISE_ITEM': { const { date, exerciseId } = action.payload; const dateKey = `workout-${date}`; const exercise = getExerciseById(exerciseId); if (!exercise) break; const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id }; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } }; break; }
            case 'ADD_REST_ITEM': { const { date } = action.payload; const dateKey = `workout-${date}`; const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 }; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts }; break; }
            case 'REMOVE_WORKOUT_ITEM': { const { date, itemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId); newState = { ...state, workouts: newWorkouts }; break; }
            case 'UPDATE_REST_DURATION': { const { date, itemId, newDuration } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; const itemIndex = dayWorkout.findIndex(item => item.id === itemId); if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') { dayWorkout[itemIndex].duration = newDuration; newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts }; } break; }
            case 'REORDER_WORKOUT_ITEMS': { const { date, draggedItemId, targetItemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); const items = newWorkouts[dateKey] || []; const draggedIndex = items.findIndex(item => item.id === draggedItemId); const targetIndex = items.findIndex(item => item.id === targetItemId); if (draggedIndex > -1 && targetIndex > -1) { const [draggedItem] = items.splice(draggedIndex, 1); items.splice(targetIndex, 0, draggedItem); newWorkouts[dateKey] = items; newState = { ...state, workouts: newWorkouts }; } break; }

            // --- TRAINER LIFECYCLE (REFACTORED) ---
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const workoutItems = state.workouts[`workout-${date}`];
              if (!workoutItems || workoutItems.length === 0) break;
              const plan = generatePlan(workoutItems);
              newState = { ...state, currentView: 'trainer', activeWorkout: { date, items: workoutItems }, trainerState: 'ready', trainerContext: { executionPlan: plan, currentStepIndex: 0 } };
              break;
            }
            case 'START_TRAINER': {
              if (state.trainerState === 'ready') {
                const firstStep = state.trainerContext.executionPlan[0];
                newState = { ...state, trainerState: 'running', trainerContext: { ...state.trainerContext, remaining: firstStep.duration } };
              }
              break;
            }
            case 'TIMER_TICK': {
              if (state.trainerState !== 'running') { shouldNotify = false; break; }
              const newRemaining = (state.trainerContext.remaining || 0) - action.payload.tick;

              if (newRemaining > 0) {
                newState = { ...state, trainerContext: { ...state.trainerContext, remaining: newRemaining } };
              } else {
                const { executionPlan, currentStepIndex } = state.trainerContext;
                const nextStepIndex = currentStepIndex + 1;

                if (nextStepIndex >= executionPlan.length) {
                  const fullPlan = state.activeWorkout.items;
                  newState = { ...state, currentView: 'debriefing', completedWorkout: { ...state.activeWorkout, completed: true, fullPlan }, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
                  break;
                }

                const nextStep = executionPlan[nextStepIndex];

                if (nextStep.type === 'finished') {
                  newState = { ...state, trainerState: 'finished', trainerContext: { ...state.trainerContext, currentStepIndex: nextStepIndex, remaining: 0 }};
                } else {
                  newState = { ...state, trainerState: 'running', trainerContext: { ...state.trainerContext, currentStepIndex: nextStepIndex, remaining: nextStep.duration }};
                }
              }
              break;
            }
            case 'PAUSE_TRAINER': {
              if (state.trainerState === 'running') {
                newState = { ...state, trainerState: 'paused' };
              }
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState === 'paused') {
                newState = { ...state, trainerState: 'running' };
              }
              break;
            }
            case 'FINISH_WORKOUT': {
              const fullPlan = state.activeWorkout.items;
              newState = { ...state, currentView: 'debriefing', completedWorkout: { ...state.activeWorkout, completed: true, fullPlan }, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'TERMINATE_WORKOUT': {
              const { activeWorkout, trainerContext } = state;
              const { executionPlan, currentStepIndex } = trainerContext;
              const fullPlan = activeWorkout.items;
              
              const currentStep = executionPlan[currentStepIndex];
              const currentItem = currentStep?.item;
              const originalItemIndex = currentItem ? fullPlan.findIndex(i => i.id === currentItem.id) : -1;

              const terminationPoint = {
                itemIndex: originalItemIndex > -1 ? originalItemIndex : 0,
                currentSeries: currentStep?.context?.currentSeries || 1,
              };

              const partialWorkout = { ...activeWorkout, completed: false, fullPlan, terminationPoint };
              newState = { ...state, currentView: 'debriefing', completedWorkout: partialWorkout, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            default: shouldNotify = false; break;
          }

          state = newState;
          if (shouldNotify) {
            logState(action.type, state);
            if (state.workouts !== oldState.workouts) { saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts); }
            notify();
          }
        };

        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      const store = createStore();
      export default store;
  - file: src/modules/_mockData.js
    content: |
      // --- Dati di Sviluppo Fittizi ---
      // Questi dati vengono usati per popolare localStorage al primo avvio.

      const MOCK_DATE_KEY = 'workout-2025-07-01';

      export const mockWorkouts = {
        [MOCK_DATE_KEY]: [
          {
            id: 'test-ex-reps',
            type: 'exercise',
            exerciseId: 'test-exercise',
            name: 'Esercizio di Test (Reps)',
            series: 2,
            reps: 2,
            tempo: { up: 1, hold: 1, down: 1 },
            defaultRest: 3
          },
          {
            id: 'test-rest',
            type: 'rest',
            duration: 3
          },
          {
            id: 'test-ex-time',
            type: 'time',
            exerciseId: 'test-time-exercise',
            name: 'Esercizio di Test (Tempo)',
            series: 2,
            duration: 5,
            defaultRest: 3
          }
        ]
      };
commands:
  - "echo 'Corretti bug multipli del trainer. Il NaN è stato risolto, i log sono stati ripristinati e i tempi di riposo sono corretti.'"