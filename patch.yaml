commit_message: "fix(trainer): Implement true pause/resume and smooth progress animation"
rationale: |
  Questo patch corregge due importanti problemi di usabilità nella vista trainer: la logica di pausa errata e l'animazione a scatti del cerchio di progresso.

  1.  **Correzione Pausa/Ripresa:** Il bug che causava il reset della fase alla ripresa è stato risolto. La nuova implementazione calcola e memorizza il tempo residuo esatto al momento della pausa. Alla ripresa, il timer viene riavviato solo per la durata rimanente, garantendo una continuazione precisa e senza interruzioni del workout, come ci si aspetterebbe da un'applicazione di questo tipo.

  2.  **Animazione Fluida (High-Frequency Timer):** Per eliminare l'effetto "a scatti" dell'anello di progresso, il motore del timer in `trainer.js` è stato completamente riscritto. Invece di un intervallo di 1 secondo, ora utilizza un ciclo ad alta frequenza (ogni 50ms) basato su `Date.now()`. Questo permette al modulo `ui.js` di aggiornare la barra di progresso in modo quasi continuo, risultando in un'animazione visivamente fluida e delicata, come richiesto.

  3.  **Miglioramento CSS:** La transizione CSS per la proprietà `stroke-dashoffset` è stata sincronizzata con il nuovo intervallo del timer JavaScript per garantire che l'animazione sia il più reattiva possibile.
patches:
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       * It is decoupled from the DOM.
       */
      import * as ui from './ui.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        PREPARING: 'preparing',
        ACTION: 'action',
        PAUSED: 'paused',
        REST: 'rest',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '',
        countdown: 0, // Now represents remaining ms
        totalDuration: 0, // Now represents total ms
        timerId: null,
        timerStartTime: 0,
        timerEndTime: 0,
        prevState: null
      };

      function clearTimers() {
        clearInterval(state.timerId);
        state.timerId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState };
        ui.updateTrainerUI(state);

        switch (newState) {
          case STATES.READY:
            state.exercise = state.workout[state.currentExerciseIndex];
            state.currentSeries = 1;
            ui.updateTrainerUI(state);
            break;

          case STATES.PREPARING:
            setState(STATES.ANNOUNCING, { phase: 'Preparati!', nextState: STATES.ACTION });
            break;

          case STATES.ACTION:
             runCountdown(3000, 'VIA!', () => {
                if (state.exercise.type === 'reps') {
                    state.currentRep = 1;
                    runTempoCycle();
                } else {
                    runCountdown(state.exercise.duration * 1000, 'Stop!', STATES.REST);
                }
            });
            break;

          case STATES.REST:
            const isLastSeries = state.currentSeries >= state.exercise.series