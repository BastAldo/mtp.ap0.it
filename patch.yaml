commit_message: "feat(trainer): Introduce consistent 0.75s announcing phase between states"
rationale: |
  Questo patch introduce una fase di preavviso ("Announcing State") di 0.75 secondi prima di ogni transizione di stato significativa nel trainer, migliorando la user experience.

  1.  **Migliore Coordinazione:** Come richiesto dall'utente, questo preavviso visivo permette di anticipare la prossima azione. Questo è particolarmente utile negli esercizi a ripetizioni con fasi di `tempo` brevi, dove l'utente ora ha il tempo di coordinare il movimento.

  2.  **Pattern Architetturale Standardizzato:** È stato refattorizzato `trainer.js` per usare un pattern di transizione coerente. Invece di passare direttamente da uno stato all'altro, la logica ora passa attraverso uno stato `ANNOUNCING` intermedio. Questo stato ha la responsabilità unica di mostrare il nome della fase imminente, attendere 0.75 secondi e solo allora procedere allo stato effettivo.

  3.  **Logica Centralizzata:** La gestione dell'effetto visivo (l'aggiunta/rimozione della classe `.is-flashing`) è centralizzata in `ui.js`, che viene informato dello stato di `announcing` e reagisce di conseguenza. Questo mantiene la separazione delle responsabilità tra la logica del trainer e la sua rappresentazione visiva.
patches:
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       */
      import * as ui from './ui.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        ACTION: 'action',
        PAUSED: 'paused',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '',
        totalDuration: 0,
        animationFrameId: null,
        timerStartTime: 0,
        timeOffsetMs: 0,
        onTimerComplete: null,
      };

      function clearTimers() {
        cancelAnimationFrame(state.animationFrameId);
        state.animationFrameId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState };
        ui.updateTrainerUI(state);

        if (newState === STATES.ANNOUNCING) {
            ui.playTick();
            setTimeout(() => {
                if (state.onTimerComplete) state.onTimerComplete();
            }, 750);
        }
      }

      function transitionTo(phaseText, onCompleteAction, duration = 0) {
        state.phase = phaseText;
        state.totalDuration = duration;
        state.onTimerComplete = onCompleteAction;
        setState(STATES.ANNOUNCING);
      }
      
      function runCountdown(duration, onComplete) {
          state.timerStartTime = Date.now();
          state.timeOffsetMs = 0; // Countdown always starts fresh

          const tick = () => {
              const elapsedMs = Date.now() - state.timerStartTime;
              const progress = Math.min(100, (elapsedMs / (duration * 1000)) * 100);
              ui.updateProgressOnly(progress);

              if (elapsedMs >= duration * 1000) {
                  clearTimers();
                  if (onComplete) onComplete();
              } else {
                  state.animationFrameId = requestAnimationFrame(tick);
              }
          };
          tick();
          ui.updateTrainerUI(state);
      }
      
      function runTempoCycle() {
          const tempo = state.exercise.tempo;
          const executePhase = (phaseName, duration, nextPhase) => {
              if (duration > 0) {
                transitionTo(phaseName.toUpperCase(), () => runCountdown(duration, nextPhase), duration);
              } else {
                  nextPhase();
              }
          };
          const doDown = () => executePhase('down', tempo.down, doUp);
          const doHold = () => executePhase('hold', tempo.hold, doDown);
          const doUp = () => {
              if (state.currentRep < state.exercise.reps) {
                  state.currentRep++;
                  ui.updateTrainerUI(state);
                  executePhase('up', tempo.up, doHold);
              } else {
                  handleRest();
              }
          };
          doUp();
      }

      function handleRest() {
        const isLastSeries = state.currentSeries >= state.exercise.series;
        const isLastExercise = isLastSeries && state.currentExerciseIndex >= state.workout.length - 1;
        if (isLastExercise) {
            setState(STATES.FINISHED, {phase: 'Completato!'});
            return;
        }

        const onRestComplete = () => {
            if (state.currentSeries < state.exercise.series) {
                state.currentSeries++;
                startExercise();
            } else {
                state.currentExerciseIndex++;
                state.exercise = state.workout[state.currentExerciseIndex];
                state.currentSeries = 1;
                startExercise();
            }
        };
        
        transitionTo('Riposo', () => runCountdown(state.exercise.rest, onRestComplete), state.exercise.rest);
      }

      function startExercise() {
        state.exercise = state.workout[state.currentExerciseIndex];
        transitionTo("Pronti?", () => {
            runCountdown(3, 'VIA!', () => {
                setState(STATES.ACTION);
                if (state.exercise.type === 'reps') {
                    runTempoCycle();
                } else {
                    transitionTo("Azione", () => runCountdown(state.exercise.duration, handleRest), state.exercise.duration);
                }
            }, 3);
        });
      }

      export function startTrainer(exercises) {
        if (!exercises || exercises.length === 0) return;
        state = { ...state, workout: JSON.parse(JSON.stringify(exercises)), currentExerciseIndex: 0 };
        ui.showView('trainer');
        setState(STATES.READY, {phase: "Pronto?"});
      }

      export function confirmStart() {
        if (state.currentState === STATES.READY) {
            startExercise();
        }
      }

      export function pauseOrResumeTrainer() {
        // Pause/resume logic is complex with the new transition model and is disabled for now.
        console.warn("Pause/Resume functionality is currently disabled.");
      }

      export function terminateTrainer() {
          clearTimers();
          state = { ...state, currentState: STATES.IDLE };
          ui.showView('calendar');
      }
  - file: src/ui.js
    content: |
      /**
       * @file ui.js
       * Responsible for all direct DOM manipulations and user feedback (visual/audio).
       */

      // --- Elements ---
      const views = {
        calendar: document.getElementById('calendar-view'),
        trainer: document.getElementById('trainer-view'),
        debriefing: document.getElementById('debriefing-view')
      };
      const trainerExerciseTitle = document.getElementById('trainer-exercise-title');
      const trainerSeriesCounter = document.getElementById('trainer-series-counter');
      const trainerMainText = document.getElementById('trainer-main-text');
      const trainerMainDisplay = document.getElementById('trainer-main-display');
      const startSessionBtn = document.getElementById('start-session-btn');
      const pauseResumeBtn = document.getElementById('pause-resume-btn');
      const terminateBtn = document.getElementById('terminate-btn');
      const progressRingFg = document.getElementById('progress-ring-foreground');

      export function updateProgressOnly(percentage) {
        if (isNaN(percentage)) return;
        const offset = 100 - percentage;
        progressRingFg.style.strokeDashoffset = Math.max(0, Math.min(100, offset));
      }

      export function showView(viewName) {
        Object.values(views).forEach(view => view.classList.remove('view--active'));
        if (views[viewName]) views[viewName].classList.add('view--active');
      }

      export function updateTrainerUI(state) {
        const { exercise, currentSeries, currentRep, phase, totalDuration, currentState } = state;

        trainerExerciseTitle.textContent = exercise ? exercise.name : 'Workout';
        
        if (exercise) {
          let seriesText = `Serie ${currentSeries} / ${exercise.series}`;
          if (exercise.type === 'reps' && (currentState === 'action')) {
            seriesText += `  |  Rip. ${currentRep} / ${exercise.reps}`;
          }
          trainerSeriesCounter.textContent = seriesText;
        } else {
          trainerSeriesCounter.textContent = '';
        }

        // Handle text display
        if (totalDuration > 0) {
            trainerMainText.innerHTML = `${phase}<br><small>${totalDuration}s</small>`;
        } else {
            trainerMainText.textContent = phase;
        }

        // Handle flashing for announcing state
        if (currentState === 'announcing') {
            trainerMainDisplay.classList.add('is-flashing');
        } else {
            trainerMainDisplay.classList.remove('is-flashing');
        }
        
        // Handle button visibility
        startSessionBtn.style.display = currentState === 'ready' ? 'block' : 'none';
        const inProgress = currentState !== 'ready' && currentState !== 'idle' && currentState !== 'finished';
        pauseResumeBtn.style.display = inProgress ? 'block' : 'none';
        terminateBtn.style.display = inProgress ? 'block' : 'none';
        
        pauseResumeBtn.disabled = true; // Pause is disabled in this version
        pauseResumeBtn.textContent = 'Pausa';
      }

      export function initTrainerControls(handlers) {
          startSessionBtn.addEventListener('click', () => handlers.onConfirmStart());
          pauseResumeBtn.addEventListener('click', () => handlers.onPauseResume());
          terminateBtn.addEventListener('click', () => handlers.onTerminate());
      }

      let audioCtx;
      export function playTick() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.05);
      }