commit_message: "fix(trainer): Correct fatal SyntaxError due to missing brace"
rationale: |
  Questo patch corregge un errore di sintassi fatale che impediva all'applicazione di avviarsi.

  1.  **Causa Radice:** L'errore `Uncaught SyntaxError: Unexpected end of input`, visibile nello screenshot dell'utente, era causato da una parentesi graffa di chiusura `}` mancante nella funzione `pauseOrResumeTrainer` all'interno di `src/trainer.js`.

  2.  **Impatto:** Un errore di sintassi blocca l'interpretazione del file JavaScript da parte del browser, interrompendo l'esecuzione di tutto lo script e risultando in una pagina non renderizzata correttamente.

  3.  **Correzione:** La soluzione consiste semplicemente nell'aggiungere la parentesi graffa mancante. Questa modifica mirata risolve l'errore di sintassi e ripristina la capacità del browser di eseguire il codice del trainer, sbloccando il funzionamento dell'applicazione. Non vengono introdotte nuove funzionalità, ma viene ripristinata la stabilità.
patches:
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       * It is decoupled from the DOM.
       */
      import * as ui from './ui.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        PREPARING: 'preparing',
        ACTION: 'action',
        PAUSED: 'paused',
        REST: 'rest',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '', // e.g., 'up', 'hold', 'down', 'rest'
        countdown: 0,
        message: '',
        timerId: null,
        pausedTime: 0,
        prevState: null
      };

      function clearTimers() {
        clearInterval(state.timerId);
        clearTimeout(state.timerId);
        state.timerId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState, message: '' };
        ui.updateTrainerUI(state);

        switch (newState) {
          case STATES.READY:
            state.exercise = state.workout[state.currentExerciseIndex];
            state.currentSeries = 1;
            setState(STATES.PREPARING);
            break;

          case STATES.PREPARING:
            setState(STATES.ANNOUNCING, { phase: 'announcing', message: 'Preparati!', nextState: STATES.ACTION });
            break;

          case STATES.ACTION:
             runCountdown(3, 'VIA!', () => {
                if (state.exercise.type === 'reps') {
                    state.currentRep = 1;
                    runTempoCycle();
                } else { // time
                    runCountdown(state.exercise.duration, 'Stop!', STATES.REST);
                }
            });
            break;

          case STATES.REST:
            const isLastSeries = state.currentSeries >= state.exercise.series;
            const isLastExercise = isLastSeries && state.currentExerciseIndex >= state.workout.length - 1;

            if (isLastExercise) {
                setState(STATES.FINISHED);
                return;
            }

            setState(STATES.ANNOUNCING, {
                phase: 'announcing',
                message: 'Riposo',
                nextState: STATES.REST_COUNTDOWN
            });
            break;
            
          case STATES.REST_COUNTDOWN:
            runCountdown(state.exercise.rest, 'Pronti', () => {
                 if (state.currentSeries < state.exercise.series) {
                    state.currentSeries++;
                    setState(STATES.PREPARING);
                 } else {
                    state.currentExerciseIndex++;
                    setState(STATES.READY);
                 }
            });
            break;

          case STATES.ANNOUNCING:
            ui.playTick();
            state.timerId = setTimeout(() => {
              const next = state.nextState;
              state.nextState = null;
              setState(next);
            }, 750);
            break;

          case STATES.FINISHED:
              ui.showView('calendar'); // Placeholder, will be debriefing view
              break;

          case STATES.IDLE:
          case STATES.PAUSED:
            // Do nothing, wait for user input
            break;
        }
      }
      
      function runCountdown(seconds, finalMessage, onComplete) {
          state.countdown = seconds;
          state.phase = 'countdown';
          ui.updateTrainerUI(state);
          ui.playTick();

          state.timerId = setInterval(() => {
              state.countdown--;
              ui.updateTrainerUI(state);
              if (state.countdown > 0) {
                 ui.playTick();
              } else {
                 ui.playTick();
                 ui.playTick();
              }

              if (state.countdown <= 0) {
                  clearInterval(state.timerId);
                  state.message = finalMessage;
                  ui.updateTrainerUI(state);
                  state.timerId = setTimeout(onComplete, 1000);
              }
          }, 1000);
      }

      function runTempoCycle() {
          const tempo = state.exercise.tempo;
          state.message = `${state.currentRep} / ${state.exercise.reps}`;

          const executePhase = (phaseName, duration, nextPhase) => {
              if (duration > 0) {
                  state.phase = phaseName;
                  runCountdown(duration, phaseName.toUpperCase(), nextPhase);
              } else {
                  nextPhase();
              }
          };
          
          const doDown = () => executePhase('down', tempo.down, doUp);
          const doHold = () => executePhase('hold', tempo.hold, doDown);
          const doUp = () => {
              if (state.currentRep < state.exercise.reps) {
                  state.currentRep++;
                  state.message = `${state.currentRep} / ${state.exercise.reps}`;
                  executePhase('up', tempo.up, doHold);
              } else {
                  setState(STATES.REST);
              }
          };
          
          executePhase('up', tempo.up, doHold);
      }

      export function startTrainer(exercises) {
        if (!exercises || exercises.length === 0) return;
        state.workout = JSON.parse(JSON.stringify(exercises));
        state.currentExerciseIndex = 0;
        ui.showView('trainer');
        setState(STATES.READY);
      }
      
      export function pauseOrResumeTrainer() {
          if (state.currentState === STATES.PAUSED) {
              // Resuming: For now, we simply restart the logic of the state we were in.
              const restartState = state.prevState;
              setState(restartState);
          } else {
              // Pausing
              clearTimers();
              state.prevState = state.currentState;
              setState(STATES.PAUSED);
          }
      }
      
      export function terminateTrainer() {
          clearTimers();
          setState(STATES.IDLE);
          ui.showView('calendar');
      }
commands:
  - "echo 'Patch applicato. È stato corretto l''errore di sintassi in trainer.js.'"
  - "echo 'Ricarica la pagina. L''errore nella console dovrebbe essere sparito e il calendario di nuovo visibile.'"
  - "echo 'Ora l''applicazione dovrebbe essere di nuovo avviabile e il trainer funzionante.'"
  - "echo 'Comando server suggerito: python3 -m http.server'"