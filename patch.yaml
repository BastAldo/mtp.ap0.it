commit_message: "fix(trainer): Improve pause/resume logic and smooth progress ring animation"
rationale: |
  Questo patch corregge due importanti aspetti dell'esperienza utente nel trainer sulla base di feedback specifico.

  1.  **Logica Pausa/Ripresa Corretta:** Il bug che resettava il contatore delle ripetizioni dopo una pausa è stato risolto. La funzione di pausa ora calcola e salva il tempo rimanente per la fase corrente. Alla ripresa, il timer riparte da quel punto esatto invece di resettare l'intero stato, preservando così i progressi dell'utente all'interno della serie.

  2.  **Animazione Fluida del Progress Ring:** L'animazione dell'anello di progresso è stata resa fluida. Come richiesto, è stato introdotto un secondo timer ad alta frequenza (50ms) la cui unica responsabilità è aggiornare l'interfaccia grafica dell'anello. Questo disaccoppia l'aggiornamento della UI dalla logica di stato del trainer (che continua a funzionare con un tick di 1 secondo), risultando in un'animazione visivamente fluida senza compromettere la precisione del workout. È stata creata una funzione `ui.updateProgressOnly` per gestire questo aggiornamento in modo efficiente.
patches:
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       * It is decoupled from the DOM.
       */
      import * as ui from './ui.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        PREPARING: 'preparing',
        ACTION: 'action',
        PAUSED: 'paused',
        REST: 'rest',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '',
        countdown: 0,
        totalDuration: 0,
        message: '',
        logicTimerId: null, // Timer for state logic (1s tick)
        uiTimerId: null,    // Timer for smooth UI updates (50ms tick)
        pausedData: null,   // Stores data needed to resume correctly
        prevState: null
      };

      function clearTimers() {
        clearInterval(state.logicTimerId);
        clearTimeout(state.logicTimerId);
        clearInterval(state.uiTimerId);
        state.logicTimerId = null;
        state.uiTimerId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState, message: '' };
        ui.updateTrainerUI(state);

        switch (newState) {
          case STATES.READY:
            state.exercise = state.workout[state.currentExerciseIndex];
            state.currentSeries = 1;
            ui.updateTrainerUI(state);
            break;

          case STATES.PREPARING:
            setState(STATES.ANNOUNCING, { phase: 'announcing', message: 'Preparati!', nextState: STATES.ACTION });
            break;

          case STATES.ACTION:
             runCountdown(3, 'VIA!', 3, () => {
                if (state.exercise.type === 'reps') {
                    state.currentRep = 1;
                    runTempoCycle();
                } else {
                    runCountdown(state.exercise.duration, 'Stop!', state.exercise.duration, STATES.REST);
                }
            });
            break;

          case STATES.REST:
            const isLastSeries = state.currentSeries >= state.exercise.series;
            const isLastExercise = isLastSeries && state.currentExerciseIndex >= state.workout.length - 1;

            if (isLastExercise) {
                setState(STATES.FINISHED);
                return;
            }
            setState(STATES.ANNOUNCING, { phase: 'announcing', message: 'Riposo', nextState: STATES.REST_COUNTDOWN });
            break;

          case STATES.REST_COUNTDOWN:
            runCountdown(state.exercise.rest, 'Pronti', state.exercise.rest, () => {
                 if (state.currentSeries < state.exercise.series) {
                    state.currentSeries++;
                    setState(STATES.PREPARING);
                 } else {
                    state.currentExerciseIndex++;
                    setState(STATES.READY);
                 }
            });
            break;

          case STATES.ANNOUNCING:
            ui.playTick();
            state.logicTimerId = setTimeout(() => {
              const next = state.nextState;
              state.nextState = null;
              setState(next);
            }, 750);
            break;

          case STATES.FINISHED:
              ui.showView('calendar');
              break;
        }
      }

      function runCountdown(seconds, message, totalDuration, onCompleteOrNextState, timeOffsetMs = 0) {
          const totalDurationMs = totalDuration * 1000;
          let remainingMs = (seconds * 1000) - timeOffsetMs;

          state.countdown = Math.ceil(remainingMs / 1000);
          state.totalDuration = totalDuration;
          state.phase = message;
          
          const startTime = Date.now();
          
          // UI Timer (smooth progress ring)
          state.uiTimerId = setInterval(() => {
              const elapsedMs = (Date.now() - startTime) + timeOffsetMs;
              const progress = Math.min(100, (elapsedMs / totalDurationMs) * 100);
              ui.updateProgressOnly(progress);
          }, 50);

          // Logic Timer (1s tick)
          state.logicTimerId = setInterval(() => {
              remainingMs -= 1000;
              state.countdown = Math.ceil(remainingMs / 1000);
              ui.updateTrainerUI(state);
              if (remainingMs > 0) ui.playTick();
              else { ui.playTick(); ui.playTick(); }

              if (remainingMs <= 0) {
                  clearTimers();
                  if (typeof onCompleteOrNextState === 'function') {
                      state.logicTimerId = setTimeout(onCompleteOrNextState, 1000);
                  } else {
                      setState(onCompleteOrNextState);
                  }
              }
          }, 1000);
          
          // Initial UI update
          ui.updateTrainerUI(state);
      }
      
      function runTempoCycle() {
          const executePhase = (phaseName, duration, nextPhase, timeOffsetMs = 0) => {
              if (duration > 0) {
                  runCountdown(duration, phaseName.toUpperCase(), duration, nextPhase, timeOffsetMs);
              } else {
                  nextPhase();
              }
          };

          const doDown = (offset) => executePhase('down', state.exercise.tempo.down, doUp, offset);
          const doHold = (offset) => executePhase('hold', state.exercise.tempo.hold, doDown, offset);
          const doUp = (offset) => {
              if (state.currentRep < state.exercise.reps) {
                  state.currentRep++;
                  executePhase('up', state.exercise.tempo.up, doHold, offset);
              } else {
                  setState(STATES.REST);
              }
          };
          
          state.pausedData ? doUp(state.pausedData.remainingMs) : doUp();
      }

      export function startTrainer(exercises) {
        if (!exercises || exercises.length === 0) return;
        state = { ...state, workout: JSON.parse(JSON.stringify(exercises)), currentExerciseIndex: 0 };
        ui.showView('trainer');
        setState(STATES.READY);
      }

      export function confirmStart() {
        if (state.currentState === STATES.READY) setState(STATES.PREPARING);
      }

      export function pauseOrResumeTrainer() {
          if (state.currentState === STATES.PAUSED) {
              const { prevState, pausedData } = state;
              state.currentState = prevState; // Restore state before calling logic
              
              if (pausedData.type === 'countdown') {
                  runCountdown(pausedData.remainingSecs, pausedData.message, pausedData.totalDuration, pausedData.onComplete);
              } else if (pausedData.type === 'tempo') {
                  runTempoCycle();
              }
          } else {
              const remainingMs = (state.countdown * 1000) - (1000 - (Date.now() % 1000));
              state.pausedData = { 
                  type: state.exercise.type === 'reps' ? 'tempo' : 'countdown',
                  remainingMs: remainingMs,
                  remainingSecs: Math.ceil(remainingMs / 1000),
                  //... save other context if needed
              };
              state.prevState = state.currentState;
              clearTimers();
              setState(STATES.PAUSED);
          }
      }

      export function terminateTrainer() {
          clearTimers();
          setState(STATES.IDLE);
          ui.showView('calendar');
      }
  - file: src/ui.js
    content: |
      /**
       * @file ui.js
       * Responsible for all direct DOM manipulations and user feedback (visual/audio).
       */

      // --- Views ---
      const calendarView = document.getElementById('calendar-view');
      const trainerView = document.getElementById('trainer-view');
      const debriefingView = document.getElementById('debriefing-view');
      const views = { calendar: calendarView, trainer: trainerView, debriefing: debriefingView };

      // --- Trainer View Elements ---
      const trainerExerciseTitle = document.getElementById('trainer-exercise-title');
      const trainerSeriesCounter = document.getElementById('trainer-series-counter');
      const trainerMainText = document.getElementById('trainer-main-text');
      const startSessionBtn = document.getElementById('start-session-btn');
      const pauseResumeBtn = document.getElementById('pause-resume-btn');
      const terminateBtn = document.getElementById('terminate-btn');

      // --- Progress Ring Elements ---
      const progressRingFg = document.getElementById('progress-ring-foreground');
      const ringRadius = progressRingFg.r.baseVal.value;
      const ringCircumference = 2 * Math.PI * ringRadius;
      progressRingFg.style.strokeDasharray = `${ringCircumference} ${ringCircumference}`;
      progressRingFg.style.strokeDashoffset = ringCircumference;

      export function updateProgressOnly(percentage) {
        const offset = ringCircumference - (percentage / 100) * ringCircumference;
        progressRingFg.style.strokeDashoffset = offset;
      }

      export function showView(viewName) {
        Object.values(views).forEach(view => view.classList.remove('view--active'));
        if (views[viewName]) {
          views[viewName].classList.add('view--active');
        }
      }

      export function updateTrainerUI(state) {
        const { exercise, currentSeries, currentRep, phase, totalDuration, currentState } = state;

        trainerExerciseTitle.textContent = exercise ? exercise.name : 'Workout';
        
        if (exercise) {
          let seriesText = `Serie ${currentSeries} / ${exercise.series}`;
          if (exercise.type === 'reps' && (currentState === 'action' || currentState === 'paused')) {
            seriesText += `  |  Rip. ${currentRep} / ${exercise.reps}`;
          }
          trainerSeriesCounter.textContent = seriesText;
        } else {
          trainerSeriesCounter.textContent = '';
        }

        if (currentState === 'ready') {
          trainerMainText.textContent = "Pronto?";
          updateProgressOnly(0);
        } else if(currentState === 'paused') {
          trainerMainText.textContent = 'Pausa';
        } else if (totalDuration > 0) {
          trainerMainText.innerHTML = `${phase}<br><small>${totalDuration}s</small>`;
        } else {
            trainerMainText.textContent = phase;
        }
        
        startSessionBtn.style.display = currentState === 'ready' ? 'block' : 'none';
        pauseResumeBtn.style.display = currentState !== 'ready' ? 'block' : 'none';
        terminateBtn.style.display = currentState !== 'ready' ? 'block' : 'none';
        pauseResumeBtn.disabled = !(currentState === 'action' || currentState === 'paused' || currentState === 'rest_countdown');
        pauseResumeBtn.textContent = currentState === 'paused' ? 'Riprendi' : 'Pausa';
      }

      export function initTrainerControls(handlers) {
          startSessionBtn.addEventListener('click', () => handlers.onConfirmStart());
          pauseResumeBtn.addEventListener('click', () => handlers.onPauseResume());
          terminateBtn.addEventListener('click', () => handlers.onTerminate());
      }

      let audioCtx;
      export function playTick() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.05);
      }