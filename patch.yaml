commit_message: "fix(trainer): Implement robust pause/resume and correct animation logic"
rationale: |
  Questo patch corregge in modo definitivo i problemi di reset durante la pausa e di animazione errata del progress ring, riscrivendo la logica di gestione del tempo nel trainer.

  1.  **Pausa/Ripresa Affidabile:** La logica di pausa è stata completamente riscritta. Ora, mettendo in pausa, viene salvato l'esatto tempo trascorso in millisecondi. Alla ripresa, il timer viene riavviato con un offset temporale, garantendo che il countdown e l'animazione riprendano dal punto preciso in cui erano stati interrotti. Questo risolve il bug critico del reset del contatore delle ripetizioni.

  2.  **Animazione Precisa:** L'uso di `requestAnimationFrame` è stato mantenuto per la fluidità, ma ora è supportato dalla nuova e più robusta logica di timing. Questo assicura che l'anello di progresso inizi sempre da 0% all'inizio di una nuova fase e non presenti più salti o posizioni di partenza errate, specialmente dopo una ripresa.

  3.  **Miglioramento Strutturale:** La funzione `runCountdown` è stata resa più potente, accettando un offset temporale per gestire la ripresa. Lo stato del trainer (`state` object) ora gestisce in modo più pulito il contesto necessario per la pausa. I pulsanti sono stati riattivati e la loro logica di disabilitazione/abilitazione è stata resa coerente con lo stato del trainer.
patches:
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       */
      import * as ui from './ui.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        PREPARING: 'preparing',
        ACTION: 'action',
        PAUSED: 'paused',
        REST: 'rest',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '',
        totalDuration: 0,
        animationFrameId: null,
        timerStartTime: 0,
        timeOffsetMs: 0, // Time already elapsed when resuming
        onTimerComplete: null,
      };

      function clearTimers() {
        cancelAnimationFrame(state.animationFrameId);
        state.animationFrameId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState };
        ui.updateTrainerUI(state);

        switch (newState) {
          case STATES.READY:
            state.exercise = state.workout[state.currentExerciseIndex];
            state.currentSeries = 1;
            state.phase = "Pronto?";
            ui.updateTrainerUI(state);
            break;

          case STATES.PREPARING:
            setState(STATES.ANNOUNCING, { phase: 'Preparati!', onTimerComplete: () => setState(STATES.ACTION) });
            break;

          case STATES.ACTION:
             runCountdown(3, 'VIA!', () => {
                if (state.exercise.type === 'reps') {
                    state.currentRep = 1;
                    runTempoCycle();
                } else {
                    runCountdown(state.exercise.duration, 'Azione', () => setState(STATES.REST));
                }
            });
            break;

          case STATES.REST:
            const isLastSeries = state.currentSeries >= state.exercise.series;
            const isLastExercise = isLastSeries && state.currentExerciseIndex >= state.workout.length - 1;
            if (isLastExercise) {
                setState(STATES.FINISHED);
                return;
            }
            setState(STATES.ANNOUNCING, { phase: 'Riposo', onTimerComplete: () => setState(STATES.REST_COUNTDOWN) });
            break;

          case STATES.REST_COUNTDOWN:
            runCountdown(state.exercise.rest, 'Riposo', () => {
                 if (state.currentSeries < state.exercise.series) {
                    state.currentSeries++;
                    setState(STATES.PREPARING);
                 } else {
                    state.currentExerciseIndex++;
                    setState(STATES.READY);
                 }
            });
            break;

          case STATES.ANNOUNCING:
            runCountdown(0.75, state.phase, state.onTimerComplete);
            break;

          case STATES.FINISHED:
              ui.showView('calendar');
              break;
        }
      }

      function runCountdown(duration, phaseText, onComplete, timeOffsetMs = 0) {
          state.totalDuration = duration;
          state.phase = phaseText;
          state.onTimerComplete = onComplete;
          state.timeOffsetMs = timeOffsetMs;
          state.timerStartTime = Date.now();

          // Initial UI update for the text and series/rep counters
          ui.updateTrainerUI(state);

          const tick = () => {
              const elapsedMs = (Date.now() - state.timerStartTime) + state.timeOffsetMs;
              const progress = Math.min(100, (elapsedMs / (duration * 1000)) * 100);
              ui.updateProgressOnly(progress);

              if (elapsedMs >= duration * 1000) {
                  ui.playTick();
                  clearTimers();
                  if (state.onTimerComplete) state.onTimerComplete();
              } else {
                  state.animationFrameId = requestAnimationFrame(tick);
              }
          };
          
          tick();
      }
      
      function runTempoCycle() {
          const tempo = state.exercise.tempo;
          const executePhase = (phaseName, duration, nextPhase) => {
              if (duration > 0) runCountdown(duration, phaseName.toUpperCase(), nextPhase);
              else nextPhase();
          };
          const doDown = () => executePhase('down', tempo.down, doUp);
          const doHold = () => executePhase('hold', tempo.hold, doDown);
          const doUp = () => {
              if (state.currentRep < state.exercise.reps) {
                  state.currentRep++;
                  ui.updateTrainerUI(state);
                  executePhase('up', tempo.up, doHold);
              } else {
                  setState(STATES.REST);
              }
          };
          doUp();
      }

      export function startTrainer(exercises) {
        if (!exercises || exercises.length === 0) return;
        state = { ...state, workout: JSON.parse(JSON.stringify(exercises)), currentExerciseIndex: 0 };
        ui.showView('trainer');
        setState(STATES.READY);
      }

      export function confirmStart() {
        if (state.currentState === STATES.READY) setState(STATES.PREPARING);
      }

      export function pauseOrResumeTrainer() {
        if (state.currentState === STATES.PAUSED) {
            // RESUMING
            const prevState = state.prevState;
            state.currentState = prevState.currentState;
            runCountdown(prevState.totalDuration, prevState.phase, prevState.onTimerComplete, prevState.timeOffsetMs);
        } else {
            // PAUSING
            clearTimers();
            const elapsed = (Date.now() - state.timerStartTime) + state.timeOffsetMs;
            const pausedState = { ...state, timeOffsetMs: elapsed }; // Save the exact state when paused
            setState(STATES.PAUSED, { prevState: pausedState });
        }
      }

      export function terminateTrainer() {
          clearTimers();
          state = { ...state, currentState: STATES.IDLE }; // Reset state
          ui.showView('calendar');
      }
  - file: src/ui.js
    content: |
      /**
       * @file ui.js
       * Responsible for all direct DOM manipulations and user feedback (visual/audio).
       */

      // --- Elements ---
      const views = {
        calendar: document.getElementById('calendar-view'),
        trainer: document.getElementById('trainer-view'),
        debriefing: document.getElementById('debriefing-view')
      };
      const trainerExerciseTitle = document.getElementById('trainer-exercise-title');
      const trainerSeriesCounter = document.getElementById('trainer-series-counter');
      const trainerMainText = document.getElementById('trainer-main-text');
      const startSessionBtn = document.getElementById('start-session-btn');
      const pauseResumeBtn = document.getElementById('pause-resume-btn');
      const terminateBtn = document.getElementById('terminate-btn');
      const progressRingFg = document.getElementById('progress-ring-foreground');

      // --- Progress Ring Setup ---
      const ringRadius = progressRingFg.r.baseVal.value;
      const ringCircumference = 2 * Math.PI * ringRadius;
      progressRingFg.style.strokeDasharray = `${ringCircumference} ${ringCircumference}`;
      progressRingFg.style.strokeDashoffset = ringCircumference;

      export function updateProgressOnly(percentage) {
        if (isNaN(percentage)) return;
        const offset = ringCircumference - (percentage / 100) * ringCircumference;
        progressRingFg.style.strokeDashoffset = Math.max(0, offset);
      }

      export function showView(viewName) {
        Object.values(views).forEach(view => view.classList.remove('view--active'));
        if (views[viewName]) views[viewName].classList.add('view--active');
      }

      export function updateTrainerUI(state) {
        const { exercise, currentSeries, currentRep, phase, totalDuration, currentState } = state;

        trainerExerciseTitle.textContent = exercise ? exercise.name : 'Workout';
        
        if (exercise) {
          let seriesText = `Serie ${currentSeries} / ${exercise.series}`;
          if (exercise.type === 'reps' && (currentState === 'action' || (currentState === 'paused' && state.prevState?.currentState === 'action'))) {
            seriesText += `  |  Rip. ${currentRep} / ${exercise.reps}`;
          }
          trainerSeriesCounter.textContent = seriesText;
        } else {
          trainerSeriesCounter.textContent = '';
        }

        if (currentState === 'paused') {
            trainerMainText.textContent = "PAUSA";
        } else if (totalDuration > 0 && currentState !== 'ready') {
            trainerMainText.innerHTML = `${phase}<br><small>${totalDuration}s</small>`;
        } else {
            trainerMainText.textContent = phase;
        }
        
        startSessionBtn.style.display = currentState === 'ready' ? 'block' : 'none';
        const inProgress = currentState !== 'ready' && currentState !== 'idle' && currentState !== 'finished';
        pauseResumeBtn.style.display = inProgress ? 'block' : 'none';
        terminateBtn.style.display = inProgress ? 'block' : 'none';
        
        const canPause = currentState === 'action' || currentState === 'rest_countdown' || currentState === 'announcing' || currentState === 'paused';
        pauseResumeBtn.disabled = !canPause;
        pauseResumeBtn.textContent = currentState === 'paused' ? 'Riprendi' : 'Pausa';
      }

      export function initTrainerControls(handlers) {
          startSessionBtn.addEventListener('click', () => handlers.onConfirmStart());
          pauseResumeBtn.addEventListener('click', () => handlers.onPauseResume());
          terminateBtn.addEventListener('click', () => handlers.onTerminate());
      }

      let audioCtx;
      export function playTick() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); // A4 note
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.05);
      }