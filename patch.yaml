commit_message: "refactor(trainer): Implement user-initiated start and visual progress ring"
rationale: |
  Questo refactoring migliora significativamente l'esperienza utente del trainer sulla base di feedback specifico.

  1.  **Avvio Manuale del Workout:** È stato eliminato l'avvio automatico. Ora, entrando nella vista trainer, l'app attende nello stato `READY`. Un nuovo pulsante "Inizia" appare, dando all'utente il pieno controllo sull'inizio della sessione. La logica in `trainer.js` è stata aggiornata per attendere una chiamata esterna (`confirmStart`) prima di procedere.

  2.  **Riorganizzazione UI:** Come richiesto, il contatore delle ripetizioni correnti è stato spostato dal display principale e ora appare accanto al contatore delle serie. Questa modifica, contenuta unicamente nel modulo `ui.js`, migliora la gerarchia delle informazioni senza alterare la logica del trainer.

  3.  **Implementazione Progress Ring SVG:**
      - L'elemento `div` centrale è stato sostituito con un `SVG` contenente due cerchi per creare un anello di progresso.
      - Il CSS è stato aggiornato per animare la proprietà `stroke-dashoffset` del cerchio, creando un effetto visivo di "riempimento" che rappresenta il tempo trascorso.
      - Il modulo `ui.js` ora calcola la percentuale di avanzamento del timer ad ogni tick e aggiorna l'anello di conseguenza.
      - Il testo all'interno del cerchio ora mostra il nome della fase corrente (es. "UP", "REST") e la sua durata totale, fornendo un feedback più chiaro e professionale rispetto al solo countdown numerico.
patches:
  - file: index.html
    content: |
      <!DOCTYPE html>
      <html lang="it">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <title>Mio Trainer Personale</title>
          <link rel="stylesheet" href="style.css" />
          <link rel="preconnect" href="https://fonts.googleapis.com" />
          <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
          <link
            href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,400;0,700;1,400&family=Teko:wght@400;600;700&display=swap"
            rel="stylesheet"
          />
        </head>
        <body>
          <div id="app-container">
            <div id="calendar-view" class="view view--active">
              <header id="calendar-header">
                <button id="prev-week-btn" class="btn">&lt;</button>
                <h1 id="current-month-year"></h1>
                <button id="next-week-btn" class="btn">&gt;</button>
              </header>
              <div id="calendar-grid"></div>
            </div>

            <div id="trainer-view" class="view">
              <h1 id="trainer-exercise-title"></h1>
              <div id="trainer-series-counter"></div>
              <div id="trainer-main-display">
                <svg id="trainer-progress-ring-svg" viewBox="0 0 100 100">
                  <circle class="progress-ring-bg" cx="50" cy="50" r="45"></circle>
                  <circle id="progress-ring-foreground" class="progress-ring-fg" cx="50" cy="50" r="45"></circle>
                </svg>
                <span id="trainer-main-text"></span>
              </div>
              <div id="trainer-description"></div>
              <div id="trainer-controls">
                <button id="start-session-btn" class="btn btn-success">Inizia</button>
                <button id="pause-resume-btn" class="btn"></button>
                <button id="terminate-btn" class="btn btn-danger"></button>
              </div>
            </div>

            <div id="debriefing-view" class="view">
              <h1>Workout Completato!</h1>
              <div id="debriefing-summary"></div>
              <div id="debriefing-report-container">
                <h2>Copia per il tuo coach:</h2>
                <textarea id="debriefing-text-report" readonly></textarea>
                <button id="copy-report-btn" class="btn btn-primary">
                  Copia Report
                </button>
              </div>
              <button id="return-to-calendar-btn" class="btn btn-secondary">
                Torna al Calendario
              </button>
            </div>
          </div>

          <div id="day-modal" class="modal-overlay" style="display: none">
            <div class="modal-content">
              <h2 id="modal-date-title"></h2>
              <ul id="modal-exercise-list"></ul>
              <div class="modal-actions">
                <button id="add-exercise-btn" class="btn btn-secondary">
                  Aggiungi Esercizio
                </button>
                <button id="close-day-modal-btn" class="btn">Chiudi</button>
              </div>
            </div>
          </div>

          <div id="library-modal" class="modal-overlay" style="display: none">
            <div class="modal-content">
              <h2>Libreria Esercizi</h2>
              <ul id="library-exercise-list"></ul>
              <div class="modal-actions">
                <button id="close-library-modal-btn" class="btn">Chiudi</button>
              </div>
            </div>
          </div>

          <script type="module" src="src/main.js"></script>
        </body>
      </html>
  - file: src/main.js
    content: |
      /**
       * @file main.js
       * The main entry point for the application.
       * Orchestrates all other modules.
       */
      import * as storage from './storage.js';
      import { initCalendar } from './calendar.js';
      import { initModals } from './modal.js';
      import { initTrainerControls } from './ui.js';
      import { confirmStart, pauseOrResumeTrainer, terminateTrainer } from './trainer.js';


      /**
       * The main function to initialize the application.
       */
      function main() {
        console.log('Application Initialized.');
        console.log('Fetching all workouts from storage:', storage.getWorkouts());

        // Initialize all primary components
        initCalendar();
        initModals();
        // Wire up trainer controls once at startup
        initTrainerControls({
          onConfirmStart: confirmStart,
          onPauseResume: pauseOrResumeTrainer,
          onTerminate: terminateTrainer
        });
      }

      // Initialize the app once the DOM is fully loaded.
      document.addEventListener('DOMContentLoaded', main);
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       * It is decoupled from the DOM.
       */
      import * as ui from './ui.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        PREPARING: 'preparing',
        ACTION: 'action',
        PAUSED: 'paused',
        REST: 'rest',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '',
        countdown: 0,
        totalDuration: 0,
        message: '',
        timerId: null,
        prevState: null
      };

      function clearTimers() {
        clearInterval(state.timerId);
        clearTimeout(state.timerId);
        state.timerId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState, message: '' };
        ui.updateTrainerUI(state);

        switch (newState) {
          case STATES.READY:
            state.exercise = state.workout[state.currentExerciseIndex];
            state.currentSeries = 1;
            ui.updateTrainerUI(state); // Update UI to show the initial state and "Inizia" button
            break;

          case STATES.PREPARING:
            setState(STATES.ANNOUNCING, { phase: 'announcing', message: 'Preparati!', nextState: STATES.ACTION });
            break;

          case STATES.ACTION:
             runCountdown(3, 'VIA!', 3, () => {
                if (state.exercise.type === 'reps') {
                    state.currentRep = 1;
                    runTempoCycle();
                } else {
                    runCountdown(state.exercise.duration, 'Stop!', state.exercise.duration, STATES.REST);
                }
            });
            break;

          case STATES.REST:
            const isLastSeries = state.currentSeries >= state.exercise.series;
            const isLastExercise = isLastSeries && state.currentExerciseIndex >= state.workout.length - 1;

            if (isLastExercise) {
                setState(STATES.FINISHED);
                return;
            }

            setState(STATES.ANNOUNCING, {
                phase: 'announcing',
                message: 'Riposo',
                nextState: STATES.REST_COUNTDOWN
            });
            break;

          case STATES.REST_COUNTDOWN:
            runCountdown(state.exercise.rest, 'Pronti', state.exercise.rest, () => {
                 if (state.currentSeries < state.exercise.series) {
                    state.currentSeries++;
                    setState(STATES.PREPARING);
                 } else {
                    state.currentExerciseIndex++;
                    setState(STATES.READY);
                 }
            });
            break;

          case STATES.ANNOUNCING:
            ui.playTick();
            state.timerId = setTimeout(() => {
              const next = state.nextState;
              state.nextState = null;
              setState(next);
            }, 750);
            break;

          case STATES.FINISHED:
              ui.showView('calendar');
              break;

          case STATES.IDLE:
          case STATES.PAUSED:
            break;
        }
      }

      function runCountdown(seconds, message, totalDuration, onCompleteOrNextState) {
          state.countdown = seconds;
          state.totalDuration = totalDuration;
          state.phase = message;
          ui.updateTrainerUI(state);
          ui.playTick();

          state.timerId = setInterval(() => {
              state.countdown--;
              ui.updateTrainerUI(state);
              if (state.countdown > 0) ui.playTick();
              else { ui.playTick(); ui.playTick(); }

              if (state.countdown <= 0) {
                  clearInterval(state.timerId);
                  if (typeof onCompleteOrNextState === 'function') {
                      state.timerId = setTimeout(onCompleteOrNextState, 1000);
                  } else {
                      setState(onCompleteOrNextState);
                  }
              }
          }, 1000);
      }

      function runTempoCycle() {
          const tempo = state.exercise.tempo;
          const repCountMessage = `${state.currentRep} / ${state.exercise.reps}`;

          const executePhase = (phaseName, duration, nextPhase) => {
              if (duration > 0) {
                  runCountdown(duration, phaseName.toUpperCase(), duration, nextPhase);
              } else {
                  nextPhase();
              }
          };

          const doDown = () => executePhase('down', tempo.down, doUp);
          const doHold = () => executePhase('hold', tempo.hold, doDown);
          const doUp = () => {
              if (state.currentRep < state.exercise.reps) {
                  state.currentRep++;
                  executePhase('up', tempo.up, doHold);
              } else {
                  setState(STATES.REST);
              }
          };
          executePhase('up', tempo.up, doHold);
      }

      export function startTrainer(exercises) {
        if (!exercises || exercises.length === 0) return;
        state.workout = JSON.parse(JSON.stringify(exercises));
        state.currentExerciseIndex = 0;
        ui.showView('trainer');
        setState(STATES.READY);
      }

      export function confirmStart() {
        if (state.currentState === STATES.READY) {
          setState(STATES.PREPARING);
        }
      }

      export function pauseOrResumeTrainer() {
          if (state.currentState === STATES.PAUSED) {
              const restartState = state.prevState;
              setState(restartState);
          } else {
              clearTimers();
              state.prevState = state.currentState;
              setState(STATES.PAUSED);
          }
      }

      export function terminateTrainer() {
          clearTimers();
          setState(STATES.IDLE);
          ui.showView('calendar');
      }
  - file: src/ui.js
    content: |
      /**
       * @file ui.js
       * Responsible for all direct DOM manipulations and user feedback (visual/audio).
       */

      // --- Views ---
      const calendarView = document.getElementById('calendar-view');
      const trainerView = document.getElementById('trainer-view');
      const debriefingView = document.getElementById('debriefing-view');
      const views = { calendar: calendarView, trainer: trainerView, debriefing: debriefingView };

      // --- Trainer View Elements ---
      const trainerExerciseTitle = document.getElementById('trainer-exercise-title');
      const trainerSeriesCounter = document.getElementById('trainer-series-counter');
      const trainerMainText = document.getElementById('trainer-main-text');
      const trainerDescription = document.getElementById('trainer-description');
      const startSessionBtn = document.getElementById('start-session-btn');
      const pauseResumeBtn = document.getElementById('pause-resume-btn');
      const terminateBtn = document.getElementById('terminate-btn');

      // --- Progress Ring Elements ---
      const progressRingFg = document.getElementById('progress-ring-foreground');
      const ringRadius = progressRingFg.r.baseVal.value;
      const ringCircumference = 2 * Math.PI * ringRadius;
      progressRingFg.style.strokeDasharray = `${ringCircumference} ${ringCircumference}`;

      function updateProgressRing(percentage) {
        const offset = ringCircumference - (percentage / 100) * ringCircumference;
        progressRingFg.style.strokeDashoffset = offset;
      }

      export function showView(viewName) {
        Object.values(views).forEach(view => view.classList.remove('view--active'));
        if (views[viewName]) {
          views[viewName].classList.add('view--active');
        }
      }

      export function updateTrainerUI(state) {
        const { exercise, currentSeries, currentRep, phase, countdown, totalDuration, currentState } = state;

        trainerExerciseTitle.textContent = exercise ? exercise.name : 'Workout';
        
        // Update series and reps counter
        if (exercise) {
          let seriesText = `Serie ${currentSeries} / ${exercise.series}`;
          if (exercise.type === 'reps' && currentState === 'action') {
            seriesText += `  |  Rip. ${currentRep} / ${exercise.reps}`;
          }
          trainerSeriesCounter.textContent = seriesText;
        } else {
          trainerSeriesCounter.textContent = '';
        }

        // Update main display text and progress ring
        if (currentState === 'ready') {
          trainerMainText.textContent = "Pronto?";
          updateProgressRing(100);
        } else if (totalDuration > 0) {
          trainerMainText.innerHTML = `${phase}<br><small>${totalDuration}s</small>`;
          const elapsed = totalDuration - countdown;
          const progressPercentage = (elapsed / totalDuration) * 100;
          updateProgressRing(progressPercentage);
        } else {
            trainerMainText.textContent = phase;
            updateProgressRing(0);
        }
        
        // Update button visibility and state
        startSessionBtn.style.display = currentState === 'ready' ? 'block' : 'none';
        pauseResumeBtn.style.display = currentState !== 'ready' ? 'block' : 'none';
        terminateBtn.style.display = currentState !== 'ready' ? 'block' : 'none';

        pauseResumeBtn.disabled = !(currentState === 'action' || currentState === 'paused');
        if (currentState === 'paused') {
            pauseResumeBtn.textContent = 'Riprendi';
        } else {
            pauseResumeBtn.textContent = 'Pausa';
        }
      }

      export function initTrainerControls(handlers) {
          startSessionBtn.addEventListener('click', () => handlers.onConfirmStart());
          pauseResumeBtn.addEventListener('click', () => handlers.onPauseResume());
          terminateBtn.addEventListener('click', () => handlers.onTerminate());
      }

      let audioCtx;
      export function playTick() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.05);
      }
  - file: style.css
    content: |
      :root {
        --bg-color: #1a1a1d;
        --card-color: #2c2c34;
        --primary-color: #9575cd;
        --secondary-color: #4db6ac;
        --text-color: #f4f4f9;
        --text-secondary: #b3b3b3;
        --danger-color: #ef5350;
        --success-color: #66bb6a;
        --border-color: #4a4a52;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Roboto Condensed", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        min-height: 100vh;
        padding: 2rem;
      }

      #app-container {
        width: 100%;
        max-width: 1200px;
        position: relative;
      }

      h1, h2 {
        font-family: "Teko", sans-serif;
        font-weight: 600;
        color: var(--primary-color);
        text-align: center;
        margin-bottom: 1.5rem;
      }

      .view {
        display: none;
      }

      .view--active {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #calendar-view { display: none; }
      #calendar-view.view--active { display: block; }
      #calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; }
      #calendar-header h1 { margin: 0; }
      #calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 1rem; }
      .day-cell { background-color: var(--card-color); border-radius: 8px; padding: 1rem; display: flex; flex-direction: column; justify-content: space-between; border-left: 4px solid transparent; transition: transform 0.2s ease-out, border-color 0.2s ease-out; cursor: pointer; }
      .day-cell:hover { transform: translateY(-4px); border-left-color: var(--primary-color); }
      .day-name { font-weight: bold; text-transform: capitalize; font-size: 1.1rem; color: var(--text-secondary); }
      .day-number { font-family: "Teko", sans-serif; font-size: 3rem; font-weight: 700; text-align: center; margin: 0.5rem 0; }
      .day-summary { font-size: 0.9rem; color: var(--text-secondary); min-height: 2.5em; text-align: center; }

      .btn { background-color: var(--card-color); color: var(--text-color); border: 1px solid var(--border-color); padding: 0.75rem 1.5rem; border-radius: 6px; font-family: "Roboto Condensed", sans-serif; font-weight: bold; text-transform: uppercase; cursor: pointer; transition: background-color 0.2s, transform 0.2s; display: block; width: 100%; text-align: center; margin-top: 1rem; }
      .btn:hover:not(:disabled) { transform: scale(1.02); }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .btn.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); }
      .btn.btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--bg-color); }
      .btn.btn-secondary:disabled { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--bg-color); opacity: 0.4; }
      .btn.btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); }
      .btn.btn-success { background-color: var(--success-color); border-color: var(--success-color); }

      .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
      .modal-content { background-color: var(--card-color); padding: 2rem; border-radius: 8px; width: 90%; max-width: 500px; max-height: 80vh; display: flex; flex-direction: column; }
      .modal-content h2 { margin-top: 0; }
      .modal-content ul { list-style: none; padding: 0; overflow-y: auto; flex-grow: 1; margin: 1rem 0; }
      .modal-list-item { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
      .modal-list-item:last-child { border-bottom: none; }
      .modal-list-item .btn { width: auto; padding: 0.5rem 1rem; margin-top: 0; }
      .empty-list-item { color: var(--text-secondary); text-align: center; padding: 2rem; }
      .modal-actions { display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem; }
      .modal-actions .btn { width: auto; margin-top: 0; }

      /* Trainer View Styles */
      #trainer-view { gap: 1rem; }
      #trainer-exercise-title { font-size: 2.5rem; text-align: center; }
      #trainer-series-counter { font-size: 1.5rem; color: var(--text-secondary); min-height: 1.5rem; }
      #trainer-main-display { width: 300px; height: 300px; margin: 1rem 0; position: relative; display: flex; justify-content: center; align-items: center; }
      #trainer-main-text { font-family: 'Teko', sans-serif; font-size: 6rem; line-height: 1; text-align: center; }
      #trainer-main-text small { font-size: 2.5rem; color: var(--text-secondary); }
      #trainer-progress-ring-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
      .progress-ring-bg { fill: transparent; stroke: var(--card-color); stroke-width: 8; }
      .progress-ring-fg { fill: transparent; stroke: var(--primary-color); stroke-width: 8; stroke-linecap: round; transform: rotate(-90deg); transform-origin: 50% 50%; transition: stroke-dashoffset 0.5s linear; }
      #trainer-controls { display: flex; gap: 1rem; }
      #trainer-controls .btn { width: 150px; }
      @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
      .is-flashing { animation: flash 0.75s infinite; }

      @media (max-width: 768px) {
        body { padding: 1rem; }
        #calendar-grid { grid-template-columns: 1fr; gap: 0.5rem; }
        #calendar-header { margin-bottom: 1rem; }
        #trainer-main-display { width: 250px; height: 250px; }
        #trainer-main-text { font-size: 4.5rem; }
      }