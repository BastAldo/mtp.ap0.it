commit_message: "revert(core): Ripristinare lo stato stabile pre-requestAnimationFrame"
rationale: |
  Questo commit esegue un "rollback" strategico per riportare l'applicazione a uno stato stabile e interattivo, annullando le modifiche che hanno introdotto il bug del "blocco dei click".

  Le modifiche architetturali precedenti (in particolare l'introduzione di `requestAnimationFrame` e la separazione dei reducer) si sono rivelate instabili e hanno reso l'applicazione inutilizzabile.

  Questo commit ripristina la versione precedente e più stabile dell'architettura:
  1.  **`main.js`:** Rimuove il loop `requestAnimationFrame` e ripristina la gestione del timer del trainer tramite `setInterval`, confinato in una funzione di side-effect (`handleTrainerEffects`). Questo risolve il problema del re-rendering incontrollato che bloccava i click.
  2.  **`store.js`:** Ripristina la versione dello store monolitico, più semplice da debuggare, che contiene la logica corretta per prevenire il bug del `NaN` (senza "nested dispatch").
  3.  **`CalendarView.js`:** Rimuove la logica di ottimizzazione non più necessaria, tornando a un `subscribe` diretto.

  L'obiettivo è ristabilire una base funzionante e interattiva, da cui poter poi applicare le correzioni ai bug rimanenti in modo controllato e sicuro.
patches:
  - file: src/main.js
    content: |
      console.log('File loaded: main.js');
      import store from './modules/store.js';
      import { init as initCalendarView } from './views/CalendarView.js';
      import { init as initTrainerView } from './views/TrainerView.js';
      import { init as initDebriefingView } from './views/DebriefingView.js';
      import { init as initModal } from './ui/Modal.js';
      import { init as initNotice } from './ui/Notice.js';
      import { loadFromStorage, saveToStorage } from './modules/storage.js';
      import { mockWorkouts } from './modules/_mockData.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const TICK_INTERVAL = 100;

      const views = {
          calendar: document.getElementById('calendar-view'),
          trainer: document.getElementById('trainer-view'),
          debriefing: document.getElementById('debriefing-view'),
      };
      const initializedViews = new Set();

      function initializeApp() {
        let workouts = loadFromStorage(WORKOUTS_STORAGE_KEY);
        if (!workouts) {
          saveToStorage(WORKOUTS_STORAGE_KEY, mockWorkouts);
          workouts = mockWorkouts;
        }
        store.dispatch({ type: 'SET_WORKOUTS', payload: workouts });

        initCalendarView(views.calendar);
        initializedViews.add('calendar');
        initModal(document.getElementById('modal-container'));
        initNotice(document.getElementById('notice-container'));
        console.log('App Initialized.');
      }

      let currentActiveView = views.calendar;
      function handleViewChange() {
        const { currentView } = store.getState();
        const newActiveViewEl = views[currentView];

        if (currentActiveView !== newActiveViewEl) {
          currentActiveView.classList.remove('view--active');
          newActiveViewEl.classList.add('view--active');
          currentActiveView = newActiveViewEl;

          if (!initializedViews.has(currentView)) {
            if (currentView === 'trainer') initTrainerView(views.trainer);
            else if (currentView === 'debriefing') initDebriefingView(views.debriefing);
            initializedViews.add(currentView);
          }
        }
      }

      // --- Gestore Effetti Collaterali per il Timer del Trainer ---
      let timerInterval = null;
      function handleTrainerEffects() {
          const { trainer } = store.getState();
          const trainerState = trainer.status;

          if (trainerState !== 'running' && timerInterval) {
              clearInterval(timerInterval);
              timerInterval = null;
          }

          if (trainerState === 'running' && !timerInterval) {
              timerInterval = setInterval(() => {
                  // Usiamo un payload fittizio per il tick, la logica del tempo è ora interna allo store
                  store.dispatch({ type: 'TIMER_TICK', payload: { tick: TICK_INTERVAL } });
              }, TICK_INTERVAL);
          }
      }

      store.subscribe(handleViewChange);
      store.subscribe(handleTrainerEffects);

      initializeApp();
  - file: src/modules/store.js
    content: |
      console.log('File loaded: store.js');
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';
      import { generatePlan } from './planGenerator.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const clone = (data) => JSON.parse(JSON.stringify(data));

      const trainerInitialState = {
          status: 'idle',
          executionPlan: null,
          currentStepIndex: 0,
          remaining: 0,
          activeWorkout: null,
          completedWorkout: null,
      };

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          trainer: { ...trainerInitialState },
        };

        const subscribers = new Set();
        function notify() { 
            for (const callback of subscribers) {
                callback();
            }
        }

        const dispatch = (action) => {
          if(action.type !== 'TIMER_TICK') {
            console.log(`%c[${action.type}]`, 'color: #88aaff; font-weight: bold;', action.payload || '');
          }
          
          const oldState = state;
          const newState = clone(state);

          switch (action.type) {
            case 'CHANGE_VIEW': newState.currentView = action.payload; break;
            case 'PREV_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() - 7); newState.focusedDate = d; break; }
            case 'NEXT_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() + 7); newState.focusedDate = d; break; }
            case 'SET_WORKOUTS': newState.workouts = action.payload; break;
            case 'OPEN_MODAL': newState.isModalOpen = true; newState.modalContext = action.payload; break;
            case 'CLOSE_MODAL': newState.isModalOpen = false; newState.modalContext = null; break;
            case 'SHOW_NOTICE': newState.notice = { message: action.payload.message, id: Date.now() }; break;
            case 'ADD_EXERCISE_ITEM': { const { date, exerciseId } = action.payload; const dateKey = `workout-${date}`; const exercise = getExerciseById(exerciseId); if (!exercise) break; const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id }; const dayWorkout = newState.workouts[dateKey] || []; dayWorkout.push(newItem); newState.workouts[dateKey] = dayWorkout; newState.modalContext = { type: 'EDIT_WORKOUT', date }; break; }
            case 'ADD_REST_ITEM': { const { date } = action.payload; const dateKey = `workout-${date}`; const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 }; const dayWorkout = newState.workouts[dateKey] || []; dayWorkout.push(newItem); newState.workouts[dateKey] = dayWorkout; break; }
            case 'REMOVE_WORKOUT_ITEM': { const { date, itemId } = action.payload; const dateKey = `workout-${date}`; newState.workouts[dateKey] = (newState.workouts[dateKey] || []).filter(item => item.id !== itemId); break; }
            case 'UPDATE_REST_DURATION': { const { date, itemId, newDuration } = action.payload; const dateKey = `workout-${date}`; const dayWorkout = newState.workouts[dateKey] || []; const itemIndex = dayWorkout.findIndex(item => item.id === itemId); if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') { dayWorkout[itemIndex].duration = newDuration; } break; }
            case 'REORDER_WORKOUT_ITEMS': { const { date, draggedItemId, targetItemId } = action.payload; const dateKey = `workout-${date}`; const items = newState.workouts[dateKey] || []; const draggedIndex = items.findIndex(item => item.id === draggedItemId); const targetIndex = items.findIndex(item => item.id === targetItemId); if (draggedIndex > -1 && targetIndex > -1) { const [draggedItem] = items.splice(draggedIndex, 1); items.splice(targetIndex, 0, draggedItem); } break; }
            
            case 'START_WORKOUT': {
                const { date } = action.payload;
                const workoutItems = newState.workouts[`workout-${date}`];
                if (workoutItems?.length > 0) {
                    newState.currentView = 'trainer';
                    newState.trainer = {
                        ...trainerInitialState,
                        status: 'ready',
                        executionPlan: generatePlan(workoutItems),
                        activeWorkout: { date, items: workoutItems },
                    };
                }
                break;
            }
            case 'START_TRAINER':
                if (newState.trainer.status === 'ready') {
                    const firstStep = newState.trainer.executionPlan[0];
                    newState.trainer.status = 'running';
                    newState.trainer.remaining = firstStep.duration;
                }
                break;
            case 'PAUSE_TRAINER':
                if (newState.trainer.status === 'running') newState.trainer.status = 'paused';
                break;
            case 'RESUME_TRAINER':
                if (newState.trainer.status === 'paused') newState.trainer.status = 'running';
                break;
            case 'TIMER_TICK':
                if (newState.trainer.status === 'running') {
                    const newRemaining = newState.trainer.remaining - action.payload.tick;
                    if (newRemaining <= 0) {
                        const { executionPlan, currentStepIndex } = newState.trainer;
                        const nextStepIndex = currentStepIndex + 1;
                        if (nextStepIndex < executionPlan.length) {
                            const nextStep = executionPlan[nextStepIndex];
                            newState.trainer.currentStepIndex = nextStepIndex;
                            newState.trainer.remaining = nextStep.duration;
                            if (nextStep.type === 'finished') {
                                newState.trainer.status = 'finished';
                                newState.trainer.completedWorkout = { ...newState.trainer.activeWorkout, completed: true };
                            }
                        }
                    } else {
                        newState.trainer.remaining = newRemaining;
                    }
                }
                break;
            case 'TERMINATE_WORKOUT':
                if (newState.trainer.status !== 'idle' && newState.trainer.status !== 'finished') {
                    const { executionPlan, currentStepIndex, activeWorkout } = newState.trainer;
                    const currentStep = executionPlan[currentStepIndex];
                    const itemIndex = activeWorkout.items.findIndex(i => i.id === currentStep.item?.id);
                    newState.trainer.status = 'finished';
                    newState.trainer.completedWorkout = { ...activeWorkout, completed: false, terminationPoint: { itemIndex: itemIndex > -1 ? itemIndex : 0, currentSeries: currentStep.context?.currentSeries || 1 }};
                    newState.currentView = 'debriefing';
                }
                break;
            case 'FINISH_WORKOUT':
                if (newState.trainer.status === 'finished') newState.currentView = 'debriefing';
                break;
          }
          
          state = newState;

          if (state.workouts !== oldState.workouts) {
            saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
          }
          notify();
        };

        return { 
            getState: () => state, 
            subscribe: (callback) => {
                subscribers.add(callback);
                return () => subscribers.delete(callback);
            },
            dispatch 
        };
      }
      
      const store = createStore();
      export default store;
  - file: src/views/CalendarView.js
    content: |
      import store from '../modules/store.js';

      function toISODateString(date) {
          return date.getFullYear() + '-' +
                 ('0' + (date.getMonth() + 1)).slice(-2) + '-' +
                 ('0' + date.getDate()).slice(-2);
      }
      function getWeekStartDate(date) { const d = new Date(date); const day = d.getDay(); const diff = d.getDate() - day + (day === 0 ? -6 : 1); return new Date(d.setDate(diff)); }
      function formatShortDate(date) { return date.toLocaleDateString('it-IT', { day: 'numeric', month: 'long' }); }

      export function init(element) {
        element.innerHTML = `
          <header class="calendar-header">
            <button id="prev-week-btn">&lt; Prev</button>
            <h2 id="week-title"></h2>
            <button id="next-week-btn">Next &gt;</button>
          </header>
          <div class="calendar-grid" id="calendar-grid-container"></div>
        `;

        const prevBtn = element.querySelector('#prev-week-btn');
        const nextBtn = element.querySelector('#next-week-btn');
        const weekTitle = element.querySelector('#week-title');
        const gridContainer = element.querySelector('#calendar-grid-container');

        prevBtn.addEventListener('click', () => store.dispatch({ type: 'PREV_WEEK' }));
        nextBtn.addEventListener('click', () => store.dispatch({ type: 'NEXT_WEEK' }));

        gridContainer.addEventListener('click', (event) => {
          const dayCell = event.target.closest('.day-cell');
          if (!dayCell) return;

          const startButton = event.target.closest('.start-btn');
          if (startButton) {
            const date = dayCell.dataset.date;
            store.dispatch({ type: 'START_WORKOUT', payload: { date } });
            return;
          }

          const date = dayCell.dataset.date;
          store.dispatch({ type: 'OPEN_MODAL', payload: { type: 'EDIT_WORKOUT', date } });
        });

        function render() {
          const { focusedDate, workouts } = store.getState();
          const weekStart = getWeekStartDate(focusedDate);
          const weekEnd = new Date(weekStart); weekEnd.setDate(weekEnd.getDate() + 6);
          weekTitle.textContent = `${formatShortDate(weekStart)} - ${formatShortDate(weekEnd)}`;
          gridContainer.innerHTML = '';

          for (let i = 0; i < 7; i++) {
            const dayDate = new Date(weekStart);
            dayDate.setDate(dayDate.getDate() + i);
            const isoDate = toISODateString(dayDate);
            const dateKey = `workout-${isoDate}`;
            const workoutForDay = workouts[dateKey];

            const dayCell = document.createElement('div');
            dayCell.className = 'day-cell';
            dayCell.dataset.date = isoDate;

            let bodyContent = '';
            if (workoutForDay?.length > 0) {
              const exerciseCount = workoutForDay.filter(item => item.type !== 'rest').length;
              bodyContent = `<div class="exercise-count">${exerciseCount} esercizi</div><button class="start-btn">START</button>`;
            }
            dayCell.innerHTML = `<div class="day-cell__header"><span>${dayDate.toLocaleDateString('it-IT', { weekday: 'long' })}</span><span>${dayDate.getDate()}</span></div><div class="day-cell__body">${bodyContent}</div>`;
            gridContainer.appendChild(dayCell);
          }
        }
        store.subscribe(render);
        render();
      }