commit_message: "feat(debriefing): Implement workout summary and terminate button"
rationale: |
  This commit delivers a major feature enhancement by implementing a fully functional Debriefing View and adding the ability for users to terminate a workout prematurely.

  1.  **State Management**: A `completedWorkout` property has been added to the store. This acts as a vessel to transfer data of the finished (or terminated) workout to the Debriefing View, ensuring a clean separation of concerns.

  2.  **Terminate Functionality**: A "Termina" button has been added to the Trainer. It dispatches a new `TERMINATE_WORKOUT` action, which saves the partial workout progress to `completedWorkout` and navigates to the debriefing screen.

  3.  **Dynamic Debriefing View**: The `DebriefingView` is no longer static. It now subscribes to the store and dynamically renders a summary based on the `completedWorkout` data. It also includes a functional "Copy for Coach" button that uses the Clipboard API.

  4.  **Documentation**: All relevant documentation (`01_FUNCTIONALITY.md`, `functionality_spec.md`) has been updated to reflect the new "Terminate" button and the detailed behavior of the Debriefing View for both complete and partial workouts.
patches:
  - file: docs/01_FUNCTIONALITY.md
    content: |
      # App Functionality Specification

      This document outlines the core features and operational logic of the "Mio Trainer Personale" web application.

      ## 1. Core Concept

      The application is a single-page app (SPA) designed for users to schedule, execute, and track workouts. All user data is persisted locally in the browser's `localStorage`.

      ## 2. Main Views

      The application operates using three primary, mutually exclusive views: `Calendar`, `Trainer`, and `Debriefing`.

      ### 2.1. Calendar View

      -   **Function:** The main dashboard and default view of the application.
      -   **Display:** It presents a weekly grid layout.
      -   **Navigation:** Users can navigate to the previous or next week.
      -   **Day Cells:** Each cell represents a day and displays a summary of the number of exercises scheduled for that day. A "START" button is enabled if one or more exercises are scheduled.
      -   **Interaction:** Clicking a day cell (but not the "START" button) opens the Workout Editor modal for that specific date.

      ### 2.2. Workout Editor (Modal System)

      The editor is a modal system for managing a day's workout routine. It allows for the composition of exercises and configurable rest periods.

      -   **Daily Workout Modal:**
          -   Triggered by clicking a day cell.
          -   Displays a list of items (exercises or rests) currently scheduled for the selected date.
      -   **Exercise Library Modal:**
          -   Triggered by the "Add Exercise" button.
          -   Displays a list of all **available exercises** from the application's library.

      ### 2.3. Interactive Trainer View

      -   **Function:** An interactive, state-driven interface that guides the user through a scheduled workout in real-time.
      -   **Activation:** Triggered by clicking the "START" button on a day cell in the calendar.
      -   **Controls:** Includes a main button for starting/pausing/resuming and a secondary button to **terminate** the workout at any time.

      #### Trainer State Machine & Flow
      The trainer operates as a state machine. The primary user flow is as follows:

      1.  **Ready (`ready`):** The initial state. The trainer displays the first exercise and awaits user input.
      2.  **Preparing (`preparing`):** A 3-second countdown that runs **only once** at the very beginning of the workout.
      3.  **Announcing (`announcing`):** A 0.75-second state that displays the name of the upcoming phase (e.g., "UP", "REST") to alert the user.
      4.  **Action (`action`):** The core execution phase where the user performs the movement for a timed duration.
      5.  **Rest (`rest`):** A timed countdown for rest. This state is **only** activated when the trainer encounters a user-defined rest block in the workout sequence. There are no automatic rests between series or exercises.
      6.  **Paused (`paused`):** The user can pause the workout at any time during `preparing`, `announcing`, `action`, or `rest`.
      7.  **Advancement Logic:**
          - After an `action` phase, the logic checks for more phases, repetitions, or series within the same exercise.
          - Once an entire exercise item is complete (all series and reps), the trainer immediately advances to the next item in the workout list.
          - If the next item is an exercise, it begins the `announcing` phase for it.
          - If the next item is a rest block, it enters the `rest` state.
      8.  **Finished (`finished`):** Once all items in the routine are complete, the trainer's main button changes to "DEBRIEFING". Clicking it transitions to the Debriefing View.
      9.  **Terminated (`terminate`):** If the user clicks "Termina", the workout is immediately stopped, and the app transitions to the Debriefing View with a partial summary.

      ### 2.4. Debriefing View

      -   **Activation:** Appears automatically after a workout is finished or terminated.
      -   **Content:** Displays a summary of all exercises completed (or partially completed). For partial workouts, it indicates exactly where the user left off.
      -   **Actions:**
          - **"Copy for Coach"**: Copies a pre-formatted text summary of the workout to the clipboard.
          - **"Return to Calendar"**: Navigates back to the main calendar view.
  - file: functionality_spec.md
    content: |
      # App Functionality Specification

      This document outlines the core features and operational logic of the "Mio Trainer Personale" web application.

      ## 1. Core Concept

      The application is a single-page app (SPA) designed for users to schedule, execute, and track workouts. All user data is persisted locally in the browser's `localStorage`.

      ## 2. Main Views

      The application operates using three primary, mutually exclusive views: `Calendar`, `Trainer`, and `Debriefing`.

      ### 2.1. Calendar View
      - **Function:** The main dashboard and default view of the application.
      - **Display:** It presents a weekly grid layout.
      - **Navigation:** Users can navigate to the previous or next week.
      - **Day Cells:** Each cell represents a day and displays a summary of the number of exercises scheduled for that day. A "START" button is enabled if one or more exercises are scheduled.
      - **Interaction:** Clicking a day cell (but not the "START" button) opens the Workout Editor modal for that specific date.

      ### 2.2. Workout Editor (Modal System)
      The editor is a two-stage modal system for managing a day's workout routine.
      - **Daily Workout Modal:**
          - Triggered by clicking a day cell.
          - Displays a list of exercises currently scheduled for the selected date.
          - Allows **removal** of any exercise from the list.
          - Contains an "Add Exercise" button to open the Exercise Library modal.
      - **Exercise Library Modal:**
          - Triggered by the "Add Exercise" button.
          - Displays a complete list of all available exercises defined in the app's configuration.
          - Allows **selection** of an exercise to add to the current day's routine.

      ### 2.3. Interactive Trainer View
      - **Function:** An interactive, state-driven interface that guides the user through a scheduled workout in real-time.
      - **Activation:** Triggered by clicking the "START" button on a day cell in the calendar.
      - **Controls:** Includes a main button for flow control (start/pause) and a secondary button to **terminate** the workout.

      #### Trainer State Machine & Flow
      The trainer operates as a state machine. Each exercise consists of a number of **series**. The primary user flow is as follows:

      1.  **Ready (`ready`):** The trainer displays the current exercise and series number. It shows "READY" inside the progress ring. It awaits user input to begin.
      2.  **Announcing (`announcing`):** Before every new phase, this 0.75-second state is activated. The progress ring is shown as empty. The content inside the ring is replaced by a large, flashing text label announcing the upcoming phase (e.g., "PREPARE", "UP", "REST"). An audio tick alerts the user.
      3.  **Preparing (`preparing`):** A 3-second countdown to prepare the user for the first series of an exercise. The progress ring fills up, and the countdown is displayed inside.
      4.  **Action (`action`):** The core execution phase. The progress ring animates for the duration of the phase, with the countdown and phase label shown inside.
          - For **`reps`**-based exercises, the trainer automatically cycles through timed phases as defined by the exercise's `tempo` object (e.g., `up`, `hold`, `down`), each with its own countdown and progress ring animation.
          - For **`time`**-based exercises, a single countdown for the specified `duration` is run.
      5.  **Paused (`paused`):** The user can pause the workout at any time during a countdown state. The timer and the progress ring animation stop. The user must click "RESUME" to continue.
      6.  **Rest (`rest`):** This state is **only** activated when the trainer encounters a user-defined rest block in the workout sequence. There are no automatic rests between series or exercises. A countdown for the specified `rest` duration is shown, and the progress ring animates accordingly.
      7.  **Advancement:** After completing all series/reps of an exercise, the system automatically proceeds to the next item in the workout list. If the next item is another exercise, it begins immediately. If it is an explicit rest block, the `rest` state is triggered.
      8.  **Finished (`finished`):** Once all exercises and series are complete, the trainer automatically transitions to the Debriefing View.
      9.  **Terminated (`terminate`):** If the user clicks the "Termina" button, the workout is immediately stopped, and the app transitions to the Debriefing View with a partial summary.

      ### 2.4. Debriefing View
      - **Activation:** Appears automatically when a workout is completed or manually terminated.
      - **Content:**
          - **Summary:** Displays a list of all exercises completed during the session. For terminated workouts, it clearly indicates the last attempted exercise and series/rep.
          - **Text Report:** Generates a pre-formatted, multi-line string summarizing the workout, ready for sharing.
      - **Actions:**
          - **Copy for Coach:** Copies the text report to the user's clipboard.
          - **Return to Calendar:** Switches the view back to the main Calendar.
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';

      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          activeWorkout: null,
          completedWorkout: null, // Holds data for the debriefing view
          trainerState: 'idle',
          trainerContext: {},
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        // Custom Logger Function
        function logState(actionType, state) {
            const { activeWorkout, trainerState, trainerContext } = state;
            if (!activeWorkout) return;

            const currentItem = activeWorkout.items[trainerContext.itemIndex];
            const exerciseName = currentItem?.name || 'Riposo';
            const series = `${trainerContext.currentSeries || '-'}/${currentItem?.series || '-'}`;
            const reps = `${trainerContext.currentRep || '-'}/${currentItem?.reps || '-'}`;

            let status = trainerState.toUpperCase();
            if (trainerState === 'announcing' || trainerState === 'action') {
                status += ` (${trainerContext.currentPhase || 'N/A'})`;
            }

            const logString = `Esercizio: ${exerciseName} | Serie: ${series} | Rep: ${reps} | Stato: ${status}`;

            console.log(`%c[${actionType}]`, 'color: #88aaff; font-weight: bold;', logString);
        }

        function dispatch(action) {
          const oldState = { ...state };
          let newState = { ...state };

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d=new Date(state.focusedDate); d.setDate(d.getDate()-7); newState={...state, focusedDate:d}; break; }
            case 'NEXT_WEEK': { const d=new Date(state.focusedDate); d.setDate(d.getDate()+7); newState={...state, focusedDate:d}; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'ADD_EXERCISE_ITEM': {
                const { date, exerciseId } = action.payload;
                const dateKey = `workout-${date}`;
                const exercise = getExerciseById(exerciseId);
                if (!exercise) break;
                const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } };
                break;
            }
            case 'ADD_REST_ITEM': {
                const { date } = action.payload;
                const dateKey = `workout-${date}`;
                const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'REMOVE_WORKOUT_ITEM': {
                const { date, itemId } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId);
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'UPDATE_REST_DURATION': {
                const { date, itemId, newDuration } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                const itemIndex = dayWorkout.findIndex(item => item.id === itemId);
                if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') {
                    dayWorkout[itemIndex].duration = newDuration;
                    newWorkouts[dateKey] = dayWorkout;
                    newState = { ...state, workouts: newWorkouts };
                }
                break;
            }
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const dateKey = `workout-${date}`;
              const workoutItems = state.workouts[dateKey];
              if (!workoutItems || workoutItems.length === 0) break;
              newState = {
                ...state,
                currentView: 'trainer',
                activeWorkout: { date, items: workoutItems, completed: false },
                completedWorkout: null,
                trainerState: 'ready',
                trainerContext: { itemIndex: 0, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0 }
              };
              break;
            }
            case 'FINISH_WORKOUT': {
              newState = { ...state, currentView: 'debriefing', completedWorkout: { ...state.activeWorkout, completed: true }, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'TERMINATE_WORKOUT': {
              const { activeWorkout, trainerContext } = state;
              const partialWorkout = {
                ...activeWorkout,
                completed: false,
                items: activeWorkout.items.slice(0, trainerContext.itemIndex + 1),
                terminationPoint: trainerContext
              };
              newState = { ...state, currentView: 'debriefing', completedWorkout: partialWorkout, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'SET_TRAINER_STATE': {
              newState = { ...state, trainerState: action.payload };
              break;
            }
            case 'PAUSE_TRAINER': {
              if (['paused', 'ready', 'finished'].includes(state.trainerState)) break;
              const { remaining, duration } = action.payload;
              newState = {
                ...state,
                trainerState: 'paused',
                trainerContext: { ...state.trainerContext, remaining, duration, stateBeforePause: state.trainerState },
              };
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState !== 'paused') break;
              newState = { ...state, trainerState: state.trainerContext.stateBeforePause };
              break;
            }
            case 'TIMER_COMPLETE': {
              const { trainerState, activeWorkout, trainerContext } = state;
              const currentItem = activeWorkout.items[trainerContext.itemIndex];

              const advanceToNextItem = () => {
                if (trainerContext.itemIndex < activeWorkout.items.length - 1) {
                  const nextItemIndex = trainerContext.itemIndex + 1;
                  const nextItem = activeWorkout.items[nextItemIndex];
                  const newContext = { itemIndex: nextItemIndex, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0 };
                  const newState = nextItem.type === 'rest' ? 'rest' : 'announcing';
                  if (nextItem.type !== 'rest') {
                      newContext.currentPhase = nextItem.type === 'time' ? 'Esegui' : (Object.keys(nextItem.tempo || {})[0] || 'up');
                  }
                  return { newState, newContext };
                }
                return null; // Signals workout is finished
              };

              let nextState = trainerState;
              let nextContext = { ...trainerContext };

              switch (trainerState) {
                case 'preparing':
                  nextState = 'announcing';
                  const firstItem = activeWorkout.items[0];
                  if (firstItem.type === 'time') { nextContext.currentPhase = 'Esegui'; }
                  else { const tempo = firstItem.tempo || {}; nextContext.currentPhase = Object.keys(tempo)[0] || 'up'; }
                  break;

                case 'announcing':
                  nextState = 'action';
                  break;

                case 'action': {
                  if (currentItem.type === 'exercise') {
                    const tempo = currentItem.tempo || {};
                    const phases = Object.keys(tempo);
                    const nextPhaseIndex = trainerContext.currentPhaseIndex + 1;

                    if (nextPhaseIndex < phases.length) { // More phases in this rep
                      nextState = 'announcing';
                      nextContext.currentPhaseIndex = nextPhaseIndex;
                      nextContext.currentPhase = phases[nextPhaseIndex];
                    } else { // Rep complete
                      nextContext.currentPhaseIndex = 0; // Reset for next rep
                      if (trainerContext.currentRep < currentItem.reps) {
                        nextContext.currentRep++;
                        nextState = 'announcing'; // Start next rep immediately
                        nextContext.currentPhase = phases[0] || 'up';
                      } else if (trainerContext.currentSeries < currentItem.series) {
                        nextContext.currentSeries++;
                        nextContext.currentRep = 1;
                        nextState = 'announcing'; // Start next series immediately
                        nextContext.currentPhase = phases[0] || 'up';
                      } else { // Exercise complete
                        const advance = advanceToNextItem();
                        if (advance) { nextState = advance.newState; nextContext = { ...nextContext, ...advance.newContext }; }
                        else { nextState = 'finished'; }
                      }
                    }
                  } else if (currentItem.type === 'time') {
                      if (trainerContext.currentSeries < currentItem.series) {
                          nextContext.currentSeries++;
                          nextState = 'announcing'; // Start next series immediately
                          nextContext.currentPhase = 'Esegui';
                      } else {
                          const advance = advanceToNextItem();
                          if (advance) { nextState = advance.newState; nextContext = { ...nextContext, ...advance.newContext }; }
                          else { nextState = 'finished'; }
                      }
                  }
                  break;
                }

                case 'rest': {
                  // After an explicit rest, always advance to the next item
                  const advance = advanceToNextItem();
                  if (advance) { nextState = advance.newState; nextContext = { ...nextContext, ...advance.newContext }; }
                  else { nextState = 'finished'; }
                  break;
                }
              }
              newState = { ...state, trainerState: nextState, trainerContext: nextContext };
              break;
            }
            default:
              return;
          }
          state = newState;
          if (state !== oldState) {
            if (action.type !== 'PAUSE_TRAINER' && action.type !== 'RESUME_TRAINER') {
                logState(action.type, state);
            }
            if (state.workouts !== oldState.workouts) {
              saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
            }
            notify();
          }
        }
        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      const store = createStore();
      export default store;
  - file: src/views/DebriefingView.js
    content: |
      import store from '../modules/store.js';

      function generateSummary(completedWorkout) {
          if (!completedWorkout) return '<p>Nessun dato di allenamento disponibile.</p>';

          const title = completedWorkout.completed
              ? '<h2>Workout Completato!</h2>'
              : '<h2>Workout Interrotto</h2>';

          const itemsHtml = completedWorkout.items.map((item, index) => {
              if (item.type === 'rest') {
                  return `<li>Riposo: ${item.duration}s</li>`;
              }
              const series = item.series || 1;
              const reps = item.reps ? `${item.reps} reps` : `${item.duration}s`;
              let status = '';
              if (!completedWorkout.completed && index === completedWorkout.items.length - 1) {
                  const point = completedWorkout.terminationPoint;
                  status = ` (interrotto a serie ${point.currentSeries}/${series})`;
              }
              return `<li>${item.name}: ${series} x ${reps}${status}</li>`;
          }).join('');

          return `${title}<ul>${itemsHtml}</ul>`;
      }

      function generateTextForCoach(completedWorkout) {
          if (!completedWorkout) return 'Nessun dato disponibile.';
          const date = new Date(completedWorkout.date).toLocaleDateString('it-IT');
          const status = completedWorkout.completed ? 'Completato' : 'Interrotto';
          let report = `Report Allenamento - ${date} (${status})\n\n`;

          completedWorkout.items.forEach((item, index) => {
              if (item.type === 'rest') {
                  report += `- Riposo: ${item.duration}s\n`;
              } else {
                  const series = item.series || 1;
                  const reps = item.reps ? `${item.reps} reps` : `${item.duration}s`;
                  let terminationInfo = '';
                  if (!completedWorkout.completed && index === completedWorkout.items.length - 1) {
                      const point = completedWorkout.terminationPoint;
                      terminationInfo = ` (interrotto a serie ${point.currentSeries}/${series})`;
                  }
                  report += `- ${item.name}: ${series} x ${reps}${terminationInfo}\n`;
              }
          });
          return report;
      }

      function render(element) {
          const { completedWorkout } = store.getState();
          const summaryHtml = generateSummary(completedWorkout);
          const actionsHtml = `
              <div class="debriefing-actions">
                  <button class="copy-btn">Copia per il Coach</button>
                  <button class="return-btn">Torna al Calendario</button>
              </div>
          `;
          element.innerHTML = `
              <div class="debriefing-container">
                  ${summaryHtml}
                  ${actionsHtml}
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              if (event.target.closest('.return-btn')) {
                  store.dispatch({ type: 'CHANGE_VIEW', payload: 'calendar' });
              }
              if (event.target.closest('.copy-btn')) {
                  const { completedWorkout } = store.getState();
                  const textToCopy = generateTextForCoach(completedWorkout);
                  navigator.clipboard.writeText(textToCopy).then(() => {
                      alert('Riepilogo copiato negli appunti!');
                  }).catch(err => {
                      console.error('Errore nella copia:', err);
                      alert('Impossibile copiare il testo.');
                  });
              }
          });

          store.subscribe(() => render(element));
          render(element);
      }
  - file: src/views/TrainerView.js
    content: |
      import store from '../modules/store.js';
      import { getExerciseById } from '../modules/exerciseRepository.js';

      let animationFrameId = null;
      let animationStartTime = null;

      export function init(element) {
          element.addEventListener('click', (event) => {
              const mainButton = event.target.closest('.trainer-main-btn');
              const terminateButton = event.target.closest('.trainer-terminate-btn');

              if (terminateButton) {
                  if (confirm('Sei sicuro di voler terminare l\'allenamento?')) {
                      store.dispatch({ type: 'TERMINATE_WORKOUT' });
                  }
                  return;
              }

              if (!mainButton) return;

              const { trainerState } = store.getState();
              switch (trainerState) {
                  case 'ready':
                      store.dispatch({ type: 'SET_TRAINER_STATE', payload: 'preparing' });
                      break;
                  case 'paused':
                      store.dispatch({ type: 'RESUME_TRAINER' });
                      break;
                  case 'finished':
                      store.dispatch({ type: 'FINISH_WORKOUT' });
                      break;
                  case 'preparing':
                  case 'action':
                  case 'rest':
                  case 'announcing':
                      if (animationFrameId) cancelAnimationFrame(animationFrameId);
                      const elapsed = performance.now() - animationStartTime;
                      const remaining = mainButton.dataset.duration - elapsed;
                      store.dispatch({ type: 'PAUSE_TRAINER', payload: { remaining: remaining > 0 ? remaining : 0, duration: mainButton.dataset.duration } });
                      break;
              }
          });

          element.addEventListener('animateRing', ({ detail }) => {
              if (animationFrameId) cancelAnimationFrame(animationFrameId);
              const ringEl = element.querySelector('.progress-ring__foreground');
              const timerEl = element.querySelector('.progress-ring__timer');
              if (!ringEl || !timerEl) return;
              const circumference = 2 * Math.PI * ringEl.r.baseVal.value;
              const { trainerContext } = store.getState();

              const isResuming = trainerContext.stateBeforePause && trainerContext.remaining > 0;
              const duration = isResuming ? trainerContext.remaining : detail.duration;
              let startTime = performance.now();
              animationStartTime = startTime;
              if (isResuming) {
                  store.dispatch({ type: 'UPDATE_TRAINER_CONTEXT', payload: { remaining: 0, stateBeforePause: null }});
              }

              const animationStep = (timestamp) => {
                  const elapsed = timestamp - startTime;
                  const progress = Math.min(1, elapsed / duration);
                  ringEl.style.strokeDashoffset = circumference * (1 - progress);

                  if (store.getState().trainerState !== 'announcing') {
                    timerEl.textContent = Math.ceil((duration - elapsed) / 1000);
                  } else {
                    timerEl.textContent = '';
                  }

                  if (elapsed < duration) {
                      animationFrameId = requestAnimationFrame(animationStep);
                  } else {
                      ringEl.style.strokeDashoffset = 0;
                      timerEl.textContent = 0;
                      if (detail.onComplete) detail.onComplete();
                  }
              };
              animationFrameId = requestAnimationFrame(animationStep);
          });

          function runStateBasedTimer() {
              const { trainerState, trainerContext, activeWorkout } = store.getState();

              if (animationFrameId && trainerState !== 'paused') {
                  cancelAnimationFrame(animationFrameId);
                  animationFrameId = null;
              }

              const onComplete = () => store.dispatch({ type: 'TIMER_COMPLETE' });
              const currentItem = activeWorkout.items[trainerContext.itemIndex];
              let duration = 0;

              switch(trainerState) {
                  case 'preparing':
                      duration = 3000;
                      break;
                  case 'announcing':
                      duration = 750;
                      break;
                  case 'action':
                      if (currentItem.type === 'time') {
                          duration = (currentItem.duration || 10) * 1000;
                      } else {
                          const tempo = currentItem.tempo || {};
                          duration = (tempo[trainerContext.currentPhase] || 1) * 1000;
                      }
                      break;
                  case 'rest': {
                      let restDuration = 60; // Default
                      if (currentItem.type === 'rest') {
                          restDuration = currentItem.duration;
                      } else if (currentItem.exerciseId) {
                          restDuration = getExerciseById(currentItem.exerciseId)?.defaultRest || 60;
                      }
                      duration = restDuration * 1000;
                      break;
                  }
                  default:
                      // No timer for states like 'ready', 'paused', 'finished'
                      return;
              }
              element.dispatchEvent(new CustomEvent('animateRing', { detail: { duration, onComplete } }));
          }

          function render() {
              const { activeWorkout, trainerState, trainerContext } = store.getState();
              if (!activeWorkout) { element.innerHTML = '<h2>Nessun workout attivo.</h2>'; return; }

              const currentItem = activeWorkout.items[trainerContext.itemIndex];
              const radius = 90;
              const circumference = 2 * Math.PI * radius;
              let phaseText = '', instructionText = '', buttonText = '', timerText = '', phaseClass = '';
              let ringOffset = circumference;
              const isExercise = currentItem.type === 'exercise' || currentItem.type === 'time';
              let currentDuration = 0;
              let terminateButtonHidden = trainerState === 'finished' || trainerState === 'ready';

              switch (trainerState) {
                  case 'ready':
                      phaseText = 'PRONTO'; instructionText = `Premi INIZIA per cominciare`; buttonText = 'INIZIA';
                      break;
                  case 'preparing':
                      phaseText = 'PREPARATI'; instructionText = 'Inizia il movimento...'; buttonText = 'PAUSA'; timerText = '3'; currentDuration = 3000;
                      break;
                  case 'rest': {
                      let restDuration = 60;
                      if (currentItem.type === 'rest') { restDuration = currentItem.duration; }
                      else if (currentItem.exerciseId) { restDuration = getExerciseById(currentItem.exerciseId)?.defaultRest || 60; }
                      phaseText = 'RIPOSO'; instructionText = 'Recupera'; buttonText = 'PAUSA'; timerText = restDuration; currentDuration = restDuration * 1000;
                      break;
                  }
                  case 'announcing':
                      phaseText = trainerContext.currentPhase?.toUpperCase() || '';
                      instructionText = `Prossima fase: ${phaseText}`; buttonText = 'PAUSA'; phaseClass = 'is-flashing'; currentDuration = 750;
                      break;
                  case 'action':
                      phaseText = trainerContext.currentPhase?.toUpperCase() || '';
                      if (currentItem.type === 'time') { currentDuration = currentItem.duration * 1000; }
                      else { const tempo = currentItem.tempo || {}; currentDuration = (tempo[trainerContext.currentPhase] || 1) * 1000; }
                      instructionText = 'Esegui il movimento'; buttonText = 'PAUSA';
                      break;
                  case 'paused': {
                      const prevState = trainerContext.stateBeforePause;
                      if(prevState === 'preparing') { phaseText = 'PREPARATI'; }
                      else if(prevState === 'rest') { phaseText = 'RIPOSO'; }
                      else if(prevState === 'announcing' || prevState === 'action') { phaseText = trainerContext.currentPhase?.toUpperCase() || ''; }
                      if(prevState === 'announcing') { phaseClass = 'is-flashing'; }

                      instructionText = 'Pausa'; buttonText = 'RIPRENDI';
                      if(prevState !== 'announcing') { timerText = Math.ceil(trainerContext.remaining/1000); }
                      ringOffset = circumference * (1 - ( (trainerContext.duration - trainerContext.remaining) / trainerContext.duration) );
                      currentDuration = trainerContext.duration;
                      break;
                  }
                  case 'finished':
                      phaseText = 'FINE'; instructionText = 'Workout completato!'; buttonText = 'DEBRIEFING';
                      break;
                  default: phaseText = 'IDLE'; instructionText = 'Stato non riconosciuto'; buttonText = 'RESET';
              }
              const headerTitle = currentItem.name || 'Riposo';
              const seriesText = isExercise ? `SERIE ${trainerContext.currentSeries} / ${currentItem.series || 1}` : '';
              const repsText = currentItem.type === 'exercise' ? `REP ${trainerContext.currentRep} / ${currentItem.reps || 1}` : '';

              element.innerHTML = `
                  <div class="trainer-container">
                      <header class="trainer-header">
                          <h2>${headerTitle}</h2>
                          <p>${seriesText} ${repsText ? `| ${repsText}` : ''}</p>
                      </header>
                      <div class="progress-ring">
                          <svg>
                              <circle class="progress-ring__background" stroke-width="10" r="${radius}" cx="50%" cy="50%"></circle>
                              <circle class="progress-ring__foreground" style="stroke-dashoffset: ${ringOffset};" stroke-width="10" r="${radius}" cx="50%" cy="50%" stroke-dasharray="${circumference}"></circle>
                          </svg>
                          <div class="progress-ring__text">
                              <div class="progress-ring__phase ${phaseClass}">${phaseText}</div>
                              <div class="progress-ring__timer">${timerText}</div>
                          </div>
                      </div>
                      <footer class="trainer-footer">
                          <p class="trainer-instruction">${instructionText}</p>
                          <div class="trainer-controls">
                              <button class="trainer-main-btn" data-duration="${currentDuration}">${buttonText}</button>
                              <button class="trainer-terminate-btn" ${terminateButtonHidden ? 'hidden' : ''}>Termina</button>
                          </div>
                      </footer>
                  </div>
              `;

              if (trainerState !== 'paused') {
                runStateBasedTimer();
              }
          }
          store.subscribe(render);
          render();
      }
commands:
  - "echo 'DebriefingView structure created and navigation enabled.'"