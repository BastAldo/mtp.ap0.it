commit_message: "fix(trainer): Implement ACTION/REST states and wire trainer controls"
rationale: |
  Questo patch corregge il blocco della macchina a stati del trainer e attiva i pulsanti di controllo, rendendo il workout completamente interattivo.

  1.  **Risoluzione Blocco Logico:** Il problema principale era l'assenza di logica per gli stati `ACTION` e `REST` in `trainer.js`. La macchina a stati è stata completata per gestire correttamente sia esercizi a tempo che a ripetizioni (con una nuova funzione `runTempoCycle` per i cicli up/hold/down). Ora il trainer avanza correttamente attraverso serie, riposi e esercizi successivi.

  2.  **Attivazione Pulsanti di Controllo:** I pulsanti 'Pausa' e 'Termina' sono stati collegati.
      - Il modulo `ui.js` è stato aggiornato per gestire il testo e lo stato (attivo/disattivo) dei pulsanti in base allo stato corrente del trainer (es. "Pausa" diventa "Riprendi").
      - È stata creata una funzione di inizializzazione che collega i click sui pulsanti a nuove funzioni di controllo (`pauseOrResumeTrainer`, `terminateTrainer`) nel modulo `trainer.js`, mantenendo la separazione architetturale.

  3.  **Gestione Pausa/Ripresa:** È stata implementata una logica di pausa robusta che ferma e riprende i timer (`setInterval`/`setTimeout`), preservando lo stato del workout.

  4.  **Flusso Completo:** Con queste modifiche, il trainer può ora guidare un utente attraverso un workout multi-esercizio completo, dall'inizio alla fine, con piena interattività.
patches:
  - file: src/main.js
    content: |
      /**
       * @file main.js
       * The main entry point for the application.
       * Orchestrates all other modules.
       */
      import * as storage from './storage.js';
      import { initCalendar } from './calendar.js';
      import { initModals } from './modal.js';
      import { initTrainerControls } from './ui.js';
      import { pauseOrResumeTrainer, terminateTrainer } from './trainer.js';


      /**
       * The main function to initialize the application.
       */
      function main() {
        console.log('Application Initialized.');
        console.log('Fetching all workouts from storage:', storage.getWorkouts());

        // Initialize all primary components
        initCalendar();
        initModals();
        // Wire up trainer controls once at startup
        initTrainerControls({
          onPauseResume: pauseOrResumeTrainer,
          onTerminate: terminateTrainer
        });
      }

      // Initialize the app once the DOM is fully loaded.
      document.addEventListener('DOMContentLoaded', main);
  - file: src/ui.js
    content: |
      /**
       * @file ui.js
       * Responsible for all direct DOM manipulations and user feedback (visual/audio).
       */

      // --- Views ---
      const calendarView = document.getElementById('calendar-view');
      const trainerView = document.getElementById('trainer-view');
      const debriefingView = document.getElementById('debriefing-view');
      const views = { calendar: calendarView, trainer: trainerView, debriefing: debriefingView };

      // --- Trainer View Elements ---
      const trainerExerciseTitle = document.getElementById('trainer-exercise-title');
      const trainerSeriesCounter = document.getElementById('trainer-series-counter');
      const trainerMainText = document.getElementById('trainer-main-text');
      const trainerMainDisplay = document.getElementById('trainer-main-display');
      const trainerDescription = document.getElementById('trainer-description');
      const pauseResumeBtn = document.getElementById('pause-resume-btn');
      const terminateBtn = document.getElementById('terminate-btn');


      /**
       * Shows the specified view and hides all others.
       * @param {'calendar' | 'trainer' | 'debriefing'} viewName The name of the view to show.
       */
      export function showView(viewName) {
        Object.values(views).forEach(view => view.classList.remove('view--active'));
        if (views[viewName]) {
          views[viewName].classList.add('view--active');
        }
      }

      /**
       * Updates the entire trainer UI based on the current state of the workout.
       * @param {object} state The current state object from the trainer module.
       */
      export function updateTrainerUI(state) {
        const { exercise, currentSeries, phase, countdown, message, currentState } = state;

        trainerExerciseTitle.textContent = exercise ? exercise.name : 'Pronti?';
        trainerSeriesCounter.textContent = exercise ? `Serie ${currentSeries} / ${exercise.series}` : '';
        trainerMainText.textContent = message || countdown;
        trainerDescription.textContent = phase ? `Fase: ${phase.toUpperCase()}` : '';

        // Update button text and state
        terminateBtn.disabled = currentState === 'idle' || currentState === 'finished';
        pauseResumeBtn.disabled = !(currentState === 'action' || currentState === 'paused');
        
        if (currentState === 'paused') {
            pauseResumeBtn.textContent = 'Riprendi';
        } else {
            pauseResumeBtn.textContent = 'Pausa';
        }

        // Handle flashing animation for announcements
        if (phase === 'announcing') {
          trainerMainDisplay.classList.add('is-flashing');
        } else {
          trainerMainDisplay.classList.remove('is-flashing');
        }
      }

      /**
       * Attaches event listeners to the trainer control buttons.
       * @param {object} handlers - Object with callback functions.
       * @param {function} handlers.onPauseResume - The function to call when pause/resume is clicked.
       * @param {function} handlers.onTerminate - The function to call when terminate is clicked.
       */
      export function initTrainerControls(handlers) {
          pauseResumeBtn.addEventListener('click', () => handlers.onPauseResume());
          terminateBtn.addEventListener('click', () => handlers.onTerminate());
      }

      /**
       * Plays a short, high-frequency audio tick.
       * Uses Web Audio API for precise timing.
       */
      let audioCtx;
      export function playTick() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A6 note
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.05);
      }
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       * It is decoupled from the DOM.
       */
      import * as ui from './ui.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        PREPARING: 'preparing',
        ACTION: 'action',
        PAUSED: 'paused',
        REST: 'rest',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '', // e.g., 'up', 'hold', 'down', 'rest'
        countdown: 0,
        message: '',
        timerId: null,
        pausedTime: 0,
      };

      function clearTimers() {
        clearInterval(state.timerId);
        clearTimeout(state.timerId);
        state.timerId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState, message: '' };
        ui.updateTrainerUI(state);

        switch (newState) {
          case STATES.READY:
            state.exercise = state.workout[state.currentExerciseIndex];
            state.currentSeries = 1;
            setState(STATES.PREPARING);
            break;

          case STATES.PREPARING:
            setState(STATES.ANNOUNCING, { phase: 'announcing', message: 'Preparati!', nextState: STATES.ACTION });
            break;

          case STATES.ACTION:
             runCountdown(3, 'VIA!', () => {
                if (state.exercise.type === 'reps') {
                    state.currentRep = 1;
                    runTempoCycle();
                } else { // time
                    runCountdown(state.exercise.duration, 'Stop!', STATES.REST);
                }
            });
            break;

          case STATES.REST:
            const isLastSeries = state.currentSeries >= state.exercise.series;
            const isLastExercise = isLastSeries && state.currentExerciseIndex >= state.workout.length - 1;

            if (isLastExercise) {
                setState(STATES.FINISHED);
                return;
            }

            setState(STATES.ANNOUNCING, {
                phase: 'announcing',
                message: 'Riposo',
                nextState: STATES.REST_COUNTDOWN
            });
            break;
            
          case STATES.REST_COUNTDOWN:
            runCountdown(state.exercise.rest, 'Pronti', () => {
                 if (state.currentSeries < state.exercise.series) {
                    state.currentSeries++;
                    setState(STATES.PREPARING);
                 } else {
                    state.currentExerciseIndex++;
                    setState(STATES.READY);
                 }
            });
            break;

          case STATES.ANNOUNCING:
            ui.playTick();
            state.timerId = setTimeout(() => {
              const next = state.nextState;
              state.nextState = null;
              setState(next);
            }, 750);
            break;

          case STATES.FINISHED:
              ui.showView('calendar'); // Placeholder, will be debriefing view
              break;

          case STATES.IDLE:
          case STATES.PAUSED:
            // Do nothing, wait for user input
            break;
        }
      }
      
      function runCountdown(seconds, finalMessage, onComplete) {
          state.countdown = seconds;
          state.phase = 'countdown';
          ui.updateTrainerUI(state);
          ui.playTick();

          state.timerId = setInterval(() => {
              state.countdown--;
              ui.updateTrainerUI(state);
              if (state.countdown > 0) {
                 ui.playTick();
              } else {
                 ui.playTick();
                 ui.playTick();
              }

              if (state.countdown <= 0) {
                  clearInterval