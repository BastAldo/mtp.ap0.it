commit_message: "fix(core): Stabilizzazione critica tramite semplificazione radicale"
rationale: |
  Questo commit affronta il fallimento sistemico dell'applicazione che ne impediva l'avvio e la reattività. La strategia è una semplificazione radicale per garantire la stabilità immediata.

  1.  **Fusione del Reducer:** Il `trainerReducer.js` è stato eliminato e la sua logica è stata fusa di nuovo all'interno dello `store.js`. Questa è la modifica più critica, volta a eliminare ogni possibile errore di importazione o integrazione tra moduli che causava il blocco dell'applicazione all'avvio.

  2.  **Log di Avvio:** Sono stati aggiunti `console.log` "grezzi" e senza dipendenze all'inizio dei file principali per garantire che, in caso di errore fatale, si abbia almeno un'indicazione su quale file sia stato caricato.

  3.  **Semplificazione dello Stato:** La struttura dello stato e le azioni sono state semplificate per essere più dirette e prevedibili, rimuovendo la complessità che portava a stati incoerenti.

  4.  **Viste Resilienti:** Tutte le funzioni di renderizzazione ora contengono controlli di sicurezza per prevenire errori dovuti a dati non ancora disponibili durante il caricamento.

  L'obiettivo di questo commit non è l'eleganza architetturale, ma la stabilità operativa. L'applicazione ora dovrebbe essere avviabile, reattiva e fornire log utili.
patches:
  - file: src/main.js
    content: |
      console.log('File loaded: main.js');
      import store from './modules/store.js';
      import { init as initCalendarView } from './views/CalendarView.js';
      import { init as initTrainerView } from './views/TrainerView.js';
      import { init as initDebriefingView } from './views/DebriefingView.js';
      import { init as initModal } from './ui/Modal.js';
      import { init as initNotice } from './ui/Notice.js';
      import { loadFromStorage, saveToStorage } from './modules/storage.js';
      import { mockWorkouts } from './modules/_mockData.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';

      const views = {
          calendar: document.getElementById('calendar-view'),
          trainer: document.getElementById('trainer-view'),
          debriefing: document.getElementById('debriefing-view'),
      };
      const initializedViews = new Set();

      function initializeApp() {
        console.log('Initializing App...');
        let workouts = loadFromStorage(WORKOUTS_STORAGE_KEY);
        if (!workouts) {
          saveToStorage(WORKOUTS_STORAGE_KEY, mockWorkouts);
          workouts = mockWorkouts;
        }
        store.dispatch({ type: 'SET_WORKOUTS', payload: workouts });

        initCalendarView(views.calendar);
        initializedViews.add('calendar');
        initModal(document.getElementById('modal-container'));
        initNotice(document.getElementById('notice-container'));
        console.log('App Initialized.');
      }

      let currentActiveView = views.calendar;
      function handleViewChange() {
        const { currentView } = store.getState();
        if(!views[currentView]) return; // Safety check

        const newActiveViewEl = views[currentView];

        if (currentActiveView !== newActiveViewEl) {
          currentActiveView.classList.remove('view--active');
          newActiveViewEl.classList.add('view--active');
          currentActiveView = newActiveViewEl;

          if (!initializedViews.has(currentView)) {
            if (currentView === 'trainer') initTrainerView(views.trainer);
            else if (currentView === 'debriefing') initDebriefingView(views.debriefing);
            initializedViews.add(currentView);
          }
        }
      }

      function gameLoop(timestamp) {
          store.dispatch({ type: 'TICK', payload: { timestamp } });
          requestAnimationFrame(gameLoop);
      }

      store.subscribe(handleViewChange);

      initializeApp();
      requestAnimationFrame(gameLoop);
  - file: src/modules/store.js
    content: |
      console.log('File loaded: store.js');
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';
      import { generatePlan } from './planGenerator.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const clone = (data) => JSON.parse(JSON.stringify(data));

      const trainerInitialState = {
          status: 'idle',
          executionPlan: null,
          currentStepIndex: 0,
          stepStartTime: 0,
          remaining: 0,
          activeWorkout: null,
          completedWorkout: null,
      };

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          trainer: { ...trainerInitialState },
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        const dispatch = (action) => {
          console.log(`Dispatching: ${action.type}`);
          const oldState = state;
          
          let newState = { ...state };

          // --- Trainer Logic (Re-integrated for stability) ---
          const trainerState = { ...newState.trainer };
          switch (action.type) {
              case 'START_WORKOUT': {
                  const { date } = action.payload;
                  const workoutItems = newState.workouts[`workout-${date}`];
                  if (workoutItems?.length > 0) {
                      const plan = generatePlan(workoutItems);
                      newState.currentView = 'trainer';
                      trainerState.status = 'ready';
                      trainerState.executionPlan = plan;
                      trainerState.activeWorkout = { date, items: workoutItems };
                      trainerState.currentStepIndex = 0;
                  }
                  break;
              }
              case 'START_TRAINER':
                  if (trainerState.status === 'ready') {
                      trainerState.status = 'running';
                      trainerState.stepStartTime = performance.now();
                      trainerState.remaining = trainerState.executionPlan[0].duration;
                  }
                  break;
              case 'PAUSE_TRAINER':
                  if (trainerState.status === 'running') {
                      trainerState.status = 'paused';
                  }
                  break;
              case 'RESUME_TRAINER':
                  if (trainerState.status === 'paused') {
                      trainerState.status = 'running';
                      trainerState.stepStartTime = performance.now() - (trainerState.executionPlan[trainerState.currentStepIndex].duration - trainerState.remaining);
                  }
                  break;
              case 'TICK':
                  if (trainerState.status === 'running') {
                      const { timestamp } = action.payload;
                      const { duration } = trainerState.executionPlan[trainerState.currentStepIndex];
                      const elapsedTime = timestamp - trainerState.stepStartTime;
                      const newRemaining = duration - elapsedTime;

                      if (newRemaining <= 0) {
                          const nextStepIndex = trainerState.currentStepIndex + 1;
                          if (nextStepIndex < trainerState.executionPlan.length) {
                              const nextStep = trainerState.executionPlan[nextStepIndex];
                              trainerState.currentStepIndex = nextStepIndex;
                              trainerState.stepStartTime = performance.now();
                              trainerState.remaining = nextStep.duration;
                              if (nextStep.type === 'finished') {
                                  trainerState.status = 'finished';
                                  trainerState.completedWorkout = { ...trainerState.activeWorkout, completed: true };
                              }
                          }
                      } else {
                          trainerState.remaining = newRemaining;
                      }
                  }
                  break;
              case 'TERMINATE_WORKOUT':
                  if (trainerState.status !== 'idle' && trainerState.status !== 'finished') {
                      const currentStep = trainerState.executionPlan[trainerState.currentStepIndex];
                      const itemIndex = trainerState.activeWorkout.items.findIndex(i => i.id === currentStep.item?.id);
                      trainerState.status = 'finished';
                      trainerState.completedWorkout = { ...trainerState.activeWorkout, completed: false, terminationPoint: { itemIndex: itemIndex > -1 ? itemIndex : 0, currentSeries: currentStep.context?.currentSeries || 1 }};
                      newState.currentView = 'debriefing';
                  }
                  break;
              case 'FINISH_WORKOUT':
                  if (trainerState.status === 'finished') {
                      newState.currentView = 'debriefing';
                  }
                  break;
          }
          newState.trainer = trainerState;

          // --- General App Logic ---
          switch (action.type) {
            case 'CHANGE_VIEW': newState.currentView = action.payload; break;
            case 'PREV_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() - 7); newState.focusedDate = d; break; }
            case 'NEXT_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() + 7); newState.focusedDate = d; break; }
            case 'SET_WORKOUTS': newState.workouts = action.payload; break;
            case 'OPEN_MODAL': newState.isModalOpen = true; newState.modalContext = action.payload; break;
            case 'CLOSE_MODAL': newState.isModalOpen = false; newState.modalContext = null; break;
            case 'SHOW_NOTICE': newState.notice = { message: action.payload.message, id: Date.now() }; break;
            case 'ADD_EXERCISE_ITEM': { const { date, exerciseId } = action.payload; const dateKey = `workout-${date}`; const exercise = getExerciseById(exerciseId); if (!exercise) break; const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id }; const newWorkouts = clone(newState.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState.workouts = newWorkouts; newState.modalContext = { type: 'EDIT_WORKOUT', date }; break; }
            case 'ADD_REST_ITEM': { const { date } = action.payload; const dateKey = `workout-${date}`; const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 }; const newWorkouts = clone(newState.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState.workouts = newWorkouts; break; }
            case 'REMOVE_WORKOUT_ITEM': { const { date, itemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = clone(newState.workouts); newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId); newState.workouts = newWorkouts; break; }
            case 'UPDATE_REST_DURATION': { const { date, itemId, newDuration } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = clone(newState.workouts); const dayWorkout = newWorkouts[dateKey] || []; const itemIndex = dayWorkout.findIndex(item => item.id === itemId); if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') { dayWorkout[itemIndex].duration = newDuration; newWorkouts[dateKey] = dayWorkout; newState.workouts = newWorkouts; } break; }
            case 'REORDER_WORKOUT_ITEMS': { const { date, draggedItemId, targetItemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = clone(newState.workouts); const items = newWorkouts[dateKey] || []; const draggedIndex = items.findIndex(item => item.id === draggedItemId); const targetIndex = items.findIndex(item => item.id === targetItemId); if (draggedIndex > -1 && targetIndex > -1) { const [draggedItem] = items.splice(draggedIndex, 1); items.splice(targetIndex, 0, draggedItem); newWorkouts[dateKey] = items; newState.workouts = newWorkouts; } break; }
          }
          
          state = newState;

          if (oldState.workouts !== state.workouts) {
            saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
          }
          notify();
        };

        return {
          getState: () => state,
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      
      const store = createStore();
      export default store;
  - file: src/views/TrainerView.js
    content: |
      import store from '../modules/store.js';

      function render(element) {
          const { trainer } = store.getState();
          // Defensive check: Do not render if the trainer isn't ready
          if (!trainer || !trainer.executionPlan || !trainer.executionPlan[trainer.currentStepIndex]) {
              element.innerHTML = '<h2>Caricamento...</h2>';
              return;
          }
          
          const { status, executionPlan, currentStepIndex, remaining } = trainer;
          const currentStep = executionPlan[currentStepIndex];
          const { type, duration, headerTitle, mainText } = currentStep;

          const radius = 90;
          const circumference = 2 * Math.PI * radius;
          
          let timerText = '', buttonText = '', instructionText = '';
          const isFlashing = type === 'announcing';
          const terminateButtonHidden = status === 'finished' || status === 'ready';
          
          const progress = duration > 0 ? (duration - Math.max(0, remaining)) / duration : 0;
          const ringOffset = circumference * (1 - progress);

          if (duration > 0 && (status === 'running' || status === 'paused')) {
              timerText = Math.ceil(remaining / 1000);
          }

          switch (status) {
              case 'ready': buttonText = 'INIZIA'; instructionText = 'Premi INIZIA per cominciare'; break;
              case 'running': buttonText = 'PAUSA'; instructionText = 'Esegui'; break;
              case 'paused': buttonText = 'RIPRENDI'; instructionText = 'Pausa'; break;
              case 'finished': buttonText = 'DEBRIEFING'; instructionText = 'Ben fatto!'; break;
              default: buttonText = '...'; instructionText = 'Stato non valido';
          }
          
          const subHeaderText = currentStep.context?.totalSeries ? `SERIE ${currentStep.context.currentSeries}/${currentStep.context.totalSeries}` : '';

          element.innerHTML = `
              <div class="trainer-container">
                  <header class="trainer-header">
                      <h2>${headerTitle}</h2>
                      <p>${subHeaderText || ' '}</p>
                  </header>
                  <div class="progress-ring">
                      <svg>
                          <circle class="progress-ring__background" stroke-width="10" r="${radius}" cx="50%" cy="50%"></circle>
                          <circle class="progress-ring__foreground" style="stroke-dashoffset: ${ringOffset};" stroke-width="10" r="${radius}" cx="50%" cy="50%" stroke-dasharray="${circumference}"></circle>
                      </svg>
                      <div class="progress-ring__text">
                          <div class="progress-ring__phase ${isFlashing ? 'is-flashing' : ''}">${mainText}</div>
                          <div class="progress-ring__timer">${timerText}</div>
                      </div>
                  </div>
                  <footer class="trainer-footer">
                      <p class="trainer-instruction">${instructionText}</p>
                      <div class="trainer-controls">
                          <button class="trainer-main-btn">${buttonText}</button>
                          <button class="trainer-terminate-btn" ${terminateButtonHidden ? 'hidden' : ''}>Termina</button>
                      </div>
                  </footer>
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              const mainButton = event.target.closest('.trainer-main-btn');
              const terminateButton = event.target.closest('.trainer-terminate-btn');
              
              const { trainer } = store.getState();
              if(!trainer) return; // Defensive check

              if (terminateButton) {
                  store.dispatch({ type: 'TERMINATE_WORKOUT' });
                  return;
              }

              if (!mainButton) return;
              
              switch (trainer.status) {
                  case 'ready': store.dispatch({ type: 'START_TRAINER' }); break;
                  case 'running': store.dispatch({ type: 'PAUSE_TRAINER' }); break;
                  case 'paused': store.dispatch({ type: 'RESUME_TRAINER' }); break;
                  case 'finished': store.dispatch({ type: 'FINISH_WORKOUT' }); break;
              }
          });

          store.subscribe(() => {
              if (element.classList.contains('view--active')) {
                  render(element);
              }
          });

          if (element.classList.contains('view--active')) {
            render(element);
          }
      }
  - file: src/views/DebriefingView.js
    content: |
      import store from '../modules/store.js';

      function generateSummaryHtml(completedWorkout) {
          if (!completedWorkout || !completedWorkout.items) {
              return '<p>Nessun dato di allenamento disponibile.</p>';
          }

          const title = completedWorkout.completed
              ? '<h2>Workout Completato!</h2>'
              : '<h2>Workout Interrotto</h2>';

          const termPoint = completedWorkout.terminationPoint;

          const itemsHtml = completedWorkout.items.map((item, index) => {
              let itemClass = 'debrief-item';
              let statusText = '';
              let animationDelay = `style="animation-delay: ${index * 50}ms;"`;

              if (completedWorkout.completed) {
                  itemClass += ' debrief-item--completed';
              } else if (termPoint) {
                  if (index < termPoint.itemIndex) {
                      itemClass += ' debrief-item--completed';
                  } else if (index === termPoint.itemIndex) {
                      itemClass += ' debrief-item--terminated';
                      statusText = `(interrotto alla serie ${termPoint.currentSeries})`;
                  } else {
                      itemClass += ' debrief-item--skipped';
                      animationDelay = '';
                  }
              }

              let mainText = '';
              if (item.type === 'rest') {
                  mainText = `Riposo: ${item.duration}s`;
              } else {
                  const series = item.series || 1;
                  const reps = item.reps ? `${item.reps} reps` : `${item.duration}s`;
                  mainText = `${item.name}: ${series}x${reps} ${statusText}`;
              }

              return `<li class="${itemClass}" ${animationDelay}>${mainText}</li>`;
          }).join('');

          return `${title}<ul class="debrief-list">${itemsHtml}</ul>`;
      }

      function generateTextForCoach(completedWorkout) {
          if (!completedWorkout || !completedWorkout.items) return 'Nessun dato disponibile.';
          const date = new Date(completedWorkout.date).toLocaleDateString('it-IT');
          const status = completedWorkout.completed ? 'Completato' : 'Interrotto';
          let report = `Report Allenamento - ${date} (${status})\n====================\n\n`;

          const termPoint = completedWorkout.terminationPoint;

          completedWorkout.items.forEach((item, index) => {
              let statusTag = '[✓]';
              if (!completedWorkout.completed && termPoint) {
                  if (index < termPoint.itemIndex) statusTag = '[✓]';
                  else if (index === termPoint.itemIndex) statusTag = '[✗]';
                  else statusTag = '[-]';
              }

              if (item.type === 'rest') {
                  report += `${statusTag} Riposo: ${item.duration}s\n`;
              } else {
                  const series = item.series || 1;
                  const reps = item.reps ? `${item.reps} reps` : `${item.duration}s`;
                  let terminationInfo = '';
                  if (statusTag === '[✗]') {
                      terminationInfo = ` (interrotto alla serie ${termPoint.currentSeries}/${series})`;
                  }
                  report += `${statusTag} ${item.name}: ${series}x${reps}${terminationInfo}\n`;
              }
          });
          return report;
      }

      function render(element) {
          const { trainer } = store.getState();
          if (!trainer || !trainer.completedWorkout) return; 

          const { completedWorkout } = trainer;
          const summaryHtml = generateSummaryHtml(completedWorkout);
          const actionsHtml = `
              <div class="debriefing-actions">
                  <button class="copy-btn">Copia per il Coach</button>
                  <button class="return-btn">Torna al Calendario</button>
              </div>
          `;
          element.innerHTML = `
              <div class="debriefing-container">
                  ${summaryHtml}
                  ${actionsHtml}
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              if (event.target.closest('.return-btn')) {
                  store.dispatch({ type: 'CHANGE_VIEW', payload: 'calendar' });
              }
              if (event.target.closest('.copy-btn')) {
                  const { completedWorkout } = store.getState().trainer;
                  if (!completedWorkout) return;
                  const textToCopy = generateTextForCoach(completedWorkout);
                  navigator.clipboard.writeText(textToCopy).then(() => {
                      store.dispatch({ type: 'SHOW_NOTICE', payload: { message: 'Riepilogo copiato!' } });
                  }).catch(err => {
                      console.error('Errore nella copia:', err);
                      store.dispatch({ type: 'SHOW_NOTICE', payload: { message: 'Errore nella copia' } });
                  });
              }
          });

          store.subscribe(() => {
              if (element.classList.contains('view--active')) {
                  render(element);
              }
          });
          element.innerHTML = '';
      }