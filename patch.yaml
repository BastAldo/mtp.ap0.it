# This is a YAML file. Copy all content from here down
# and save it as 'patch.yaml'.
commit_message: "fix(trainer): Implement robust trainer control state management"
rationale: |
  The user reported a JavaScript error: `Uncaught SyntaxError: The requested module './trainer.js' does not provide an export named 'pauseOrResumeTrainer'`.

  This error is a symptom of a deeper issue. Analysis revealed that the trainer's UI controls (the Start/Pause/Resume buttons) were not updating their text or state correctly after the workout began. The initial "INIZIA" text would persist, leading to confusion. The user likely attempted to fix this by adding an incorrect import to `main.js`, causing the reported crash.

  This patch resolves the underlying problem by introducing a clear state management system for the trainer's controls, making the user's attempted fix unnecessary.

  1.  **New `ui.updateTrainerControls` function:** A new, dedicated function has been created in `ui.js`. It accepts a state (`ready`, `active`, `paused`) and exclusively handles the visibility and text content of the control buttons. This centralizes the UI logic.

  2.  **State-Driven Updates:** The `trainer.js` state machine now calls this new UI function at critical state transitions (`runReadyState`, `runPausedState`, `runActionState`). This ensures the UI is always an accurate reflection of the trainer's internal state.

  3.  **Architectural Integrity:** This fix respects and strengthens the existing architecture. The `trainer.js` module remains responsible for *what* state it's in, while `ui.js` is responsible for *how* that state is displayed. No changes are needed in `main.js`.
patches:
  - file: src/ui.js
    content: |
      /**
       * @file ui.js
       * ---
       * Responsible for all direct DOM manipulations.
       * This module contains functions to show/hide views, update the calendar,
       * manage modals, and update the trainer interface based on data it receives.
       * It is the "View" layer of the application.
       */

      import { getDayName, getFormattedDate } from './utils.js';
      import * as storage from './storage.js';
      import { ALL_EXERCISES } from './workouts.js';
      import { handleAction } from './trainer.js';

      // --- DOM Element References ---
      const views = {
        calendar: document.getElementById('calendar-view'),
        trainer: document.getElementById('trainer-view'),
        debriefing: document.getElementById('debriefing-view'),
      };
      const calendarGrid = document.getElementById('calendar-grid');
      const currentWeekTitle = document.getElementById('current-week-title');

      // Modals
      const dailyWorkoutModal = document.getElementById('daily-workout-modal');
      const exerciseLibraryModal = document.getElementById('exercise-library-modal');
      const modalTitle = document.getElementById('modal-title');
      const dailyExercisesList = document.getElementById('daily-exercises-list');
      const exerciseLibraryList = document.getElementById('exercise-library-list');

      // Trainer View Elements
      const trainerView = document.getElementById('trainer-view');
      const trainerExerciseTitle = document.getElementById('trainer-exercise-title');
      const trainerSeriesCounter = document.getElementById('trainer-series-counter');
      const trainerMainDisplay = document.getElementById('trainer-main-display');
      const trainerExerciseDescription = document.getElementById('trainer-exercise-description');
      const pauseBtn = document.getElementById('trainer-pause-btn');
      const resumeBtn = document.getElementById('trainer-resume-btn');
      const endBtn = document.getElementById('trainer-end-btn');


      // --- View Management ---

      /**
       * Shows a specific view and hides all others.
       * @param {string} viewName - The name of the view to show ('calendar', 'trainer', 'debriefing').
       */
      export function showView(viewName) {
        for (const key in views) {
          if (key === viewName) {
            views[key].classList.add('view--active');
          } else {
            views[key].classList.remove('view--active');
          }
        }
      }

      // --- Calendar UI ---

      /**
       * Updates the entire calendar display for a given week.
       * @param {Array<Date>} week - An array of 7 Date objects representing the week.
       * @param {function} dayClickHandler - Callback for when a day cell is clicked.
       * @param {function} startWorkoutHandler - Callback for when a start button is clicked.
       */
      export function updateCalendar(week, dayClickHandler, startWorkoutHandler) {
        calendarGrid.innerHTML = '';
        const firstDay = week[0];
        const lastDay = week[6];
        currentWeekTitle.textContent = `Settimana ${getFormattedDate(firstDay, { month: 'short', day: 'numeric' })} - ${getFormattedDate(lastDay, { month: 'short', day: 'numeric' })}`;

        week.forEach(date => {
          const dateString = getFormattedDate(date);
          const dayCell = createDayCell(date, dateString, dayClickHandler, startWorkoutHandler);
          calendarGrid.appendChild(dayCell);
        });
      }

      /**
       * Creates a single day cell element for the calendar.
       * @returns {HTMLElement} The created day cell element.
       */
      function createDayCell(date, dateString, dayClickHandler, startWorkoutHandler) {
        const dayCell = document.createElement('div');
        dayCell.className = 'day-cell';
        dayCell.dataset.date = dateString;

        const workouts = storage.getWorkoutsForDate(dateString);
        const workoutCount = workouts.length;
        const hasWorkouts = workoutCount > 0;

        dayCell.innerHTML = `
          <div class="day-header">
            <span class="day-name">${getDayName(date)}</span>
            <span class="day-number">${date.getDate()}</span>
          </div>
          <div class="day-summary">
            ${hasWorkouts ? `${workoutCount} eserciz${workoutCount > 1 ? 'i' : 'o'}` : 'Nessun allenamento'}
          </div>
          <div class="day-actions">
            <button id="start-day-btn" class="btn btn-secondary" ${!hasWorkouts ? 'disabled' : ''}>INIZIA</button>
          </div>
        `;

        // Add event listeners
        dayCell.addEventListener('click', (e) => {
            if (!e.target.closest('.day-actions')) {
                dayClickHandler(dateString);
            }
        });

        dayCell.querySelector('#start-day-btn').addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent day cell click
            startWorkoutHandler(dateString);
        });

        return dayCell;
      }

      // --- Modal UI ---

      export function openDailyWorkoutModal(date, workouts, removeHandler) {
        modalTitle.textContent = `Allenamento del ${getFormattedDate(new Date(date), { weekday: 'long', month: 'long', day: 'numeric' })}`;
        renderDailyExercises(workouts, removeHandler);
        dailyWorkoutModal.style.display = 'flex';
      }

      export function closeDailyWorkoutModal() {
        dailyWorkoutModal.style.display = 'none';
      }

      export function openExerciseLibraryModal(selectHandler) {
        renderExerciseLibrary(selectHandler);
        exerciseLibraryModal.style.display = 'flex';
      }

      export function closeExerciseLibraryModal() {
        exerciseLibraryModal.style.display = 'none';
      }

      export function renderDailyExercises(workouts, removeHandler) {
        dailyExercisesList.innerHTML = '';
        if (workouts.length === 0) {
          dailyExercisesList.innerHTML = '<li>Nessun esercizio aggiunto.</li>';
          return;
        }
        workouts.forEach(exercise => {
          const li = document.createElement('li');
          li.innerHTML = `
            <span>${exercise.name}</span>
            <button class="remove-exercise-btn" data-id="${exercise.id}">&times;</button>
          `;
          li.querySelector('.remove-exercise-btn').addEventListener('click', () => removeHandler(exercise.id));
          dailyExercisesList.appendChild(li);
        });
      }

      function renderExerciseLibrary(selectHandler) {
          exerciseLibraryList.innerHTML = '';
          ALL_EXERCISES.forEach(exercise => {
              const li = document.createElement('li');
              li.textContent = exercise.name;
              li.dataset.id = exercise.id;
              li.addEventListener('click', () => selectHandler(exercise.id));
              exerciseLibraryList.appendChild(li);
          });
      }


      // --- Trainer UI ---
      pauseBtn.addEventListener('click', handleAction);
      resumeBtn.addEventListener('click', handleAction);


      /**
       * Updates the entire trainer view, except for the controls.
       * @param {object} exercise - The current exercise object.
       * @param {number} currentSeries - The current series number.
       * @param {string} mainDisplayText - Text for the main large display.
       * @param {string} descriptionText - Text for the smaller description area.
       */
      export function updateTrainerUI(exercise, currentSeries, mainDisplayText, descriptionText) {
          trainerExerciseTitle.textContent = exercise.name;
          trainerSeriesCounter.textContent = `Serie ${currentSeries} / ${exercise.series}`;
          trainerMainDisplay.textContent = mainDisplayText;
          trainerMainDisplay.classList.remove('is-flashing');
          trainerExerciseDescription.textContent = descriptionText || (exercise.type === 'reps' ? `${exercise.reps} ripetizioni` : `${exercise.duration} secondi`);
      }

      /**
       * Updates only the main display of the trainer (e.g., for countdowns).
       * @param {string|number} text - The text or number to display.
       * @param {boolean} [isFlashing=false] - Whether to apply the flashing animation.
       */
      export function updateTrainerMainDisplay(text, isFlashing = false) {
          trainerMainDisplay.textContent = text;
          if (isFlashing) {
              trainerMainDisplay.classList.add('is-flashing');
          } else {
              trainerMainDisplay.classList.remove('is-flashing');
          }
      }

      /**
       * Manages the state of the trainer control buttons.
       * @param {'ready' | 'active' | 'paused'} state The current trainer state.
       */
      export function updateTrainerControls(state) {
        if (state === 'ready') {
            pauseBtn.textContent = 'INIZIA';
            pauseBtn.style.display = 'inline-block';
            resumeBtn.style.display = 'none';
        } else if (state === 'active') {
            pauseBtn.textContent = 'PAUSA';
            pauseBtn.style.display = 'inline-block';
            resumeBtn.style.display = 'none';
        } else if (state === 'paused') {
            pauseBtn.style.display = 'none';
            resumeBtn.style.display = 'inline-block';
        }
      }
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * ---
       * Contains the entire state machine logic for the training session.
       * This module is completely decoupled from the DOM. It receives workout data,
       * manages the state (ready, preparing, action, rest, etc.), and uses callback
       * functions provided by the UI module to display updates.
       */

      import * as ui from './ui.js';
      import { ALL_EXERCISES } from './workouts.js';
      import { playTick } from './utils.js';

      const ANNOUNCE_DURATION = 750; // ms
      const PREPARE_DURATION = 3; // seconds

      // --- STATE ---
      // This object holds the entire state of the current training session.
      let trainerState = {
        state: 'idle', // idle, ready, announcing, preparing, action, paused, rest, finished
        exercises: [], // a queue of exercises for the current session
        currentExerciseIndex: -1,
        currentSeries: 0,
        currentRep: 0,
        timerId: null, // To store setInterval reference
        countdown: 0,
      };

      // --- PUBLIC API ---

      /**
       * Initializes and starts the trainer with a list of exercise IDs.
       * @param {Array<string>} exerciseIds - List of exercise IDs to be performed.
       */
      export function startTrainer(exerciseIds) {
        if (!exerciseIds || exerciseIds.length === 0) {
          console.error("Trainer started with no exercises.");
          return;
        }
        // Reset state and populate with new workout
        resetTrainerState();
        trainerState.exercises = exerciseIds
          .map(id => ALL_EXERCISES.find(ex => ex.id === id))
          .filter(Boolean);

        ui.showView('trainer');
        nextStep();
      }

      /**
       * Handles user interaction with the main trainer action button (Start/Pause/Resume).
       */
      export function handleAction() {
        switch (trainerState.state) {
            case 'ready':
                runAnnouncingPhase('PREPARATI', runPreparingPhase);
                break;
            case 'action':
                runPausedState();
                break;
            case 'paused':
                resumeActionState();
                break;
            case 'rest':
                // Pausing during rest is not yet implemented, but we can stop the timer.
                runPausedState();
                break;
        }
      }

      // --- STATE MACHINE LOGIC ---

      /**
       * The core of the trainer. Determines the next state and executes it.
       */
      function nextStep() {
        const currentExercise = getCurrentExercise();

        // Case 1: Workout is finished
        if (!currentExercise) {
          runFinishedState();
          return;
        }

        // Case 2: Starting a new exercise
        if (trainerState.currentSeries === 0) {
          trainerState.currentExerciseIndex++;
          trainerState.currentSeries = 1;
          trainerState.currentRep = 1;
          runReadyState();
          return;
        }

        // Case 3: Finished all series for the current exercise
        if (trainerState.currentSeries > currentExercise.series) {
          trainerState.currentExerciseIndex++;
          trainerState.currentSeries = 1;
          trainerState.currentRep = 1;
           // Check if this was the last exercise
          if (trainerState.currentExerciseIndex >= trainerState.exercises.length) {
              runFinishedState();
          } else {
              runReadyState();
          }
          return;
        }
        
        // Case 4: Proceeding to the next set (start with rest)
        runRestState();
      }

      /**
       * Runs the READY state. The user has to manually start the set.
       */
      function runReadyState() {
        trainerState.state = 'ready';
        const exercise = getCurrentExercise();
        ui.updateTrainerUI(exercise, trainerState.currentSeries, 'PRONTI?', `Premi 'INIZIA' per cominciare la serie`);
        ui.updateTrainerControls('ready');
      }

      /**
       * Runs a short "announcing" phase to alert the user of what's next.
       * @param {string} text - The text to display (e.g., "UP", "REST").
       * @param {function} nextPhaseCallback - The function to call after the announcement.
       */
      function runAnnouncingPhase(text, nextPhaseCallback) {
        trainerState.state = 'announcing';
        ui.updateTrainerMainDisplay(text, true);
        playTick();
        
        setTimeout(() => {
          ui.updateTrainerMainDisplay(text, false); // Stop flashing
          nextPhaseCallback();
        }, ANNOUNCE_DURATION);
      }


      /**
       * Runs the PREPARING state (countdown before the first set).
       */
      function runPreparingPhase() {
        trainerState.state = 'preparing';
        trainerState.countdown = PREPARE_DURATION;
        ui.updateTrainerMainDisplay(trainerState.countdown);
        
        trainerState.timerId = setInterval(() => {
            trainerState.countdown--;
            playTick();
            ui.updateTrainerMainDisplay(trainerState.countdown);
            if (trainerState.countdown <= 0) {
                clearInterval(trainerState.timerId);
                runActionState();
            }
        }, 1000);
      }

      function runActionState() {
          trainerState.state = 'action';
          ui.updateTrainerControls('active');
          const exercise = getCurrentExercise();
          // Logic for timed vs reps exercise will go here
          // For now, let's just simulate a 5s action
          trainerState.countdown = 5;
          ui.updateTrainerMainDisplay(trainerState.countdown);

          trainerState.timerId = setInterval(() => {
              trainerState.countdown--;
              ui.updateTrainerMainDisplay(trainerState.countdown);
              if (trainerState.countdown <= 0) {
                  clearInterval(trainerState.timerId);
                  trainerState.currentSeries++;
                  nextStep(); // This will trigger the rest phase
              }
          }, 1000);
      }

      function runPausedState() {
          const prevState = trainerState.state;
          if (prevState !== 'action' && prevState !== 'rest') return; // Can only pause during action or rest

          trainerState.state = 'paused';
          clearInterval(trainerState.timerId);
          ui.updateTrainerControls('paused');
          // We can store the previous state to resume correctly
          trainerState.pausedFrom = prevState; 
      }

      function resumeActionState() {
          // To resume correctly, we check where we paused from.
          // This simplified version just restarts the previous phase's timer.
          if (trainerState.pausedFrom === 'action') {
              runActionState();
          } else if (trainerState.pausedFrom === 'rest') {
              // We need a dedicated function to resume the rest timer
              runRestState(true); // passing a flag to indicate it's a resume
          } else {
              // Default fallback
              runActionState();
          }
      }

      function runRestState(isResuming = false) {
          trainerState.state = 'rest';
          ui.updateTrainerControls('active'); // Rest is an active state with a "PAUSA" button
          const exercise = getCurrentExercise();

          // Only set countdown if it's not a resume action
          if (!isResuming) {
            trainerState.countdown = exercise.rest;
          }

          const startRestTimer = () => {
              ui.updateTrainerMainDisplay(trainerState.countdown);
              trainerState.timerId = setInterval(() => {
                  trainerState.countdown--;
                  playTick();
                  ui.updateTrainerMainDisplay(trainerState.countdown);
                  if (trainerState.countdown <= 0) {
                      clearInterval(trainerState.timerId);
                      runAnnouncingPhase('PREPARATI', runPreparingPhase);
                  }
              }, 1000);
          }
          
          if (isResuming) {
            startRestTimer();
          } else {
            runAnnouncingPhase('RIPOSO', startRestTimer);
          }
      }

      function runFinishedState() {
          trainerState.state = 'finished';
          console.log("Workout Finished!");
          ui.showView('calendar'); // For now, just go back to calendar
      }

      /**
       * Resets the trainer's state to its initial values.
       */
      function resetTrainerState() {
        if (trainerState.timerId) {
          clearInterval(trainerState.timerId);
        }
        trainerState = {
          state: 'idle',
          exercises: [],
          currentExerciseIndex: -1,
          currentSeries: 0,
          currentRep: 0,
          timerId: null,
          countdown: 0,
          pausedFrom: null,
        };
      }

      // --- HELPERS ---
      function getCurrentExercise() {
        return trainerState.exercises[trainerState.currentExerciseIndex];
      }
commands:
  - "git status"