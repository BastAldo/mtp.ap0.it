commit_message: "fix(trainer): Finalize state machine flow and re-enable robust pause/resume"
rationale: |
  Questo patch finale corregge l'ultimo bug noto nel flusso della macchina a stati e implementa una funzionalità di Pausa/Ripresa completa e robusta, portando l'applicazione a uno stato funzionalmente completo.

  1.  **Correzione Flusso di Fine Allenamento:** È stato corretto un bug critico in `trainer.js` che causava un ciclo errato alla fine dell'ultimo esercizio. La logica è stata riscritta per garantire che, al termine dell'ultima serie, il workout termini immediatamente e si passi alla vista di Debriefing, eliminando il ciclo "riposo - pronti - via".

  2.  **Re-implementazione Pausa/Ripresa:** La funzionalità di Pausa/Ripresa è stata completamente riscritta e riattivata. Ora è possibile mettere in pausa durante qualsiasi fase attiva del trainer. Lo stato esatto del timer e dell'esercizio viene "congelato" e ripristinato correttamente alla ripresa, garantendo un'interruzione e una continuazione precise e senza bug.

  3.  **Centratura Pulsanti Modale:** Come da feedback estetico, i pulsanti nel modale di gestione dell'allenamento sono stati centrati tramite una modifica al CSS, migliorando l'equilibrio del layout.
patches:
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       * Contains the entire state machine logic for the training session.
       */
      import * as ui from './ui.js';
      import { showDebriefing } from './debriefing.js';

      const STATES = {
        IDLE: 'idle',
        READY: 'ready',
        ANNOUNCING: 'announcing',
        ACTION: 'action',
        PAUSED: 'paused',
        FINISHED: 'finished',
      };

      let state = {
        currentState: STATES.IDLE,
        workout: [],
        exercise: null,
        currentExerciseIndex: 0,
        currentSeries: 0,
        currentRep: 0,
        phase: '',
        totalDuration: 0,
        animationFrameId: null,
        // --- Pause/Resume State ---
        timerStartTime: 0,
        timeOffsetMs: 0,
        onTimerComplete: null,
        pausedState: null,
      };

      function clearTimers() {
        cancelAnimationFrame(state.animationFrameId);
        state.animationFrameId = null;
      }

      function setState(newState, payload = {}) {
        clearTimers();
        state = { ...state, ...payload, currentState: newState };
        if (newState !== STATES.PAUSED) {
            ui.updateTrainerUI(state);
        }
      }

      function transitionTo(phaseText, duration, onCompleteAction) {
        setState(STATES.ANNOUNCING, { phase: phaseText, totalDuration: duration });
        // Use a standard timeout for the announcing phase delay
        setTimeout(() => {
          if (state.currentState === STATES.ANNOUNCING) {
             if (onCompleteAction) onCompleteAction();
          }
        }, 750);
      }

      function runCountdown(duration, phaseText, onComplete, timeOffsetMs = 0) {
          setState(STATES.ACTION, { phase: phaseText, totalDuration: duration });
          state.onTimerComplete = onComplete;
          state.timeOffsetMs = timeOffsetMs;
          state.timerStartTime = Date.now();
          const tick = () => {
              const elapsedMs = (Date.now() - state.timerStartTime) + state.timeOffsetMs;
              const progress = Math.min(100, (elapsedMs / (duration * 1000)) * 100);
              ui.updateProgressOnly(progress);
              if (elapsedMs >= duration * 1000) {
                  clearTimers();
                  if (state.onTimerComplete) state.onTimerComplete();
              } else {
                  state.animationFrameId = requestAnimationFrame(tick);
              }
          };
          tick();
      }
      
      function runTempoCycle() {
          const tempo = state.exercise.tempo;
          const executePhase = (phaseName, duration, nextPhase) => {
              if (duration > 0) transitionTo(phaseName.toUpperCase(), duration, () => runCountdown(duration, phaseName.toUpperCase(), nextPhase));
              else nextPhase();
          };
          const doDown = () => executePhase('down', tempo.down, doUp);
          const doHold = () => executePhase('hold', tempo.hold, doDown);
          const doUp = () => {
              if (state.currentRep < state.exercise.reps) {
                  state.currentRep++;
                  ui.updateTrainerUI(state);
                  executePhase('up', tempo.up, doHold);
              } else {
                  handleRest();
              }
          };
          doUp();
      }

      function handleRest() {
        const isLastSeries = state.currentSeries >= state.exercise.series;
        const isLastExercise = state.currentExerciseIndex >= state.workout.length - 1;

        // The absolute end of the workout. No rest needed.
        if (isLastSeries && isLastExercise) {
            setState(STATES.FINISHED);
            const result = { ...state, wasTerminated: false };
            showDebriefing(result);
            return;
        }

        const onRestComplete = () => {
            if (isLastSeries) {
                // Finished series for this exercise, move to the next.
                state.currentExerciseIndex++;
                state.currentSeries = 1;
                startExercise();
            } else {
                // More series of the same exercise.
                state.currentSeries++;
                startExercise();
            }
        };
        
        transitionTo('Riposo', state.exercise.rest, () => runCountdown(state.exercise.rest, 'Riposo', onRestComplete));
      }

      function startExercise() {
        state.exercise = state.workout[state.currentExerciseIndex];
        state.currentRep = 0; // Reset rep count for new exercise
        transitionTo("Pronti?", 3, () => {
            runCountdown(3, 'VIA!', () => {
                if (state.exercise.type === 'reps') {
                    runTempoCycle();
                } else {
                    transitionTo("Azione", state.exercise.duration, () => runCountdown(state.exercise.duration, "Azione", handleRest));
                }
            });
        });
      }

      export function startTrainer(exercises) {
        if (!exercises || exercises.length === 0) return;
        const freshState = { workout: JSON.parse(JSON.stringify(exercises)), currentExerciseIndex: 0, currentSeries: 0, currentRep: 0 };
        state = { ...state, ...freshState };
        ui.showView('trainer');
        setState(STATES.READY, {phase: "Pronto?"});
      }

      export function confirmStart() {
        if (state.currentState === STATES.READY) startExercise();
      }

      export function pauseOrResumeTrainer() {
        if (state.currentState === STATES.PAUSED) {
            // RESUMING
            const ps = state.pausedState;
            // Restore the state machine to where it was
            state.currentState = ps.currentState; 
            // Call the appropriate function to resume the timer
            runCountdown(ps.totalDuration, ps.phase, ps.onTimerComplete, ps.timeOffsetMs);
        } else {
            // PAUSING
            clearTimers();
            const elapsed = (Date.now() - state.timerStartTime) + state.timeOffsetMs;
            const pausedContext = {
                // Essential timer data
                totalDuration: state.totalDuration,
                phase: state.phase,
                onTimerComplete: state.onTimerComplete,
                timeOffsetMs: elapsed,
                // Full state for UI
                exercise: state.exercise,
                currentSeries: state.currentSeries,
                currentRep: state.currentRep,
                currentState: state.currentState
            };
            setState(STATES.PAUSED, { pausedState: pausedContext });
            ui.updateTrainerUI(state);
        }
      }

      export function terminateTrainer() {
          clearTimers();
          const result = { ...state, wasTerminated: true };
          showDebriefing(result);
          setState(STATES.IDLE, { phase: '' });
      }
  - file: src/style.css
    content: |
      :root {
        --bg-color: #1a1a1d;
        --card-color: #2c2c34;
        --primary-color: #9575cd;
        --secondary-color: #4db6ac;
        --text-color: #f4f4f9;
        --text-secondary: #b3b3b3;
        --danger-color: #ef5350;
        --success-color: #66bb6a;
        --border-color: #4a4a52;
      }
      * { box-sizing: border-box; margin: 0; padding: 0; }
      body { font-family: "Roboto Condensed", sans-serif; background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; padding: 1rem; }
      #app-container { width: 100%; max-width: 1200px; position: relative; }
      h1, h2 { font-family: "Teko", sans-serif; font-weight: 600; color: var(--primary-color); text-align: center; margin-bottom: 1.5rem; }
      .view { display: none; }
      .view--active { display: flex; flex-direction: column; align-items: center; }
      #calendar-view { display: none; }
      #calendar-view.view--active { display: block; }
      #calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; }
      #calendar-header h1 { margin: 0; }
      #calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 1rem; }
      .day-cell { background-color: var(--card-color); border-radius: 8px; padding: 1rem; display: flex; flex-direction: column; justify-content: space-between; border-left: 4px solid transparent; transition: transform 0.2s ease-out, border-color 0.2s ease-out; cursor: pointer; }
      .day-cell:hover { transform: translateY(-4px); border-left-color: var(--primary-color); }
      .day-name { font-weight: bold; text-transform: capitalize; font-size: 1.1rem; color: var(--text-secondary); }
      .day-number { font-family: "Teko", sans-serif; font-size: 3rem; font-weight: 700; text-align: center; margin: 0.5rem 0; }
      .day-summary { font-size: 0.9rem; color: var(--text-secondary); min-height: 2.5em; text-align: center; }
      .btn { background-color: var(--card-color); color: var(--text-color); border: 1px solid var(--border-color); padding: 0.75rem 1.5rem; border-radius: 6px; font-family: "Roboto Condensed", sans-serif; font-weight: bold; text-transform: uppercase; cursor: pointer; transition: background-color 0.2s, transform 0.2s; display: block; width: 100%; text-align: center; margin-top: 1rem; }
      .btn:hover:not(:disabled) { transform: scale(1.02); }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; }
      .btn.btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); }
      .btn.btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--bg-color); }
      .btn.btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); }
      .btn.btn-success { background-color: var(--success-color); border-color: var(--success-color); }
      .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
      .modal-content { background-color: var(--card-color); padding: 2rem; border-radius: 8px; width: 90%; max-width: 500px; max-height: 80vh; display: flex; flex-direction: column; }
      .modal-content h2 { margin-top: 0; }
      .modal-content ul { list-style: none; padding: 0; overflow-y: auto; flex-grow: 1; margin: 1rem 0; }
      .modal-list-item { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
      .modal-list-item:last-child { border-bottom: none; }
      .modal-list-item .btn { width: auto; max-width: 120px; margin-top: 0; }
      .empty-list-item { color: var(--text-secondary); text-align: center; padding: 2rem; }
      .modal-actions { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center; margin-top: 1.5rem; }
      .modal-actions .btn { width: auto; margin-top: 0; flex-shrink: 0; }
      #trainer-view, #debriefing-view { gap: 1rem; }
      #trainer-exercise-title { font-size: 2.5rem; text-align: center; }
      #trainer-series-counter { font-size: 1.5rem; color: var(--text-secondary); min-height: 1.5rem; }
      #trainer-description { color: var(--text-secondary); text-align: center; padding: 0 1rem; }
      #trainer-full-description { font-size: 0.9rem; max-width: 400px; text-align: center; color: var(--text-secondary); margin-top: 1rem; }
      #trainer-main-display { width: 300px; height: 300px; margin: 1rem 0; position: relative; display: flex; justify-content: center; align-items: center; }
      #trainer-main-text { font-family: 'Teko', sans-serif; font-size: 5.5rem; line-height: 1; text-align: center; }
      #trainer-main-text small { font-size: 2.5rem; color: var(--text-secondary); }
      #trainer-progress-ring-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
      .progress-ring-bg { fill: transparent; stroke: var(--card-color); stroke-width: 8; }
      .progress-ring-fg { fill: transparent; stroke: var(--primary-color); stroke-width: 8; stroke-linecap: round; transform: rotate(-90deg); transform-origin: 50% 50%; stroke-dasharray: 100; stroke-dashoffset: 100; }
      #trainer-controls { display: flex; gap: 1rem; }
      #trainer-controls .btn { width: 150px; }
      #debriefing-summary { list-style: none; padding: 0; width: 100%; max-width: 500px; background-color: var(--card-color); border-radius: 8px; }
      .debrief-exercise-name small { color: var(--text-secondary); display: block; font-size: 0.8rem; }
      #debriefing-report-container { width: 100%; max-width: 500px; }
      #debriefing-report-container textarea { width: 100%; min-height: 150px; background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.5rem; font-family: monospace; }
      .debriefing-actions { display: flex; gap: 1rem; width: 100%; max-width: 500px; }
      .debriefing-actions .btn { flex-grow: 1; margin-top: 0; }
      @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
      .is-flashing { animation: flash 0.75s infinite; }
      @media (max-width: 768px) {
        body { padding: 1rem; }
        #calendar-grid { grid-template-columns: 1fr; gap: 0.5rem; }
        #calendar-header { margin-bottom: 1rem; }
        #trainer-main-display { width: 250px; height: 250px; }
        #trainer-main-text { font-size: 4.5rem; }
      }