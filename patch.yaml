commit_message: "refactor(core): Allineare il codice all'architettura documentata"
rationale: |
  Questo commit esegue un refactoring completo per allineare l'implementazione del codice con l'architettura a "Piano Pre-compilato" definita nella documentazione.

  1. **Rimozione del Codice Obsoleto**: Il file `src/modules/trainerReducer.js` è stato eliminato in quanto la sua logica era un residuo di una precedente architettura e già centralizzata in `store.js`. Anche i file di supporto allo sviluppo come `logger.js` e `_mockData.js` sono stati rimossi per pulizia.

  2. **Implementazione Completa della Macchina a Stati**: Lo `store.js` è stato aggiornato per gestire l'intera macchina a stati (`preparing`, `announcing-phase`, `running`, `paused`, `finished`) come descritto nella documentazione, consumando direttamente il piano generato da `planGenerator.js`.

  3. **Aggiornamento della UI**: La `TrainerView.js` ora renderizza correttamente tutti gli stati del trainer, fornendo il feedback visivo appropriato (countdown iniziale e animazioni di annuncio).

  4. **Sincronizzazione della Documentazione**: I documenti `01_FUNCTIONALITY.md` e `02_ARCHITECTURE.md` sono stati aggiornati per riflettere accuratamente l'architettura corrente, eliminando i riferimenti al reducer obsoleto.

  Questo refactoring risolve le incongruenze, riduce il debito tecnico e rende l'applicazione più robusta, manutenibile e pienamente conforme alle specifiche di progetto.
patches:
  - file: src/modules/trainerReducer.js
    content: "" # File eliminato
  - file: src/modules/logger.js
    content: "" # File eliminato
  - file: src/modules/_mockData.js
    content: "" # File eliminato
  - file: docs/01_FUNCTIONALITY.md
    content: |
      # App Functionality Specification

      This document outlines the core features and operational logic of the "Mio Trainer Personale" web application.

      ## 1. Core Concept

      The application is a single-page app (SPA) designed for users to schedule, execute, and track workouts. It features a persistent header for consistent branding. All user data is persisted locally in the browser's `localStorage`. All user interactions, such as confirmations and notifications, are handled through custom, non-native UI elements.

      ## 2. Main Views

      The application operates using three primary, mutually exclusive views: `Calendar`, `Trainer`, and `Debriefing`.

      ### 2.1. Calendar View
      -   **Function:** The main dashboard and default view of the application.
      -   **Display:** It presents a weekly grid layout.
      -   **Navigation:** Users can navigate to the previous or next week.
      -   **Day Cells:** Each cell represents a day and displays a summary of the number of exercises scheduled for that day. A "START" button is enabled if one or more exercises are scheduled.
      -   **Interaction:** Clicking a day cell (but not the "START" button) opens the Workout Editor modal for that specific date.

      ### 2.2. Workout Editor (Modal System)
      The editor is a modal system for managing a day's workout routine.
      -   **Daily Workout Modal:** Displays a list of items (exercises or rests) that can be reordered via drag-and-drop.
      -   **Exercise Library Modal:** Allows adding exercises from a predefined library.
      -   **Confirmation Modal**: A custom modal is used to confirm critical actions, such as terminating a workout.

      ### 2.3. Interactive Trainer View
      -   **Function:** An interactive, state-driven interface that guides the user through a scheduled workout in real-time.
      -   **Core Logic**: The trainer's flow is determined by a **pre-compiled execution plan** generated by `planGenerator.js`. The `store.js` module acts as a simple "runner" that steps through this plan.
      -   **Controls:** Includes a main button for flow control (start/pause/resume) and a secondary button to terminate the workout.

      #### Execution Flow
      1.  **Ready (`ready`):** The initial state before the workout begins.
      2.  **Preparing (`preparing`):** A 3-second countdown that runs once at the very beginning.
      3.  **Announcing (`announcing-phase`):** A brief (0.75s) state that flashes the name of the upcoming exercise or phase.
      4.  **Action/Rest (`running`):** The main state where timers for exercises and rests are active.
      5.  **Paused (`paused`):** The user can pause the workout at any time.
      6.  **Finished (`finished`):** The state after all items in the plan are completed or the workout is terminated.

      ### 2.4. Debriefing View
      -   **Activation:** Appears automatically when a workout is finished or terminated.
      -   **Content:** Displays a summary of the completed workout plan.
      -   **Actions:**
          - **"Copy for Coach"**: Copies a formatted text summary to the clipboard.
          - **"Return to Calendar"**: Navigates back to the main calendar view.
  - file: docs/02_ARCHITECTURE.md
    content: |
      # Application Architecture

      This document outlines the high-level architecture for the "Mio Trainer Personale" SPA.

      ## 1. Core Principles
      -   **Modularity:** The application is broken down into distinct, single-responsibility modules.
      -   **State-Driven UI:** The user interface is a function of the application's state.

      ## 2. State Management: Centralized Store
      The application uses a centralized state store (`src/modules/store.js`) as the Single Source of Truth (SSoT).
      -   **State:** A single, read-only JavaScript object.
      -   **Actions:** State is modified by dispatching predefined "actions".
      -   **Subscriptions:** UI modules subscribe to the store to re-render on state changes.

      ## 3. Core Architectural Pattern: Pre-compiled Execution Plan
      To ensure robustness and eliminate complex runtime logic, the Trainer view operates on a "pre-compiled plan" architecture.
      -   **Status**: Accepted & Implemented
      -   **Context**: Dynamic state machines for workouts are prone to bugs.
      -   **Decision**: Before a workout starts, `planGenerator.js` creates a complete, sequential array of "step objects". Each step object contains all necessary data for its execution and rendering (`type`, `duration`, `headerTitle`, `mainText`, etc.).
      -   **Execution**: The `store.js` module acts as a simple "runner". During the workout, it just increments an index (`currentStepIndex`) to move to the next step in the pre-compiled array. All complex logic is handled upfront by the generator, not at runtime.
      -   **Benefits**: This approach makes the runtime logic extremely simple, predictable, and easy to debug. The entire workout flow can be inspected before it even starts.

      ## 4. Directory Structure
      -   `docs/`: Project documentation.
      -   `src/`: Application source code.
          -   `modules/`: Core logic (store, plan generator, etc.).
          -   `views/`: UI rendering and event handling for major components.
          -   `data/`: Static data sources (e.g., exercise library).

      ## 5. Data Persistence
      All workout data is persisted in `localStorage` via the `storage.js` module.
  - file: src/main.js
    content: |
      console.log('File loaded: main.js');
      import store from './modules/store.js';
      import { init as initCalendarView } from './views/CalendarView.js';
      import { init as initTrainerView } from './views/TrainerView.js';
      import { init as initDebriefingView } from './views/DebriefingView.js';
      import { init as initModal } from './ui/Modal.js';
      import { init as initNotice } from './ui/Notice.js';
      import { loadFromStorage, saveToStorage } from './modules/storage.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const TICK_INTERVAL = 100;

      const views = {
          calendar: document.getElementById('calendar-view'),
          trainer: document.getElementById('trainer-view'),
          debriefing: document.getElementById('debriefing-view'),
      };
      const initializedViews = new Set();

      function initializeApp() {
        let workouts = loadFromStorage(WORKOUTS_STORAGE_KEY);
        if (!workouts) {
          // Inizializza con un oggetto vuoto se non c'è nulla nello storage
          workouts = {};
          saveToStorage(WORKOUTS_STORAGE_KEY, workouts);
        }
        store.dispatch({ type: 'SET_WORKOUTS', payload: workouts });

        initCalendarView(views.calendar);
        initializedViews.add('calendar');
        initModal(document.getElementById('modal-container'));
        initNotice(document.getElementById('notice-container'));
        console.log('App Initialized.');
      }

      let currentActiveView = views.calendar;
      function handleViewChange() {
        const { currentView } = store.getState();
        const newActiveViewEl = views[currentView];

        if (currentActiveView !== newActiveViewEl) {
          currentActiveView.classList.remove('view--active');
          newActiveViewEl.classList.add('view--active');
          currentActiveView = newActiveViewEl;

          if (!initializedViews.has(currentView)) {
            if (currentView === 'trainer') initTrainerView(views.trainer);
            else if (currentView === 'debriefing') initDebriefingView(views.debriefing);
            initializedViews.add(currentView);
          }
        }
      }

      // --- Gestore Effetti Collaterali per il Timer del Trainer ---
      let timerInterval = null;
      function handleTrainerEffects() {
          const { trainer } = store.getState();
          const trainerState = trainer.status;

          if (trainerState !== 'running' && timerInterval) {
              clearInterval(timerInterval);
              timerInterval = null;
          }

          if (trainerState === 'running' && !timerInterval) {
              timerInterval = setInterval(() => {
                  store.dispatch({ type: 'TIMER_TICK', payload: { tick: TICK_INTERVAL } });
              }, TICK_INTERVAL);
          }
      }

      store.subscribe(handleViewChange);
      store.subscribe(handleTrainerEffects);

      initializeApp();
  - file: src/modules/planGenerator.js
    content: |
      function createActionSteps(item, seriesIndex) {
        const steps = [];
        const totalSeries = item.series || 1;
        const context = { currentSeries: seriesIndex, totalSeries, item };

        // Annuncio dell'esercizio
        steps.push({
          type: 'announcing-phase',
          duration: 750,
          headerTitle: item.name,
          mainText: `Serie ${seriesIndex}/${totalSeries}`,
          context,
          item
        });

        if (item.type === 'time') {
          steps.push({ type: 'action', duration: (item.duration || 10) * 1000, headerTitle: item.name, mainText: `Esegui`, context, item });
        } else {
          const totalReps = item.reps || 1;
          const tempoPhases = Object.keys(item.tempo || { exec: 1 });
          for (let repIndex = 1; repIndex <= totalReps; repIndex++) {
            tempoPhases.forEach(phase => {
              steps.push({ type: 'action', duration: (item.tempo[phase] || 1) * 1000, headerTitle: item.name, mainText: phase.toUpperCase(), context: { ...context, currentRep: repIndex, totalReps, phase }, item });
            });
          }
        }
        return steps;
      }

      export function generatePlan(workoutItems) {
        if (!workoutItems || workoutItems.length === 0) return [];

        let plan = [
          { type: 'preparing', duration: 3000, headerTitle: 'Preparati', mainText: 'Si comincia...' }
        ];

        workoutItems.forEach((item, index) => {
          if (item.type === 'rest') {
            plan.push({
              type: 'rest',
              duration: item.duration * 1000,
              headerTitle: 'Riposo',
              mainText: `Prossimo: ${workoutItems[index + 1]?.name || 'Fine'}`,
              item
            });
          } else {
            const totalSeries = item.series || 1;
            for (let i = 1; i <= totalSeries; i++) {
              plan.push(...createActionSteps(item, i));
            }
          }
        });

        plan.push({ type: 'finished', duration: 0, headerTitle: 'Fine', mainText: 'Workout Completato!' });
        return plan;
      }
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';
      import { generatePlan } from './planGenerator.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';

      const trainerInitialState = {
          status: 'idle', // idle, ready, running, paused, finished
          executionPlan: null,
          currentStepIndex: 0,
          remaining: 0,
          activeWorkout: null,
          completedWorkout: null,
      };

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          trainer: { ...trainerInitialState },
        };

        const subscribers = new Set();
        function notify() { for (const callback of subscribers) { callback(); } }

        const dispatch = (action) => {
          if (action.type !== 'TIMER_TICK') {
            console.log(`%c[${action.type}]`, 'color: #88aaff; font-weight: bold;', action.payload || '');
          }

          const oldState = state;
          const newState = { ...state, trainer: { ...state.trainer } };

          switch (action.type) {
            case 'CHANGE_VIEW': newState.currentView = action.payload; break;
            case 'PREV_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() - 7); newState.focusedDate = d; break; }
            case 'NEXT_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() + 7); newState.focusedDate = d; break; }
            case 'SET_WORKOUTS': newState.workouts = action.payload; break;
            case 'OPEN_MODAL': newState.isModalOpen = true; newState.modalContext = action.payload; break;
            case 'CLOSE_MODAL': newState.isModalOpen = false; newState.modalContext = null; break;
            case 'SHOW_NOTICE': newState.notice = { message: action.payload.message, id: Date.now() }; break;
            case 'ADD_EXERCISE_ITEM': { const { date, exerciseId } = action.payload; const dateKey = `workout-${date}`; const exercise = getExerciseById(exerciseId); if (!exercise) break; const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id }; const dayWorkout = [...(newState.workouts[dateKey] || [])]; dayWorkout.push(newItem); newState.workouts = { ...newState.workouts, [dateKey]: dayWorkout }; newState.modalContext = { type: 'EDIT_WORKOUT', date }; break; }
            case 'ADD_REST_ITEM': { const { date } = action.payload; const dateKey = `workout-${date}`; const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 }; const dayWorkout = [...(newState.workouts[dateKey] || [])]; dayWorkout.push(newItem); newState.workouts = { ...newState.workouts, [dateKey]: dayWorkout }; break; }
            case 'REMOVE_WORKOUT_ITEM': { const { date, itemId } = action.payload; const dateKey = `workout-${date}`; const updatedWorkout = (newState.workouts[dateKey] || []).filter(item => item.id !== itemId); newState.workouts = { ...newState.workouts, [dateKey]: updatedWorkout }; break; }
            case 'UPDATE_REST_DURATION': { const { date, itemId, newDuration } = action.payload; const dateKey = `workout-${date}`; const dayWorkout = (newState.workouts[dateKey] || []).map(item => item.id === itemId ? { ...item, duration: newDuration } : item); newState.workouts = { ...newState.workouts, [dateKey]: dayWorkout }; break; }
            case 'REORDER_WORKOUT_ITEMS': { const { date, draggedItemId, targetItemId } = action.payload; const dateKey = `workout-${date}`; const items = [...(newState.workouts[dateKey] || [])]; const draggedIndex = items.findIndex(item => item.id === draggedItemId); const targetIndex = items.findIndex(item => item.id === targetItemId); if (draggedIndex > -1 && targetIndex > -1) { const [draggedItem] = items.splice(draggedIndex, 1); items.splice(targetIndex, 0, draggedItem); newState.workouts = { ...newState.workouts, [dateKey]: items }; } break; }
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const workoutItems = newState.workouts[`workout-${date}`];
              if (workoutItems?.length > 0) {
                const plan = generatePlan(workoutItems);
                newState.currentView = 'trainer';
                newState.trainer = { ...trainerInitialState, status: 'ready', executionPlan: plan, activeWorkout: { date, items: workoutItems } };
              }
              break;
            }
            case 'START_TRAINER':
              if (newState.trainer.status === 'ready') {
                newState.trainer.status = 'running';
                const firstStep = newState.trainer.executionPlan[0];
                newState.trainer.remaining = firstStep.duration;
              }
              break;
            case 'PAUSE_TRAINER': if (newState.trainer.status === 'running') { newState.trainer.status = 'paused'; } break;
            case 'RESUME_TRAINER': if (newState.trainer.status === 'paused') { newState.trainer.status = 'running'; } break;
            case 'TIMER_TICK':
              if (newState.trainer.status === 'running') {
                const newRemaining = newState.trainer.remaining - action.payload.tick;
                if (newRemaining <= 0) {
                  const { executionPlan, currentStepIndex } = newState.trainer;
                  const nextStepIndex = currentStepIndex + 1;
                  if (nextStepIndex < executionPlan.length) {
                    const nextStep = executionPlan[nextStepIndex];
                    newState.trainer.currentStepIndex = nextStepIndex;
                    newState.trainer.remaining = nextStep.duration;
                    if (nextStep.type === 'finished') {
                      newState.trainer.status = 'finished';
                      newState.trainer.completedWorkout = { ...newState.trainer.activeWorkout, completed: true };
                    }
                  }
                } else {
                  newState.trainer.remaining = newRemaining;
                }
              }
              break;
            case 'TERMINATE_WORKOUT':
              if (newState.trainer.status !== 'idle' && newState.trainer.status !== 'finished') {
                const { executionPlan, currentStepIndex, activeWorkout } = newState.trainer;
                const currentStep = executionPlan[currentStepIndex];
                const itemIndex = activeWorkout.items.findIndex(i => i.id === currentStep.item?.id);
                newState.trainer.status = 'finished';
                newState.trainer.completedWorkout = { ...activeWorkout, completed: false, terminationPoint: { itemIndex: itemIndex > -1 ? itemIndex : 0, currentSeries: currentStep.context?.currentSeries || 1 } };
                newState.currentView = 'debriefing';
              }
              break;
            case 'FINISH_WORKOUT':
              if (newState.trainer.status === 'finished') {
                newState.trainer = { ...trainerInitialState }; // Reset trainer state
                newState.currentView = 'calendar';
              }
              break;
          }

          state = newState;
          if (JSON.stringify(state.workouts) !== JSON.stringify(oldState.workouts)) {
            saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
          }
          notify();
        };

        return { getState: () => state, subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); }, dispatch };
      }

      const store = createStore();
      export default store;
  - file: src/views/TrainerView.js
    content: |
      import store from '../modules/store.js';

      function render(element) {
          const { trainer } = store.getState();
          if (!trainer || !trainer.executionPlan || !trainer.executionPlan[trainer.currentStepIndex]) {
              element.innerHTML = '<h2>Caricamento...</h2>';
              return;
          }

          const { status, executionPlan, currentStepIndex, remaining } = trainer;
          const currentStep = executionPlan[currentStepIndex];
          const { type, duration, headerTitle, mainText, context = {} } = currentStep;

          const radius = 90;
          const circumference = 2 * Math.PI * radius;

          let timerText = '', buttonText = '', instructionText = '', mainPhaseText = mainText;
          const isAnnouncing = type === 'announcing-phase';
          const terminateButtonHidden = status === 'finished' || status === 'ready';

          const progress = duration > 0 ? (duration - Math.max(0, remaining)) / duration : 0;
          const ringOffset = circumference * (1 - progress);

          if (duration > 0 && (status === 'running' || status === 'paused')) {
              timerText = String(Math.ceil(remaining / 1000));
          }
          if(type === 'preparing') timerText = String(Math.ceil(remaining / 1000));

          switch (status) {
              case 'ready': buttonText = 'INIZIA'; instructionText = 'Premi INIZIA per cominciare'; break;
              case 'running': buttonText = 'PAUSA'; instructionText = 'Esegui'; break;
              case 'paused': buttonText = 'RIPRENDI'; instructionText = 'Pausa'; break;
              case 'finished': buttonText = 'DEBRIEFING'; instructionText = 'Ben fatto!'; break;
              default: buttonText = '...';
          }
          
          const subHeaderText = context.totalSeries ? `SERIE ${context.currentSeries}/${context.totalSeries}` : '';
          if (type === 'rest') {
              instructionText = mainText; // Mostra il prossimo esercizio durante il riposo
              mainPhaseText = "RIPOSO";
          }
          
          element.innerHTML = `
              <div class="trainer-container">
                  <header class="trainer-header">
                      <h2>${headerTitle}</h2>
                      <p>${subHeaderText || '&nbsp;'}</p>
                  </header>
                  <div class="progress-ring">
                      <svg>
                          <circle class="progress-ring__background" stroke-width="10" r="${radius}" cx="50%" cy="50%"></circle>
                          <circle class="progress-ring__foreground" style="stroke-dashoffset: ${ringOffset};" stroke-width="10" r="${radius}" cx="50%" cy="50%" stroke-dasharray="${circumference}"></circle>
                      </svg>
                      <div class="progress-ring__text">
                          <div class="progress-ring__phase ${isAnnouncing ? 'is-flashing' : ''}">${mainPhaseText}</div>
                          <div class="progress-ring__timer">${timerText}</div>
                      </div>
                  </div>
                  <footer class="trainer-footer">
                      <p class="trainer-instruction">${instructionText}</p>
                      <div class="trainer-controls">
                          <button class="trainer-main-btn">${buttonText}</button>
                          <button class="trainer-terminate-btn" ${terminateButtonHidden ? 'hidden' : ''}>Termina</button>
                      </div>
                  </footer>
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              const mainButton = event.target.closest('.trainer-main-btn');
              const terminateButton = event.target.closest('.trainer-terminate-btn');

              const { trainer } = store.getState();
              if (!trainer) return;

              if (terminateButton) {
                  store.dispatch({ type: 'OPEN_MODAL', payload: { type: 'CONFIRM_TERMINATION' } });
                  return;
              }

              if (!mainButton) return;

              switch (trainer.status) {
                  case 'ready': store.dispatch({ type: 'START_TRAINER' }); break;
                  case 'running': store.dispatch({ type: 'PAUSE_TRAINER' }); break;
                  case 'paused': store.dispatch({ type: 'RESUME_TRAINER' }); break;
                  case 'finished': store.dispatch({ type: 'FINISH_WORKOUT' }); break;
              }
          });

          store.subscribe(() => {
              if (element.classList.contains('view--active')) {
                  render(element);
              }
          });

          if (element.classList.contains('view--active')) {
              render(element);
          }
      }
commands:
  - "echo 'Refactoring completato. Il codice è ora allineato con la documentazione architetturale.'"
  - "echo 'Rimosso il reducer obsoleto e implementata la macchina a stati completa nello store.'"