commit_message: "feat(core): Riprogettare il timer e ripristinare le funzionalità"
rationale: |
  Questo commit esegue una riprogettazione architetturale del sistema di timer per risolvere una criticità di 'race condition' e migliora la generazione del piano di allenamento.

  1.  **Nuovo Modulo Timer**: È stato introdotto un nuovo modulo `src/modules/timer.js` che utilizza `requestAnimationFrame`. Questo approccio, superiore a `setInterval`, elimina la 'race condition' che rendeva inaffidabile il pulsante "Pausa" e centralizza la gestione del tempo in un unico punto con funzioni semplici (`start`, `stop`).

  2.  **Logica Semplificata**: La logica del timer è stata rimossa da `main.js` e integrata direttamente nelle azioni dello store (`START_TRAINER`, `PAUSE_TRAINER`, etc.), che ora controllano esplicitamente l'avvio e l'arresto del timer. Questo rende il flusso di stato più pulito e prevedibile.

  3.  **Funzionalità Ripristinate**:
      - È stata reinserita la `console.table()` per l'ispezione del piano di allenamento generato, una feature di debug fondamentale.
      - Il `planGenerator.js` è stato corretto per inserire correttamente gli stati di annuncio (`announcing-phase`) per ogni fase del 'tempo' (up, hold, down), riabilitando il feedback visivo (flicker) durante le ripetizioni.

  L'insieme di queste modifiche rende l'applicazione più stabile, performante e allineata ai principi di codice pulito e a singola responsabilità.
patches:
  - file: src/modules/timer.js
    content: |
      let animationFrameId = null;

      function loop(callback, lastTime) {
          const currentTime = performance.now();
          const tick = currentTime - lastTime;
          callback(tick);
          animationFrameId = requestAnimationFrame(() => loop(callback, currentTime));
      }

      export function start(callback) {
          if (!animationFrameId) {
              animationFrameId = requestAnimationFrame(() => loop(callback, performance.now()));
          }
      }

      export function stop() {
          if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
          }
      }
  - file: src/main.js
    content: |
      import store from './modules/store.js';
      import { init as initCalendarView } from './views/CalendarView.js';
      import { init as initTrainerView } from './views/TrainerView.js';
      import { init as initDebriefingView } from './views/DebriefingView.js';
      import { init as initModal } from './ui/Modal.js';
      import { init as initNotice } from './ui/Notice.js';
      import { loadFromStorage, saveToStorage } from './modules/storage.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';

      const views = {
          calendar: document.getElementById('calendar-view'),
          trainer: document.getElementById('trainer-view'),
          debriefing: document.getElementById('debriefing-view'),
      };
      const initializedViews = new Set();

      function initializeApp() {
        let workouts = loadFromStorage(WORKOUTS_STORAGE_KEY);
        if (!workouts) {
          workouts = {};
          saveToStorage(WORKOUTS_STORAGE_KEY, workouts);
        }
        store.dispatch({ type: 'SET_WORKOUTS', payload: workouts });

        initCalendarView(views.calendar);
        initializedViews.add('calendar');
        initModal(document.getElementById('modal-container'));
        initNotice(document.getElementById('notice-container'));
      }

      function handleViewChange() {
        const { currentView } = store.getState();
        const newActiveViewEl = views[currentView];

        if (newActiveViewEl && newActiveViewEl.id !== store.currentActiveViewId) {
          const oldView = document.querySelector('.view--active');
          if(oldView) oldView.classList.remove('view--active');
          
          newActiveViewEl.classList.add('view--active');
          store.currentActiveViewId = newActiveViewEl.id;

          if (!initializedViews.has(currentView)) {
            if (currentView === 'trainer') initTrainerView(views.trainer);
            else if (currentView === 'debriefing') initDebriefingView(views.debriefing);
            initializedViews.add(currentView);
          }
        }
      }

      store.subscribe(handleViewChange);
      initializeApp();
  - file: src/modules/planGenerator.js
    content: |
      function createActionSteps(item, seriesIndex) {
          const steps = [];
          const totalSeries = item.series || 1;
          const baseContext = { currentSeries: seriesIndex, totalSeries, item };

          if (item.type === 'time') {
              steps.push({ type: 'announcing-phase', duration: 750, headerTitle: item.name, mainText: `Esegui`, context: baseContext, item });
              steps.push({ type: 'action', duration: (item.duration || 10) * 1000, headerTitle: item.name, mainText: `RUN`, context: baseContext, item });
          } else {
              const totalReps = item.reps || 1;
              const tempoPhases = Object.keys(item.tempo || { exec: 1 });
              for (let repIndex = 1; repIndex <= totalReps; repIndex++) {
                  const repContext = { ...baseContext, currentRep: repIndex, totalReps };
                  tempoPhases.forEach(phase => {
                      const phaseContext = { ...repContext, phase };
                      // Inserisce un annuncio PRIMA di ogni fase di azione
                      steps.push({ type: 'announcing-phase', duration: 750, headerTitle: item.name, mainText: phase.toUpperCase(), context: phaseContext, item });
                      steps.push({ type: 'action', duration: (item.tempo[phase] || 1) * 1000, headerTitle: item.name, mainText: phase.toUpperCase(), context: phaseContext, item });
                  });
              }
          }
          return steps;
      }

      export function generatePlan(workoutItems) {
          if (!workoutItems || workoutItems.length === 0) return [];

          let plan = [{ type: 'preparing', duration: 3000, headerTitle: 'Preparati', mainText: 'Si comincia...' }];

          workoutItems.forEach((item, index) => {
              if (item.type === 'rest') {
                  plan.push({ type: 'rest', duration: item.duration * 1000, headerTitle: 'Riposo', mainText: `Prossimo: ${workoutItems[index + 1]?.name || 'Fine'}`, item });
              } else {
                  plan.push(...createActionSteps(item, index + 1));
              }
          });

          plan.push({ type: 'finished', duration: 0, headerTitle: 'Fine', mainText: 'Workout Completato!' });
          return plan;
      }
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';
      import { generatePlan } from './planGenerator.js';
      import * as timer from './timer.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';

      const trainerInitialState = {
          status: 'idle',
          executionPlan: null,
          currentStepIndex: 0,
          remaining: 0,
          activeWorkout: null,
          completedWorkout: null,
      };

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          trainer: { ...trainerInitialState },
        };

        const subscribers = new Set();
        function notify() { for (const callback of subscribers) { callback(); } }

        function handleTimerTick(tick) {
            dispatch({ type: 'TIMER_TICK', payload: { tick } });
        }

        const dispatch = (action) => {
          if (action.type !== 'TIMER_TICK') {
            console.log(`%c[${action.type}]`, 'color: #88aaff; font-weight: bold;', action.payload || '');
          }

          const oldState = state;
          const newState = { ...state, trainer: { ...state.trainer } };

          switch (action.type) {
            case 'CHANGE_VIEW': newState.currentView = action.payload; break;
            case 'PREV_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() - 7); newState.focusedDate = d; break; }
            case 'NEXT_WEEK': { const d = new Date(newState.focusedDate); d.setDate(d.getDate() + 7); newState.focusedDate = d; break; }
            case 'SET_WORKOUTS': newState.workouts = action.payload; break;
            case 'OPEN_MODAL': newState.isModalOpen = true; newState.modalContext = action.payload; break;
            case 'CLOSE_MODAL': newState.isModalOpen = false; newState.modalContext = null; break;
            case 'SHOW_NOTICE': newState.notice = { message: action.payload.message, id: Date.now() }; break;
            case 'ADD_EXERCISE_ITEM': { const { date, exerciseId } = action.payload; const dateKey = `workout-${date}`; const exercise = getExerciseById(exerciseId); if (!exercise) break; const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id }; const dayWorkout = [...(newState.workouts[dateKey] || [])]; dayWorkout.push(newItem); newState.workouts = { ...newState.workouts, [dateKey]: dayWorkout }; newState.modalContext = { type: 'EDIT_WORKOUT', date }; break; }
            case 'ADD_REST_ITEM': { const { date } = action.payload; const dateKey = `workout-${date}`; const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 }; const dayWorkout = [...(newState.workouts[dateKey] || [])]; dayWorkout.push(newItem); newState.workouts = { ...newState.workouts, [dateKey]: dayWorkout }; break; }
            case 'REMOVE_WORKOUT_ITEM': { const { date, itemId } = action.payload; const dateKey = `workout-${date}`; const updatedWorkout = (newState.workouts[dateKey] || []).filter(item => item.id !== itemId); newState.workouts = { ...newState.workouts, [dateKey]: updatedWorkout }; break; }
            case 'UPDATE_REST_DURATION': { const { date, itemId, newDuration } = action.payload; const dateKey = `workout-${date}`; const dayWorkout = (newState.workouts[dateKey] || []).map(item => item.id === itemId ? { ...item, duration: newDuration } : item); newState.workouts = { ...newState.workouts, [dateKey]: dayWorkout }; break; }
            case 'REORDER_WORKOUT_ITEMS': { const { date, draggedItemId, targetItemId } = action.payload; const dateKey = `workout-${date}`; const items = [...(newState.workouts[dateKey] || [])]; const draggedIndex = items.findIndex(item => item.id === draggedItemId); const targetIndex = items.findIndex(item => item.id === targetItemId); if (draggedIndex > -1 && targetIndex > -1) { const [draggedItem] = items.splice(draggedIndex, 1); items.splice(targetIndex, 0, draggedItem); newState.workouts = { ...newState.workouts, [dateKey]: items }; } break; }
            
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const workoutItems = newState.workouts[`workout-${date}`];
              if (workoutItems?.length > 0) {
                const plan = generatePlan(workoutItems);
                console.log("--- Piano di Esecuzione Generato ---");
                console.table(plan);
                newState.currentView = 'trainer';
                newState.trainer = { ...trainerInitialState, status: 'ready', executionPlan: plan, activeWorkout: { date, items: workoutItems } };
              }
              break;
            }
            case 'START_TRAINER':
              if (newState.trainer.status === 'ready') {
                newState.trainer.status = 'running';
                const firstStep = newState.trainer.executionPlan[0];
                newState.trainer.remaining = firstStep.duration;
                timer.start(handleTimerTick);
              }
              break;
            case 'PAUSE_TRAINER':
              if (newState.trainer.status === 'running') {
                newState.trainer.status = 'paused';
                timer.stop();
              }
              break;
            case 'RESUME_TRAINER':
              if (newState.trainer.status === 'paused') {
                newState.trainer.status = 'running';
                timer.start(handleTimerTick);
              }
              break;
            case 'TIMER_TICK':
              if (newState.trainer.status === 'running') {
                const newRemaining = newState.trainer.remaining - action.payload.tick;
                if (newRemaining <= 0) {
                  const { executionPlan, currentStepIndex } = newState.trainer;
                  const nextStepIndex = currentStepIndex + 1;
                  if (nextStepIndex < executionPlan.length) {
                    const nextStep = executionPlan[nextStepIndex];
                    newState.trainer.currentStepIndex = nextStepIndex;
                    newState.trainer.remaining = nextStep.duration;
                    if (nextStep.type === 'finished') {
                      newState.trainer.status = 'finished';
                      newState.trainer.completedWorkout = { ...newState.trainer.activeWorkout, completed: true };
                      timer.stop();
                    }
                  }
                } else {
                  newState.trainer.remaining = newRemaining;
                }
              }
              break;
            case 'TERMINATE_WORKOUT':
              if (newState.trainer.status !== 'idle' && newState.trainer.status !== 'finished') {
                const { executionPlan, currentStepIndex, activeWorkout } = newState.trainer;
                const currentStep = executionPlan[currentStepIndex];
                const itemIndex = activeWorkout.items.findIndex(i => i.id === currentStep.item?.id);
                newState.trainer.status = 'finished';
                newState.trainer.completedWorkout = { ...activeWorkout, completed: false, terminationPoint: { itemIndex: itemIndex > -1 ? itemIndex : 0, currentSeries: currentStep.context?.currentSeries || 1 } };
                timer.stop();
                newState.currentView = 'debriefing';
              }
              break;
            case 'FINISH_WORKOUT':
              if (newState.trainer.status === 'finished') {
                newState.trainer = { ...trainerInitialState };
                newState.currentView = 'calendar';
              }
              break;
          }

          state = newState;
          if (JSON.stringify(state.workouts) !== JSON.stringify(oldState.workouts)) {
            saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
          }
          notify();
        };

        return { getState: () => state, subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); }, dispatch };
      }

      const store = createStore();
      export default store;
commands:
  - "echo 'Riprogettazione del timer completata con successo!'"
  - "echo 'La gestione del timer è ora più robusta e il codice più pulito.'"
  - "echo 'Ripristinata la console.table e la logica di annuncio per le fasi tempo.'"