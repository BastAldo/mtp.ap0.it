commit_message: "fix(trainer): Correggere bug critico e migliorare la robustezza del trainer"
rationale: |
  Questo commit risolve un errore di sintassi critico in `store.js` che impediva l'avvio dell'applicazione.

  Inoltre, come parte di una revisione più approfondita del codice, sono state implementate diverse migliorie per aumentare la robustezza e la manutenibilità del nuovo sistema a piano pre-compilato:

  1.  **Bug Fix (`store.js`):** Rimosso un carattere '}' extra che causava un `SyntaxError` bloccante.
  
  2.  **Robustezza (`store.js`):** Aggiunto un controllo di sicurezza nell'azione `TERMINATE_WORKOUT` per gestire con grazia eventuali dati corrotti e garantire che la sessione termini senza errori imprevisti.
  
  3.  **Manutenibilità (`planGenerator.js`):** Aggiunti commenti dettagliati per documentare la struttura degli oggetti-passo generati, rendendo il codice più chiaro per future manutenzioni.

  4.  **Coerenza (`DebriefingView.js`):** Effettuato un piccolo ritocco per garantire che la vista di debriefing utilizzi sempre la proprietà `fullPlan` dall'oggetto `completedWorkout`, assicurando coerenza con lo stato centrale.
patches:
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';
      import { generatePlan } from './planGenerator.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          activeWorkout: null, // Contiene il workout originale {date, items}
          completedWorkout: null,
          trainerState: 'idle', // ready, running, paused, finished
          trainerContext: {}, // { executionPlan, currentStepIndex, remaining, stateBeforePause }
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        const dispatch = (action) => {
          const oldState = { ...state };
          let newState = { ...state };
          let shouldNotify = true;

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() - 7); newState = { ...state, focusedDate: d }; break; }
            case 'NEXT_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() + 7); newState = { ...state, focusedDate: d }; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'SHOW_NOTICE': newState = { ...state, notice: { message: action.payload.message, id: Date.now() } }; break;
            case 'ADD_EXERCISE_ITEM': { const { date, exerciseId } = action.payload; const dateKey = `workout-${date}`; const exercise = getExerciseById(exerciseId); if (!exercise) break; const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id }; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } }; break; }
            case 'ADD_REST_ITEM': { const { date } = action.payload; const dateKey = `workout-${date}`; const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 }; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts }; break; }
            case 'REMOVE_WORKOUT_ITEM': { const { date, itemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId); newState = { ...state, workouts: newWorkouts }; break; }
            case 'UPDATE_REST_DURATION': { const { date, itemId, newDuration } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; const itemIndex = dayWorkout.findIndex(item => item.id === itemId); if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') { dayWorkout[itemIndex].duration = newDuration; newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts }; } break; }
            case 'REORDER_WORKOUT_ITEMS': { const { date, draggedItemId, targetItemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); const items = newWorkouts[dateKey] || []; const draggedIndex = items.findIndex(item => item.id === draggedItemId); const targetIndex = items.findIndex(item => item.id === targetItemId); if (draggedIndex > -1 && targetIndex > -1) { const [draggedItem] = items.splice(draggedIndex, 1); items.splice(targetIndex, 0, draggedItem); newWorkouts[dateKey] = items; newState = { ...state, workouts: newWorkouts }; } break; }

            // --- TRAINER LIFECYCLE (REFACTORED) ---
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const workoutItems = state.workouts[`workout-${date}`];
              if (!workoutItems || workoutItems.length === 0) break;
              const plan = generatePlan(workoutItems);
              newState = { ...state, currentView: 'trainer', activeWorkout: { date, items: workoutItems }, trainerState: 'ready', trainerContext: { executionPlan: plan, currentStepIndex: 0 } };
              break;
            }
            case 'START_TRAINER': {
              if (state.trainerState === 'ready') {
                const firstStep = state.trainerContext.executionPlan[0];
                newState = { ...state, trainerState: 'running', trainerContext: { ...state.trainerContext, remaining: firstStep.duration } };
              }
              break;
            }
            case 'ADVANCE_PLAN': {
              const { executionPlan, currentStepIndex } = state.trainerContext;
              const nextStepIndex = currentStepIndex + 1;
              if (nextStepIndex >= executionPlan.length) {
                dispatch({ type: 'FINISH_WORKOUT' });
                shouldNotify = false;
                break;
              }
              const nextStep = executionPlan[nextStepIndex];
              if (nextStep.type === 'finished') {
                newState = { ...state, trainerState: 'finished', trainerContext: { ...state.trainerContext, currentStepIndex: nextStepIndex }};
              } else {
                newState = { ...state, trainerContext: { ...state.trainerContext, currentStepIndex: nextStepIndex, remaining: nextStep.duration }};
              }
              break;
            }
            case 'TIMER_TICK': {
              if (state.trainerState !== 'running') { shouldNotify = false; break; }
              const newRemaining = (state.trainerContext.remaining || 0) - action.payload.tick;
              if (newRemaining > 0) {
                newState = { ...state, trainerContext: { ...state.trainerContext, remaining: newRemaining } };
              } else {
                dispatch({ type: 'ADVANCE_PLAN' });
                shouldNotify = false;
              }
              break;
            }
            case 'PAUSE_TRAINER': {
              if (state.trainerState === 'running') {
                newState = { ...state, trainerState: 'paused' };
              }
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState === 'paused') {
                newState = { ...state, trainerState: 'running' };
              }
              break;
            }
            case 'FINISH_WORKOUT': {
              // Il fullPlan contiene solo gli item originali, per il debriefing.
              const fullPlan = state.activeWorkout.items;
              newState = { ...state, currentView: 'debriefing', completedWorkout: { ...state.activeWorkout, completed: true, fullPlan }, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'TERMINATE_WORKOUT': {
              const { activeWorkout, trainerContext } = state;
              const { executionPlan, currentStepIndex } = trainerContext;
              const fullPlan = activeWorkout.items;
              
              // Safeguard: Trova l'indice dell'item originale per un debriefing accurato
              const currentStep = executionPlan[currentStepIndex];
              const currentItem = currentStep?.item;
              const originalItemIndex = currentItem ? fullPlan.findIndex(i => i.id === currentItem.id) : -1;

              const terminationPoint = {
                itemIndex: originalItemIndex > -1 ? originalItemIndex : 0,
                currentSeries: currentStep?.context?.currentSeries || 1,
              };

              const partialWorkout = { ...activeWorkout, completed: false, fullPlan, terminationPoint };
              newState = { ...state, currentView: 'debriefing', completedWorkout: partialWorkout, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            default: shouldNotify = false; break;
          }

          state = newState;
          if (shouldNotify) {
            if (state.workouts !== oldState.workouts) { saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts); }
            notify();
          }
        };

        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      const store = createStore();
      export default store;
  - file: src/modules/planGenerator.js
    content: |
      // --- Modulo Generatore di Piani di Esecuzione per il Trainer ---

      /**
       * Struttura di un "Oggetto-Passo" (Step Object) generato:
       * {
       * type: string,          // 'preparing', 'announcing', 'action', 'rest', 'finished'
       * duration: number,      // Durata del passo in millisecondi
       * headerTitle: string,   // Testo principale per l'header del trainer (es. nome esercizio)
       * mainText: string,      // Testo secondario per il centro del trainer (es. 'RIPOSO', 'UP', 'DOWN')
       * item?: object,         // Riferimento all'item originale del workout (se applicabile)
       * context?: object,      // Contesto specifico del passo (es. { currentSeries, totalSeries, ... })
       * }
       */

      function unrollExerciseSeries(item, seriesIndex) {
          const steps = [];
          const totalSeries = item.series || 1;
          const totalReps = item.reps || 1;

          if (seriesIndex === 1) {
              steps.push({
                  type: 'announcing',
                  duration: 2000,
                  headerTitle: 'Prossimo Esercizio',
                  mainText: item.name,
                  item,
              });
          }

          for (let repIndex = 1; repIndex <= totalReps; repIndex++) {
              if (item.type === 'time') {
                  steps.push({
                      type: 'action',
                      duration: (item.duration || 10) * 1000,
                      headerTitle: item.name,
                      mainText: `Serie ${seriesIndex}/${totalSeries}`,
                      item,
                      context: { currentSeries: seriesIndex, totalSeries }
                  });
              } else { // type 'exercise' con tempo
                  const tempoPhases = Object.keys(item.tempo || { exec: 1 });
                  tempoPhases.forEach(phase => {
                      steps.push({
                          type: 'action',
                          duration: (item.tempo[phase] || 1) * 1000,
                          headerTitle: item.name,
                          mainText: phase.toUpperCase(),
                          item,
                          context: { currentSeries: seriesIndex, totalSeries, currentRep: repIndex, totalReps, phase }
                      });
                  });
              }
          }

          if (seriesIndex < totalSeries) {
              steps.push({
                  type: 'rest',
                  duration: (item.defaultRest || 60) * 1000,
                  headerTitle: 'Riposo',
                  mainText: 'Recupera le forze',
                  isSeriesRest: true,
                  item,
              });
          }

          return steps;
      }

      export function generatePlan(workoutItems) {
          if (!workoutItems || workoutItems.length === 0) return [];

          const plan = [];

          plan.push({
              type: 'preparing',
              duration: 3000,
              headerTitle: 'Preparati',
              mainText: 'Si comincia...',
          });

          workoutItems.forEach((item) => {
              if (item.type === 'rest') {
                  plan.push({
                      type: 'rest',
                      duration: (item.duration || 60) * 1000,
                      headerTitle: 'Riposo',
                      mainText: 'Come da programma',
                      isSeriesRest: false,
                      item,
                  });
              } else {
                  const totalSeries = item.series || 1;
                  for (let i = 1; i <= totalSeries; i++) {
                      plan.push(...unrollExerciseSeries(item, i));
                  }
              }
          });

          plan.push({
              type: 'finished',
              duration: 0,
              headerTitle: 'Fine',
              mainText: 'Workout Completato!',
          });

          return plan;
      }
  - file: src/views/DebriefingView.js
    content: |
      import store from '../modules/store.js';

      function generateSummaryHtml(completedWorkout) {
          if (!completedWorkout || !completedWorkout.fullPlan) return '<p>Nessun dato di allenamento disponibile.</p>';

          const title = completedWorkout.completed
              ? '<h2>Workout Completato!</h2>'
              : '<h2>Workout Interrotto</h2>';

          const termPoint = completedWorkout.terminationPoint;

          const itemsHtml = completedWorkout.fullPlan.map((item, index) => {
              let itemClass = 'debrief-item';
              let statusText = '';
              let animationDelay = `style="animation-delay: ${index * 50}ms;"`;

              if (completedWorkout.completed) {
                  itemClass += ' debrief-item--completed';
              } else if (termPoint) {
                  if (index < termPoint.itemIndex) {
                      itemClass += ' debrief-item--completed';
                  } else if (index === termPoint.itemIndex) {
                      itemClass += ' debrief-item--terminated';
                      statusText = `(interrotto alla serie ${termPoint.currentSeries})`;
                  } else {
                      itemClass += ' debrief-item--skipped';
                      animationDelay = '';
                  }
              }

              let mainText = '';
              if (item.type === 'rest') {
                  mainText = `Riposo: ${item.duration}s`;
              } else {
                  const series = item.series || 1;
                  const reps = item.reps ? `${item.reps} reps` : `${item.duration}s`;
                  mainText = `${item.name}: ${series}x${reps} ${statusText}`;
              }

              return `<li class="${itemClass}" ${animationDelay}>${mainText}</li>`;
          }).join('');

          return `${title}<ul class="debrief-list">${itemsHtml}</ul>`;
      }

      function generateTextForCoach(completedWorkout) {
          if (!completedWorkout || !completedWorkout.fullPlan) return 'Nessun dato disponibile.';
          const date = new Date(completedWorkout.date).toLocaleDateString('it-IT');
          const status = completedWorkout.completed ? 'Completato' : 'Interrotto';
          let report = `Report Allenamento - ${date} (${status})\n====================\n\n`;

          const termPoint = completedWorkout.terminationPoint;

          completedWorkout.fullPlan.forEach((item, index) => {
              let statusTag = '[✓]';
              if (!completedWorkout.completed && termPoint) {
                  if (index < termPoint.itemIndex) statusTag = '[✓]';
                  else if (index === termPoint.itemIndex) statusTag = '[✗]';
                  else statusTag = '[-]';
              }

              if (item.type === 'rest') {
                  report += `${statusTag} Riposo: ${item.duration}s\n`;
              } else {
                  const series = item.series || 1;
                  const reps = item.reps ? `${item.reps} reps` : `${item.duration}s`;
                  let terminationInfo = '';
                  if (statusTag === '[✗]') {
                      terminationInfo = ` (interrotto alla serie ${termPoint.currentSeries}/${series})`;
                  }
                  report += `${statusTag} ${item.name}: ${series}x${reps}${terminationInfo}\n`;
              }
          });
          return report;
      }


      function render(element) {
          const { completedWorkout } = store.getState();
          const summaryHtml = generateSummaryHtml(completedWorkout);
          const actionsHtml = `
              <div class="debriefing-actions">
                  <button class="copy-btn">Copia per il Coach</button>
                  <button class="return-btn">Torna al Calendario</button>
              </div>
          `;
          element.innerHTML = `
              <div class="debriefing-container">
                  ${summaryHtml}
                  ${actionsHtml}
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              if (event.target.closest('.return-btn')) {
                  store.dispatch({ type: 'CHANGE_VIEW', payload: 'calendar' });
              }
              if (event.target.closest('.copy-btn')) {
                  const { completedWorkout } = store.getState();
                  const textToCopy = generateTextForCoach(completedWorkout);
                  navigator.clipboard.writeText(textToCopy).then(() => {
                      store.dispatch({ type: 'SHOW_NOTICE', payload: { message: 'Riepilogo copiato!' } });
                  }).catch(err => {
                      console.error('Errore nella copia:', err);
                      store.dispatch({ type: 'SHOW_NOTICE', payload: { message: 'Errore nella copia' } });
                  });
              }
          });

          store.subscribe(() => {
              if(element.classList.contains('view--active')) {
                  render(element);
              }
          });
          element.innerHTML = '';
      }
commands:
  - "echo 'Bug critico risolto e robustezza del sistema migliorata.'"