commit_message: "refactor(trainer): Make all rest periods explicit and update docs"
rationale: |
  This commit implements the final logic for handling rest periods and updates the documentation to reflect this critical change, based on user feedback.

  1.  **No Automatic Rests (`store.js`)**: The trainer's state machine in `store.js` has been modified to completely remove automatic rest periods. A rest state is now entered *only* when an explicit `{type: 'rest'}` item is encountered in the workout sequence. This gives the user full control over their workout pacing. The `defaultRest` property on exercises is now effectively ignored by the trainer logic.

  2.  **Updated Documentation (`01_FUNCTIONALITY.md` & `functionality_spec.md`)**: Both functionality documents have been updated to clearly state that rest periods are not automatic. The description of the state machine now accurately reflects that the trainer advances directly to the next item (be it an exercise or an explicit rest block) upon completion of the current one. This removes ambiguity and serves as a clear guide for future development.
patches:
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';

      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          activeWorkout: null,
          trainerState: 'idle',
          trainerContext: {},
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        // Custom Logger Function
        function logState(actionType, state) {
            const { activeWorkout, trainerState, trainerContext } = state;
            if (!activeWorkout) return;

            const currentItem = activeWorkout.items[trainerContext.itemIndex];
            const exerciseName = currentItem?.name || 'Riposo';
            const series = `${trainerContext.currentSeries || '-'}/${currentItem?.series || '-'}`;
            const reps = `${trainerContext.currentRep || '-'}/${currentItem?.reps || '-'}`;

            let status = trainerState.toUpperCase();
            if (trainerState === 'announcing' || trainerState === 'action') {
                status += ` (${trainerContext.currentPhase || 'N/A'})`;
            }

            const logString = `Esercizio: ${exerciseName} | Serie: ${series} | Rep: ${reps} | Stato: ${status}`;

            console.log(`%c[${actionType}]`, 'color: #88aaff; font-weight: bold;', logString);
        }

        function dispatch(action) {
          const oldState = { ...state };
          let newState = { ...state };

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d=new Date(state.focusedDate); d.setDate(d.getDate()-7); newState={...state, focusedDate:d}; break; }
            case 'NEXT_WEEK': { const d=new Date(state.focusedDate); d.setDate(d.getDate()+7); newState={...state, focusedDate:d}; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'ADD_EXERCISE_ITEM': {
                const { date, exerciseId } = action.payload;
                const dateKey = `workout-${date}`;
                const exercise = getExerciseById(exerciseId);
                if (!exercise) break;
                const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } };
                break;
            }
            case 'ADD_REST_ITEM': {
                const { date } = action.payload;
                const dateKey = `workout-${date}`;
                const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'REMOVE_WORKOUT_ITEM': {
                const { date, itemId } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId);
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'UPDATE_REST_DURATION': {
                const { date, itemId, newDuration } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                const itemIndex = dayWorkout.findIndex(item => item.id === itemId);
                if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') {
                    dayWorkout[itemIndex].duration = newDuration;
                    newWorkouts[dateKey] = dayWorkout;
                    newState = { ...state, workouts: newWorkouts };
                }
                break;
            }
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const dateKey = `workout-${date}`;
              const workoutItems = state.workouts[dateKey];
              if (!workoutItems || workoutItems.length === 0) break;
              newState = {
                ...state,
                currentView: 'trainer',
                activeWorkout: { date, items: workoutItems },
                trainerState: 'ready',
                trainerContext: { itemIndex: 0, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0 }
              };
              break;
            }
            case 'PAUSE_TRAINER': {
              if (['paused', 'ready', 'finished'].includes(state.trainerState)) break;
              const { remaining, duration } = action.payload;
              newState = {
                ...state,
                trainerState: 'paused',
                trainerContext: { ...state.trainerContext, remaining, duration, stateBeforePause: state.trainerState },
              };
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState !== 'paused') break;
              newState = { ...state, trainerState: state.trainerContext.stateBeforePause };
              break;
            }
            case 'TIMER_COMPLETE': {
              const { trainerState, activeWorkout, trainerContext } = state;
              const currentItem = activeWorkout.items[trainerContext.itemIndex];

              const advanceToNextItem = () => {
                if (trainerContext.itemIndex < activeWorkout.items.length - 1) {
                  const nextItemIndex = trainerContext.itemIndex + 1;
                  const nextItem = activeWorkout.items[nextItemIndex];
                  const newContext = { itemIndex: nextItemIndex, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0 };
                  const newState = nextItem.type === 'rest' ? 'rest' : 'announcing';
                  if (nextItem.type !== 'rest') {
                      newContext.currentPhase = nextItem.type === 'time' ? 'Esegui' : (Object.keys(nextItem.tempo || {})[0] || 'up');
                  }
                  return { newState, newContext };
                }
                return null; // Signals workout is finished
              };

              let nextState = trainerState;
              let nextContext = { ...trainerContext };

              switch (trainerState) {
                case 'preparing':
                  nextState = 'announcing';
                  const firstItem = activeWorkout.items[0];
                  if (firstItem.type === 'time') { nextContext.currentPhase = 'Esegui'; }
                  else { const tempo = firstItem.tempo || {}; nextContext.currentPhase = Object.keys(tempo)[0] || 'up'; }
                  break;

                case 'announcing':
                  nextState = 'action';
                  break;

                case 'action': {
                  if (currentItem.type === 'exercise') {
                    const tempo = currentItem.tempo || {};
                    const phases = Object.keys(tempo);
                    const nextPhaseIndex = trainerContext.currentPhaseIndex + 1;

                    if (nextPhaseIndex < phases.length) { // More phases in this rep
                      nextState = 'announcing';
                      nextContext.currentPhaseIndex = nextPhaseIndex;
                      nextContext.currentPhase = phases[nextPhaseIndex];
                    } else { // Rep complete
                      nextContext.currentPhaseIndex = 0; // Reset for next rep
                      if (trainerContext.currentRep < currentItem.reps) {
                        nextContext.currentRep++;
                        nextState = 'announcing'; // Start next rep immediately
                        nextContext.currentPhase = phases[0] || 'up';
                      } else if (trainerContext.currentSeries < currentItem.series) {
                        nextContext.currentSeries++;
                        nextContext.currentRep = 1;
                        nextState = 'announcing'; // Start next series immediately
                        nextContext.currentPhase = phases[0] || 'up';
                      } else { // Exercise complete
                        const advance = advanceToNextItem();
                        if (advance) { nextState = advance.newState; nextContext = { ...nextContext, ...advance.newContext }; }
                        else { nextState = 'finished'; }
                      }
                    }
                  } else if (currentItem.type === 'time') {
                      if (trainerContext.currentSeries < currentItem.series) {
                          nextContext.currentSeries++;
                          nextState = 'announcing'; // Start next series immediately
                          nextContext.currentPhase = 'Esegui';
                      } else {
                          const advance = advanceToNextItem();
                          if (advance) { nextState = advance.newState; nextContext = { ...nextContext, ...advance.newContext }; }
                          else { nextState = 'finished'; }
                      }
                  }
                  break;
                }

                case 'rest': {
                  // After an explicit rest, always advance to the next item
                  const advance = advanceToNextItem();
                  if (advance) { nextState = advance.newState; nextContext = { ...nextContext, ...advance.newContext }; }
                  else { nextState = 'finished'; }
                  break;
                }
              }
              newState = { ...state, trainerState: nextState, trainerContext: nextContext };
              break;
            }
            default:
              return;
          }
          state = newState;
          if (state !== oldState) {
            logState(action.type, state);
            if (state.workouts !== oldState.workouts) {
              saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
            }
            notify();
          }
        }
        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      const store = createStore();
      export default store;
  - file: docs/01_FUNCTIONALITY.md
    content: |
      # App Functionality Specification

      This document outlines the core features and operational logic of the "Mio Trainer Personale" web application.

      ## 1. Core Concept

      The application is a single-page app (SPA) designed for users to schedule, execute, and track workouts. All user data is persisted locally in the browser's `localStorage`.

      ## 2. Main Views

      The application operates using three primary, mutually exclusive views: `Calendar`, `Trainer`, and `Debriefing`.

      ### 2.1. Calendar View

      -   **Function:** The main dashboard and default view of the application.
      -   **Display:** It presents a weekly grid layout.
      -   **Navigation:** Users can navigate to the previous or next week.
      -   **Day Cells:** Each cell represents a day and displays a summary of the number of exercises scheduled for that day. A "START" button is enabled if one or more exercises are scheduled.
      -   **Interaction:** Clicking a day cell (but not the "START" button) opens the Workout Editor modal for that specific date.

      ### 2.2. Workout Editor (Modal System)

      The editor is a modal system for managing a day's workout routine. It allows for the composition of exercises and configurable rest periods.

      -   **Daily Workout Modal:**
          -   Triggered by clicking a day cell.
          -   Displays a list of items (exercises or rests) currently scheduled for the selected date.
      -   **Exercise Library Modal:**
          -   Triggered by the "Add Exercise" button.
          -   Displays a list of all **available exercises** from the application's library.

      ### 2.3. Interactive Trainer View

      -   **Function:** An interactive, state-driven interface that guides the user through a scheduled workout in real-time.
      -   **Activation:** Triggered by clicking the "START" button on a day cell in the calendar.

      #### Trainer State Machine & Flow
      The trainer operates as a state machine. The primary user flow is as follows:

      1.  **Ready (`ready`):** The initial state. The trainer displays the first exercise and awaits user input.
      2.  **Preparing (`preparing`):** A 3-second countdown that runs **only once** at the very beginning of the workout.
      3.  **Announcing (`announcing`):** A 0.75-second state that displays the name of the upcoming phase (e.g., "UP", "REST") to alert the user.
      4.  **Action (`action`):** The core execution phase where the user performs the movement for a timed duration.
      5.  **Rest (`rest`):** A timed countdown for rest. This state is **only** activated when the trainer encounters a user-defined rest block in the workout sequence. There are no automatic rests between series or exercises.
      6.  **Paused (`paused`):** The user can pause the workout at any time during `preparing`, `announcing`, `action`, or `rest`.
      7.  **Advancement Logic:**
          - After an `action` phase, the logic checks for more phases, repetitions, or series within the same exercise.
          - Once an entire exercise item is complete (all series and reps), the trainer immediately advances to the next item in the workout list.
          - If the next item is an exercise, it begins the `announcing` phase for it.
          - If the next item is a rest block, it enters the `rest` state.
      8.  **Finished (`finished`):** Once all items in the routine are complete, the trainer automatically transitions to the Debriefing View.

      ### 2.4. Debriefing View

      -   **Activation:** Appears automatically when a workout is completed.
      -   **Content:** Displays a summary of all exercises completed.
      -   **Actions:** "Copy for Coach" and "Return to Calendar".
  - file: functionality_spec.md
    content: |
      # App Functionality Specification

      This document outlines the core features and operational logic of the "Mio Trainer Personale" web application.

      ## 1. Core Concept

      The application is a single-page app (SPA) designed for users to schedule, execute, and track workouts. All user data is persisted locally in the browser's `localStorage`.

      ## 2. Main Views

      The application operates using three primary, mutually exclusive views: `Calendar`, `Trainer`, and `Debriefing`.

      ### 2.1. Calendar View
      - **Function:** The main dashboard and default view of the application.
      - **Display:** It presents a weekly grid layout.
      - **Navigation:** Users can navigate to the previous or next week.
      - **Day Cells:** Each cell represents a day and displays a summary of the number of exercises scheduled for that day. A "START" button is enabled if one or more exercises are scheduled.
      - **Interaction:** Clicking a day cell (but not the "START" button) opens the Workout Editor modal for that specific date.

      ### 2.2. Workout Editor (Modal System)
      The editor is a two-stage modal system for managing a day's workout routine.
      - **Daily Workout Modal:**
          - Triggered by clicking a day cell.
          - Displays a list of exercises currently scheduled for the selected date.
          - Allows **removal** of any exercise from the list.
          - Contains an "Add Exercise" button to open the Exercise Library modal.
      - **Exercise Library Modal:**
          - Triggered by the "Add Exercise" button.
          - Displays a complete list of all available exercises defined in the app's configuration.
          - Allows **selection** of an exercise to add to the current day's routine.

      ### 2.3. Interactive Trainer View
      - **Function:** An interactive, state-driven interface that guides the user through a scheduled workout in real-time.
      - **Activation:** Triggered by clicking the "START" button on a day cell in the calendar.

      #### Trainer State Machine & Flow
      The trainer operates as a state machine. Each exercise consists of a number of **series**. The primary user flow is as follows:

      1.  **Ready (`ready`):** The trainer displays the current exercise and series number. It shows "READY" inside the progress ring. It awaits user input to begin.
      2.  **Announcing (`announcing`):** Before every new phase, this 0.75-second state is activated. The progress ring is shown as empty. The content inside the ring is replaced by a large, flashing text label announcing the upcoming phase (e.g., "PREPARE", "UP", "REST"). An audio tick alerts the user.
      3.  **Preparing (`preparing`):** A 3-second countdown to prepare the user for the first series of an exercise. The progress ring fills up, and the countdown is displayed inside.
      4.  **Action (`action`):** The core execution phase. The progress ring animates for the duration of the phase, with the countdown and phase label shown inside.
          - For **`reps`**-based exercises, the trainer automatically cycles through timed phases as defined by the exercise's `tempo` object (e.g., `up`, `hold`, `down`), each with its own countdown and progress ring animation.
          - For **`time`**-based exercises, a single countdown for the specified `duration` is run.
      5.  **Paused (`paused`):** The user can pause the workout at any time during a countdown state. The timer and the progress ring animation stop. The user must click "RESUME" to continue.
      6.  **Rest (`rest`):** This state is **only** activated when the trainer encounters a user-defined rest block in the workout sequence. There are no automatic rests between series or exercises. A countdown for the specified `rest` duration is shown, and the progress ring animates accordingly.
      7.  **Advancement:** After completing all series/reps of an exercise, the system automatically proceeds to the next item in the workout list. If the next item is another exercise, it begins immediately. If it is an explicit rest block, the `rest` state is triggered.
      8.  **Finished (`finished`):** Once all exercises and series are complete, the trainer automatically transitions to the Debriefing View.

      ### 2.4. Debriefing View
      - **Activation:** Appears automatically when a workout is completed or manually terminated.
      - **Content:**
          - **Summary:** Displays a list of all exercises completed during the session.
          - **Text Report:** Generates a pre-formatted, multi-line string summarizing the workout, ready for sharing.
      - **Actions:**
          - **Copy for Coach:** Copies the text report to the user's clipboard.
          - **Return to Calendar:** Switches the view back to the main Calendar.
commands:
  - "echo 'Refactoring completato. I riposi ora sono solo espliciti. Documentazione aggiornata.'"