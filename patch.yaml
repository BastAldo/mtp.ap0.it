# This is a YAML file. Copy all content from here down
# and save it as 'patch.yaml'.
commit_message: "feat: Implement redesigned Trainer UI with SVG progress ring"
rationale: |
  Questo commit implementa una completa riprogettazione dell'interfaccia utente del Trainer, basata sul dettagliato feedback dell'utente per migliorare l'esperienza.

  1.  **Anello di Avanzamento (SVG)**: È stato introdotto un anello di avanzamento circolare (`<svg>`) come elemento visivo principale. Questo fornisce un feedback immediato e grafico sulla durata dei conti alla rovescia, come richiesto. `style.css` contiene i nuovi stili per disegnare e animare l'anello tramite la proprietà `stroke-dashoffset`.

  2.  **Layout Gerarchico**: L'HTML di `#trainer-view` è stato ristrutturato per ospitare il nuovo design. Ora le informazioni all'interno dell'anello seguono una chiara gerarchia visiva: il tempo rimanente è l'informazione primaria (testo grande), mentre la fase corrente (UP, DOWN, etc.) è secondaria (testo piccolo sottostante).

  3.  **Logica di Rendering (`ui.js`)**: La funzione `updateTrainerUI` è stata riscritta per gestire la nuova interfaccia. Ora si occupa di:
      - Mostrare/nascondere alternativamente il contenuto del countdown (numeri/fase) e la scritta di annuncio lampeggiante, mantenendo sempre visibile l'anello SVG come da specifica.
      - Aggiornare l'anello di avanzamento tramite una nuova funzione `updateProgressRing`, che calcola la porzione di cerchio da disegnare.

  4.  **Logica del Trainer (`trainer.js`)**: Il modulo del trainer è stato leggermente modificato per calcolare la percentuale di progresso durante ogni intervallo del countdown e passarla allo stato, permettendo alla UI di aggiornare l'anello di conseguenza.

  Il risultato è un'interfaccia molto più professionale, intuitiva e fluida, che traduce esattamente la visione dell'utente in realtà.
patches:
  - file: index.html
    content: |
      <!DOCTYPE html>
      <html lang="it">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Mio Trainer Personale</title>
          <link rel="stylesheet" href="style.css">
          <link rel="preconnect" href="https://fonts.googleapis.com">
          <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">
      </head>
      <body>

          <div id="app-container">

              <section id="calendar-view" class="view">
                  </section>

              <section id="trainer-view" class="view">
                  <h2 id="trainer-exercise-name">--</h2>
                  <p id="trainer-series-counter" class="trainer-subtitle">--</p>

                  <div class="progress-ring-container">
                      <svg id="progress-ring" class="progress-ring" width="300" height="300">
                          <circle class="progress-ring__track" stroke-width="15" fill="transparent" r="140" cx="150" cy="150"/>
                          <circle id="progress-ring-bar" class="progress-ring__bar" stroke-width="15" fill="transparent" r="140" cx="150" cy="150"/>
                      </svg>
                      <div id="trainer-display" class="trainer-display">
                          <div id="trainer-display-countdown" style="display: none;">
                              <div id="trainer-countdown-number">3</div>
                              <div id="trainer-phase-label">UP</div>
                          </div>
                          <div id="trainer-display-announcement" class="is-flashing">READY</div>
                      </div>
                  </div>
                  
                  <p id="trainer-exercise-description" class="trainer-subtitle">--</p>

                  <div id="trainer-controls" class="trainer-controls">
                      <button class="btn btn-primary" data-action="start-series">Inizia Serie</button>
                      <button class="btn" data-action="pause" style="display: none;">Pausa</button>
                      <button class="btn btn-secondary" data-action="resume" style="display: none;">Riprendi</button>
                      <button class="btn btn-danger" data-action="stop">Termina Allenamento</button>
                  </div>
              </section>

              <section id="debriefing-view" class="view">
                  <h1>Debriefing Sessione</h1>
                  </section>

          </div>

          <div id="modal-overlay" class="modal-overlay">
              <div id="modal-content" class="modal-content">
                  </div>
          </div>

          <script type="module" src="src/main.js"></script>
      </body>
      </html>
  - file: style.css
    content: |
      /**
       * FOGLIO DI STILE PRINCIPALE
       * Contiene le variabili globali e gli stili di base dell'applicazione.
       */

      :root {
          --bg-color: #1a1a1d;
          --card-color: #2c2c34;
          --primary-color: #9575cd;
          --secondary-color: #4db6ac;
          --text-color: #f4f4f9;
          --text-secondary: #b3b3b3;
          --danger-color: #ef5350;
          --success-color: #66bb6a;
          --border-color: #4a4a52;

          --font-main: 'Roboto Condensed', sans-serif;
      }

      *,
      *::before,
      *::after {
          box-sizing: border-box;
          margin: 0;
          padding: 0;
      }

      html {
          font-family: var(--font-main);
          color: var(--text-color);
          background-color: var(--bg-color);
      }

      body {
          font-size: 16px;
          line-height: 1.6;
      }

      #app-container {
          max-width: 1200px;
          margin: 2rem auto;
          padding: 0 1rem;
      }

      h1, h2, h3, h4, h5, h6 {
          color: var(--primary-color);
          font-weight: 700;
          margin-bottom: 1rem;
      }

      /* Sistema di gestione delle viste */
      .view {
          display: none;
      }

      .view--active {
          display: block;
      }

      /* --- Stili Calendario (invariati) --- */
      .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; }
      .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 1rem; }
      .day-cell { background-color: var(--card-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; display: flex; flex-direction: column; justify-content: space-between; transition: transform 0.2s ease-out, border-left 0.2s ease-out; border-left: 4px solid transparent; cursor: pointer; }
      .day-cell:hover { transform: translateY(-4px); border-left: 4px solid var(--primary-color); }
      .day-cell-header { display: flex; justify-content: space-between; align-items: baseline; font-weight: 700; }
      .day-cell-header .day-name { font-size: 0.9em; color: var(--text-secondary); }
      .day-cell-header .day-number { font-size: 1.5em; color: var(--primary-color); }
      .day-cell-body { margin: 2rem 0; text-align: center; color: var(--text-secondary); }
      .day-cell-footer { text-align: center; }

      /* --- Stili Trainer --- */
      #trainer-view { text-align: center; }
      .trainer-subtitle { color: var(--text-secondary); margin-top: 1rem; margin-bottom: 1rem; }
      
      .progress-ring-container {
          position: relative;
          width: 300px;
          height: 300px;
          margin: 1rem auto;
      }
      .progress-ring { transform: rotate(-90deg); }
      .progress-ring__track { stroke: var(--border-color); }
      .progress-ring__bar { stroke: var(--secondary-color); transition: stroke-dashoffset 0.3s linear; }
      
      .trainer-display {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
      }
      #trainer-countdown-number {
          font-size: 8rem;
          font-weight: 700;
          line-height: 1;
      }
      #trainer-phase-label {
          font-size: 2rem;
          color: var(--text-secondary);
          text-transform: uppercase;
      }
      #trainer-display-announcement {
          font-size: 5rem;
          font-weight: 700;
          text-transform: uppercase;
      }

      .trainer-controls { display: flex; justify-content: center; gap: 1rem; margin-top: 1rem; }

      @keyframes flash { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }
      .is-flashing { animation: flash 0.75s infinite; }

      /* --- Stili Componenti Generici (invariati) --- */
      .btn { background-color: var(--card-color); color: var(--text-color); border: 1px solid var(--border-color); padding: 0.5rem 1rem; font-family: var(--font-main); font-size: 1em; font-weight: 700; border-radius: 6px; cursor: pointer; transition: background-color 0.2s, transform 0.2s; }
      .btn:hover:not(:disabled) { transform: scale(1.05); }
      .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
      .btn-primary { background-color: var(--primary-color); border-color: var(--primary-color); }
      .btn-primary:hover:not(:disabled) { background-color: #a082e0; }
      .btn-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: #1a1a1d; }
      .btn-secondary:hover:not(:disabled) { background-color: #5dcbb8; }
      .btn-danger { background-color: var(--danger-color); border-color: var(--danger-color); }

      /* --- Stili Sistema Modale (invariati) --- */
      .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: none; justify-content: center; align-items: center; z-index: 1000; }
      .modal-overlay--active { display: flex; }
      .modal-content { background-color: var(--card-color); padding: 2rem; border-radius: 8px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; border-top: 4px solid var(--primary-color); }
      .modal-list { list-style: none; margin-top: 1.5rem; }
      .modal-list-item { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
      .modal-list-item:last-child { border-bottom: none; }
      .modal-actions { margin-top: 2rem; text-align: right; }
  - file: src/ui.js
    content: |
      /**
       * @file ui.js
       *
       * Responsabile di tutte le manipolazioni dirette del DOM.
       */
      import { getWeekStartDate, formatDate, formatDateForDisplay } from './utils.js';
      import { EXERCISES } from './config.js';

      // --- Elementi DOM ---
      const views = document.querySelectorAll('.view');
      export const calendarView = document.getElementById('calendar-view');
      export const trainerView = document.getElementById('trainer-view');
      export const debriefingView = document.getElementById('debriefing-view');
      export const modalOverlay = document.getElementById('modal-overlay');
      const modalContent = document.getElementById('modal-content');

      // Elementi Trainer
      const trainerExerciseName = document.getElementById('trainer-exercise-name');
      const trainerSeriesCounter = document.getElementById('trainer-series-counter');
      const trainerExerciseDescription = document.getElementById('trainer-exercise-description');
      export const trainerControls = document.getElementById('trainer-controls');
      const startSeriesBtn = trainerControls.querySelector('[data-action="start-series"]');
      const pauseBtn = trainerControls.querySelector('[data-action="pause"]');
      const resumeBtn = trainerControls.querySelector('[data-action="resume"]');
      
      // Elementi Trainer Display (nuovi)
      const ringBar = document.getElementById('progress-ring-bar');
      const ringRadius = ringBar.r.baseVal.value;
      const ringCircumference = 2 * Math.PI * ringRadius;
      ringBar.style.strokeDasharray = `${ringCircumference} ${ringCircumference}`;

      const displayCountdown = document.getElementById('trainer-display-countdown');
      const displayAnnouncement = document.getElementById('trainer-display-announcement');
      const countdownNumber = document.getElementById('trainer-countdown-number');
      const phaseLabel = document.getElementById('trainer-phase-label');

      /** Mostra una vista specifica e nasconde tutte le altre. */
      export function showView(viewId) {
          views.forEach(view => {
              view.classList.toggle('view--active', view.id === viewId);
          });
      }

      function updateProgressRing(percent) {
          const offset = ringCircumference - (percent / 100) * ringCircumference;
          ringBar.style.strokeDashoffset = offset;
      }
      
      /** Aggiorna la UI del trainer in base allo stato fornito dalla state machine */
      export function updateTrainerUI(state) {
          const { currentExercise, currentSeries, currentState, countdown, phase, progress } = state;

          trainerExerciseName.textContent = currentExercise.name;
          trainerExerciseDescription.textContent = currentExercise.description;
          trainerSeriesCounter.textContent = `Serie ${currentSeries} di ${currentExercise.series || '...'}`;

          const isCountdownState = ['action', 'preparing', 'rest'].includes(currentState);
          const isPausedState = currentState === 'paused';
          const isAnnouncingState = currentState === 'announcing';
          const isReadyState = currentState === 'ready';

          // Gestione visibilità sezioni display
          displayCountdown.style.display = (isCountdownState || isPausedState) ? 'block' : 'none';
          displayAnnouncement.style.display = (isAnnouncingState || isReadyState) ? 'block' : 'none';

          // Gestione lampeggio
          displayAnnouncement.classList.toggle('is-flashing', isAnnouncingState);
          
          // Aggiornamento contenuti e anello
          if (isReadyState) {
              displayAnnouncement.textContent = 'READY';
              updateProgressRing(100); // Anello pieno
          }

          if (isAnnouncingState) {
              displayAnnouncement.textContent = phase.toUpperCase();
              updateProgressRing(0); // Anello vuoto
          }

          if (isCountdownState || isPausedState) {
              countdownNumber.textContent = countdown;
              phaseLabel.textContent = phase.toUpperCase();
              updateProgressRing(progress * 100);
          }
          
          // Gestione pulsanti
          startSeriesBtn.style.display = isReadyState ? 'inline-block' : 'none';
          pauseBtn.style.display = isCountdownState ? 'inline-block' : 'none';
          resumeBtn.style.display = isPausedState ? 'inline-block' : 'none';
      }

      // --- Funzioni Calendario e Modale (invariate) ---
      export function renderCalendar(weekDate, schedule) {
          const startDate = getWeekStartDate(weekDate);
          const weekDays = Array.from({ length: 7 }).map((_, i) => { const day = new Date(startDate); day.setDate(day.getDate() + i); return day; });
          let headerHtml = `<div class="calendar-header"><button class="btn" id="prev-week-btn">&lt; Precedente</button><h2>Settimana del ${formatDateForDisplay(startDate)}</h2><button class="btn" id="next-week-btn">Successiva &gt;</button></div>`;
          let gridHtml = '<div class="calendar-grid">';
          weekDays.forEach(day => {
              const dateKey = formatDate(day);
              const daySchedule = schedule[dateKey] || [];
              const exerciseCount = daySchedule.length;
              gridHtml += `<div class="day-cell" data-date="${dateKey}"><div class="day-cell-header"><span class="day-name">${day.toLocaleDateString('it-IT', { weekday: 'long' }).toUpperCase()}</span><span class="day-number">${day.getDate()}</span></div><div class="day-cell-body"><p>${exerciseCount > 0 ? `${exerciseCount} esercizi` : 'Nessun allenamento'}</p></div><div class="day-cell-footer"><button class="btn btn-secondary" ${exerciseCount === 0 ? 'disabled' : ''}>START</button></div></div>`;
          });
          gridHtml += '</div>';
          calendarView.innerHTML = headerHtml + gridHtml;
      }
      export function openModal() { modalOverlay.classList.add('modal-overlay--active'); }
      export function closeModal() { modalOverlay.classList.remove('modal-overlay--active'); }
      export function renderDailyWorkoutModal(dateKey, schedule) {
          const scheduledIds = schedule[dateKey] || [];
          const scheduledExercises = scheduledIds.map(id => EXERCISES.find(ex => ex.id === id));
          let listItems = scheduledExercises.map(ex => `<li class="modal-list-item"><span>${ex.name}</span><button class="btn btn-danger" data-action="remove-exercise" data-exercise-id="${ex.id}">Rimuovi</button></li>`).join('');
          if (scheduledExercises.length === 0) { listItems = '<p>Nessun esercizio pianificato per oggi.</p>'; }
          modalContent.innerHTML = `<h3>Allenamento del ${dateKey}</h3><ul class="modal-list">${listItems}</ul><div class="modal-actions"><button class="btn btn-primary" data-action="show-library">Aggiungi Esercizio</button><button class="btn" data-action="close-modal">Chiudi</button></div>`;
      }
      export function renderExerciseLibraryModal() {
          let listItems = EXERCISES.map(ex => `<li class="modal-list-item"><div><strong>${ex.name}</strong><p style="color: var(--text-secondary); font-size: 0.9em;">${ex.description}</p></div><button class="btn btn-secondary" data-action="add-exercise" data-exercise-id="${ex.id}">Aggiungi</button></li>`).join('');
          modalContent.innerHTML = `<h3>Libreria Esercizi</h3><ul class="modal-list">${listItems}</ul><div class="modal-actions"><button class="btn" data-action="close-modal">Chiudi</button></div>`;
      }
  - file: src/trainer.js
    content: |
      /**
       * @file trainer.js
       *
       * Contiene la macchina a stati e tutta la logica di business
       * per una sessione di allenamento. È completamente disaccoppiato dal DOM.
       */
      import * as ui from './ui.js';
      import { EXERCISES } from './config.js';
      import { playTick } from './utils.js';

      let state = {};

      function resetState() {
          if (state.intervalId) clearInterval(state.intervalId);
          state = {
              workoutPlan: [],
              currentExerciseIndex: 0,
              currentSeries: 1,
              currentState: 'idle', // idle, ready, announcing, preparing, action, paused, rest, finished
              countdown: 0,
              countdownDuration: 0,
              intervalId: null,
              phase: '', // 'up', 'hold', 'down', 'rest', 'prepare'
              repCount: 0,
              progress: 1,
          };
      }

      function setState(newState, data = {}) {
          state.currentState = newState;
          // Esegui azioni all'ingresso del nuovo stato
          switch (newState) {
              case 'idle':
                  resetState();
                  break;
              case 'ready':
                  state.currentExercise = state.workoutPlan[state.currentExerciseIndex];
                  if (state.currentSeries === 1) { // Solo alla prima serie del primo esercizio
                      state.currentSeries = 1;
                  }
                  ui.updateTrainerUI(state);
                  break;
              case 'announcing':
                  state.phase = data.phase;
                  ui.updateTrainerUI(state);
                  playTick();
                  setTimeout(() => setState(data.nextState, data.nextStateData), 750);
                  break;
              case 'preparing':
                  state.phase = 'prepare';
                  runCountdown(3, 'action');
                  break;
              case 'action':
                  runActionPhase();
                  break;
              case 'rest':
                  state.phase = 'rest';
                  runCountdown(state.currentExercise.rest, 'readyForNext');
                  break;
              case 'paused':
                  clearInterval(state.intervalId);
                  ui.updateTrainerUI(state);
                  break;
              case 'readyForNext':
                  if (state.currentSeries < state.currentExercise.series) {
                      state.currentSeries++;
                      setState('announcing', { phase: 'ready', nextState: 'ready' });
                  } else if (state.currentExerciseIndex < state.workoutPlan.length - 1) {
                      state.currentExerciseIndex++;
                      state.currentSeries = 1;
                      setState('announcing', { phase: 'ready', nextState: 'ready' });
                  } else {
                      setState('finished');
                  }
                  break;
              case 'finished':
                  // Per ora, torna al calendario. In futuro andrà al debriefing.
                  alert("Allenamento completato!");
                  ui.showView('calendar-view');
                  resetState();
                  break;
          }
      }

      function runCountdown(duration, nextState, nextStateData = {}) {
          state.countdown = duration;
          state.countdownDuration = duration;
          state.progress = 1;

          ui.updateTrainerUI(state);
          if (duration > 0) playTick();

          state.intervalId = setInterval(() => {
              state.countdown--;
              state.progress = state.countdown / state.countdownDuration;
              ui.updateTrainerUI(state);
              if (state.countdown > 0) playTick();

              if (state.countdown <= 0) {
                  clearInterval(state.intervalId);
                  setState(nextState, nextStateData);
              }
          }, 1000);
      }
      
      function runActionPhase() {
          const exercise = state.currentExercise;
          if (exercise.type === 'time') {
              state.phase = 'action';
              runCountdown(exercise.duration, 'rest');
          } else if (exercise.type === 'reps') {
              state.repCount = 0;
              runRep();
          }
      }

      function runRep() {
          const { reps } = state.currentExercise;
          if (state.repCount >= reps) {
              setState('rest');
              return;
          }
          state.repCount++;
          setState('announcing', { phase: 'up', nextState: 'action.rep.up' });
      }
      
      function runRepPhase(phase) {
          const { tempo } = state.currentExercise;
          state.phase = phase;
          const nextStates = { 'up': 'action.rep.hold', 'hold': 'action.rep.down', 'down': null };
          runCountdown(tempo[phase], 'action.rep.transition', { next: nextStates[phase] });
      }

      // Entry points dall'esterno
      export function start(exerciseIds) {
          resetState();
          state.workoutPlan = exerciseIds.map(id => EXERCISES.find(e => e.id === id));
          if (state.workoutPlan.length > 0) {
              setState('ready');
          }
      }

      export function startSeries() {
          if (state.currentState !== 'ready') return;
          setState('announcing', { phase: 'prepare', nextState: 'preparing' });
      }

      export function pause() {
          if (!['action', 'rest', 'preparing'].includes(state.currentState)) return;
          setState('paused');
      }

      export function resume() {
          if (state.currentState !== 'paused') return;
          runCountdown(state.countdown, state.phase === 'rest' ? 'readyForNext' : 'action');
      }

      export function stop() {
          if (confirm("Sei sicuro di voler terminare l'allenamento?")) {
              setState('finished');
          }
      }

      // Mini-stati per la logica delle ripetizioni
      function setRepState(newState, data) {
           switch(newState) {
                case 'action.rep.up':
                case 'action.rep.down':
                case 'action.rep.hold':
                   runRepPhase(newState.split('.').pop());
                   break;
                case 'action.rep.transition':
                    if (data.next) {
                        setState('announcing', { phase: data.next.split('.').pop(), nextState: data.next });
                    } else {
                        runRep(); // Prossima ripetizione
                    }
                    break;
           }
      }

      // Intercetta la chiamata a setState per gestire gli stati complessi
      const originalSetState = setState;
      setState = (newState, data) => {
          if (newState.startsWith('action.rep')) {
              setRepState(newState, data);
          } else {
              originalSetState(newState, data);
          }
      }
commands:
  - "echo 'Patch con la nuova UI del Trainer applicato.'"
  - "echo 'Prova ad avviare un allenamento per vedere l''anello di avanzamento e la nuova interfaccia.'"
  - "git status"