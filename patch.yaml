commit_message: "fix: Corregge logica di avanzamento e aggiunge logging di stato"
rationale: |
  Questo commit risolve un bug critico nel flusso della state machine del trainer e introduce un meccanismo di logging per facilitare il debug futuro.

  1.  **Correzione Logica**: La logica di avanzamento in `ADVANCE_TRAINER_LOGIC` è stata riscritta per gestire correttamente la transizione tra serie e ripetizioni, in particolare dopo un periodo di riposo. Questo elimina il loop sulla fase "down" e assicura che il workout progredisca come previsto. L'indice delle fasi (`currentPhaseIndex`) viene ora resettato correttamente all'inizio di ogni nuova ripetizione.

  2.  **Logging di Stato**: È stato aggiunto un `console.log` dettagliato nella funzione `dispatch` dello store. Ad ogni azione, ora vengono stampati in console lo stato corrente, l'azione eseguita e il contesto del trainer, offrendo una visibilità completa sul flusso del programma.

  3.  **Aggiornamento Documentazione**: Il file `01_FUNCTIONALITY.md` è stato aggiornato per descrivere accuratamente il flusso corretto della state machine.
patches:
  - file: docs/01_FUNCTIONALITY.md
    content: |
      # App Functionality Specification

      This document outlines the core features and operational logic of the "Mio Trainer Personale" web application.

      ## 1. Core Concept

      The application is a single-page app (SPA) designed for users to schedule, execute, and track workouts. All user data is persisted locally in the browser's `localStorage`.

      ## 2. Main Views

      The application operates using three primary, mutually exclusive views: `Calendar`, `Trainer`, and `Debriefing`.

      ### 2.1. Calendar View

      -   **Function:** The main dashboard and default view of the application.
      -   **Display:** It presents a weekly grid layout.
      -   **Navigation:** Users can navigate to the previous or next week.
      -   **Day Cells:** Each cell represents a day and displays a summary of the number of exercises scheduled for that day. A "START" button is enabled if one or more exercises are scheduled.
      -   **Interaction:** Clicking a day cell (but not the "START" button) opens the Workout Editor modal for that specific date.

      ### 2.2. Workout Editor (Modal System)

      The editor is a modal system for managing a day's workout routine. It allows for the composition of exercises and configurable rest periods.

      -   **Daily Workout Modal:**
          -   Triggered by clicking a day cell.
          -   Displays a list of items (exercises or rests) currently scheduled for the selected date.
      -   **Exercise Library Modal:**
          -   Triggered by the "Add Exercise" button.
          -   Displays a list of all **available exercises** from the application's library.

      ### 2.3. Interactive Trainer View

      -   **Function:** An interactive, state-driven interface that guides the user through a scheduled workout in real-time.
      -   **Activation:** Triggered by clicking the "START" button on a day cell in the calendar.

      #### Trainer State Machine & Flow
      The trainer operates as a state machine. The primary user flow is as follows:

      1.  **Ready (`ready`):** The initial state. The trainer displays the first exercise and awaits user input.
      2.  **Preparing (`preparing`):** A 3-second countdown that runs **only once** at the very beginning of the workout.
      3.  **Announcing (`announcing`):** A 0.75-second state that displays the name of the upcoming phase (e.g., "UP", "REST") to alert the user.
      4.  **Action (`action`):** The core execution phase where the user performs the movement for a timed duration.
      5.  **Rest (`rest`):** A timed countdown for rest periods between series or exercises.
      6.  **Paused (`paused`):** The user can pause the workout at any time during `preparing`, `announcing`, `action`, or `rest`.
      7.  **Advancement Logic:**
          - After an `action` phase (e.g., 'down'), the logic checks if there are more phases in the rep (e.g., 'up', 'hold'). If not, it advances the repetition counter.
          - If the repetitions for a series are complete, it transitions to a `rest` state.
          - If the series for an exercise are complete, it moves to the next item in the workout list (which could be another exercise or a rest period).
      8.  **Finished (`finished`):** Once all items in the routine are complete, the trainer automatically transitions to the Debriefing View.

      ### 2.4. Debriefing View

      -   **Activation:** Appears automatically when a workout is completed.
      -   **Content:** Displays a summary of all exercises completed.
      -   **Actions:** "Copy for Coach" and "Return to Calendar".
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';

      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          activeWorkout: null,
          trainerState: 'idle',
          trainerContext: {},
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        function dispatch(action) {
          const oldState = { ...state };
          let newState = { ...state };

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d=new Date(state.focusedDate); d.setDate(d.getDate()-7); newState={...state, focusedDate:d}; break; }
            case 'NEXT_WEEK': { const d=new Date(state.focusedDate); d.setDate(d.getDate()+7); newState={...state, focusedDate:d}; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'ADD_EXERCISE_ITEM': {
                const { date, exerciseId } = action.payload;
                const dateKey = `workout-${date}`;
                const exercise = getExerciseById(exerciseId);
                if (!exercise) break;
                const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } };
                break;
            }
            case 'ADD_REST_ITEM': {
                const { date } = action.payload;
                const dateKey = `workout-${date}`;
                const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'REMOVE_WORKOUT_ITEM': {
                const { date, itemId } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId);
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'UPDATE_REST_DURATION': {
                const { date, itemId, newDuration } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                const itemIndex = dayWorkout.findIndex(item => item.id === itemId);
                if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') {
                    dayWorkout[itemIndex].duration = newDuration;
                    newWorkouts[dateKey] = dayWorkout;
                    newState = { ...state, workouts: newWorkouts };
                }
                break;
            }
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const dateKey = `workout-${date}`;
              const workoutItems = state.workouts[dateKey];
              if (!workoutItems || workoutItems.length === 0) break;
              newState = {
                ...state,
                currentView: 'trainer',
                activeWorkout: { date, items: workoutItems },
                trainerState: 'ready',
                trainerContext: { itemIndex: 0, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0 }
              };
              break;
            }
            case 'SET_TRAINER_STATE': {
              newState = { ...state, trainerState: action.payload };
              break;
            }
            case 'PAUSE_TRAINER': {
              if (['paused', 'ready', 'finished'].includes(state.trainerState)) break;
              const { remaining, duration } = action.payload;
              newState = {
                ...state,
                trainerState: 'paused',
                trainerContext: { ...state.trainerContext, remaining, duration, stateBeforePause: state.trainerState },
              };
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState !== 'paused') break;
              newState = { ...state, trainerState: state.trainerContext.stateBeforePause };
              break;
            }
            case 'UPDATE_TRAINER_CONTEXT': {
              newState = { ...state, trainerContext: { ...state.trainerContext, ...action.payload }};
              break;
            }
            case 'ADVANCE_TRAINER_LOGIC': {
              const { activeWorkout, trainerContext } = state;
              const currentItem = activeWorkout.items[trainerContext.itemIndex];
              let nextContext = { ...trainerContext };
              let nextStateStr = state.trainerState;

              const advanceToNextItem = () => {
                  if (trainerContext.itemIndex < activeWorkout.items.length - 1) {
                      nextContext = { ...nextContext, itemIndex: trainerContext.itemIndex + 1, currentSeries: 1, currentRep: 1, currentPhaseIndex: 0 };
                      const nextItem = activeWorkout.items[nextContext.itemIndex];
                      nextStateStr = (nextItem.type === 'rest') ? 'rest' : 'announcing';
                      if (nextItem.type === 'rest') nextContext.restDuration = nextItem.duration;
                  } else {
                      nextStateStr = 'finished';
                  }
              };

              if (currentItem.type === 'exercise') {
                  if (nextContext.currentRep < currentItem.reps) {
                      nextContext.currentRep++;
                      nextContext.currentPhaseIndex = 0;
                      nextStateStr = 'announcing';
                  } else if (nextContext.currentSeries < currentItem.series) {
                      nextContext.currentSeries++;
                      nextContext.currentRep = 1;
                      nextContext.currentPhaseIndex = 0;
                      nextContext.restDuration = getExerciseById(currentItem.exerciseId)?.defaultRest || 60;
                      nextStateStr = 'rest';
                  } else {
                      advanceToNextItem();
                  }
              } else if (currentItem.type === 'time') {
                  if (nextContext.currentSeries < currentItem.series) {
                      nextContext.currentSeries++;
                      nextContext.restDuration = getExerciseById(currentItem.exerciseId)?.defaultRest || 60;
                      nextStateStr = 'rest';
                  } else {
                      advanceToNextItem();
                  }
              } else if (state.trainerState === 'rest') {
                  // After resting, we announce the next rep/exercise
                  nextStateStr = 'announcing';
              }
              newState = { ...state, trainerState: nextStateStr, trainerContext: nextContext };
              break;
            }
            default:
              return;
          }
          state = newState;
          if (state !== oldState) {
            console.log(
              `%cACTION: ${action.type}`, 'color: #88aaff; font-weight: bold;',
              {
                payload: action.payload,
                trainerState: state.trainerState,
                context: state.trainerContext
              }
            );
            if (state.workouts !== oldState.workouts) {
              saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
            }
            notify();
          }
        }
        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      const store = createStore();
      export default store;
commands:
  - "echo 'Logica di avanzamento corretta e logging di stato implementato.'"