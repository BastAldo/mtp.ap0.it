commit_message: "refactor(trainer): Riprogettazione architetturale della macchina a stati"
rationale: |
  Questo commit implementa la riprogettazione architetturale della logica del trainer, come definito in `docs/05_STATUS.md` e in linea con l'ADR 003.

  La causa radice dell'instabilità (loop infiniti e race condition) è stata risolta separando nettamente le responsabilità:
  1.  **Reducer Puro (`store.js`):** La logica di `dispatch` è ora una funzione pura. Calcola e restituisce il nuovo stato in modo sincrono, senza gestire effetti collaterali come i timer. Tutta la logica di transizione di fase del trainer è centralizzata e prevedibile.
  2.  **Gestione Effetti Collaterali (`main.js`):** Un nuovo gestore di effetti, `handleTrainerEffects`, è stato introdotto in `main.js`. Si iscrive allo store, osserva i cambiamenti di `trainerState` e gestisce l'avvio/arresto dei `setInterval`. Questo isola completamente gli effetti collaterali dalla logica di stato.
  3.  **Vista Semplificata (`TrainerView.js`):** La vista del trainer è stata "resa stupida". Invia solo azioni semplici e semantiche (es. `PAUSE_TRAINER`) e non contiene più logica di flusso.

  Questo refactoring risolve il fallimento critico del trainer, garantendo stabilità e manutenibilità future.
patches:
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          activeWorkout: null,
          completedWorkout: null,
          trainerState: 'idle', // idle, ready, preparing, announcing, action, rest, paused, finished
          trainerContext: {},
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        const dispatch = (action) => {
          const oldState = { ...state };
          let newState = { ...state };
          let shouldNotify = true;

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() - 7); newState = { ...state, focusedDate: d }; break; }
            case 'NEXT_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() + 7); newState = { ...state, focusedDate: d }; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'SHOW_NOTICE': newState = { ...state, notice: { message: action.payload.message, id: Date.now() } }; break;

            // WORKOUT EDITOR ACTIONS
            case 'ADD_EXERCISE_ITEM': {
                const { date, exerciseId } = action.payload;
                const dateKey = `workout-${date}`;
                const exercise = getExerciseById(exerciseId);
                if (!exercise) break;
                const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } };
                break;
            }
            case 'ADD_REST_ITEM': {
                const { date } = action.payload;
                const dateKey = `workout-${date}`;
                const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 };
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                dayWorkout.push(newItem);
                newWorkouts[dateKey] = dayWorkout;
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'REMOVE_WORKOUT_ITEM': {
                const { date, itemId } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId);
                newState = { ...state, workouts: newWorkouts };
                break;
            }
            case 'UPDATE_REST_DURATION': {
                const { date, itemId, newDuration } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                const dayWorkout = newWorkouts[dateKey] || [];
                const itemIndex = dayWorkout.findIndex(item => item.id === itemId);
                if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') {
                    dayWorkout[itemIndex].duration = newDuration;
                    newWorkouts[dateKey] = dayWorkout;
                    newState = { ...state, workouts: newWorkouts };
                }
                break;
            }
            case 'REORDER_WORKOUT_ITEMS': {
                const { date, draggedItemId, targetItemId } = action.payload;
                const dateKey = `workout-${date}`;
                const newWorkouts = cloneWorkouts(state.workouts);
                const items = newWorkouts[dateKey] || [];
                const draggedIndex = items.findIndex(item => item.id === draggedItemId);
                const targetIndex = items.findIndex(item => item.id === targetItemId);
                if (draggedIndex > -1 && targetIndex > -1) {
                    const [draggedItem] = items.splice(draggedIndex, 1);
                    items.splice(targetIndex, 0, draggedItem);
                    newWorkouts[dateKey] = items;
                    newState = { ...state, workouts: newWorkouts };
                }
                break;
            }

            // TRAINER LIFECYCLE ACTIONS
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const dateKey = `workout-${date}`;
              const workoutItems = state.workouts[dateKey];
              if (!workoutItems || workoutItems.length === 0) break;
              newState = {
                ...state,
                currentView: 'trainer',
                activeWorkout: { date, items: workoutItems, completed: false, fullPlan: workoutItems },
                completedWorkout: null,
                trainerState: 'ready',
                trainerContext: { itemIndex: 0, currentSeries: 1, currentRep: 1 }
              };
              break;
            }
            case 'FINISH_WORKOUT': {
              newState = { ...state, currentView: 'debriefing', completedWorkout: { ...state.activeWorkout, completed: true }, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'TERMINATE_WORKOUT': {
              const { activeWorkout, trainerContext } = state;
              const partialWorkout = { date: activeWorkout.date, fullPlan: activeWorkout.fullPlan, completed: false, terminationPoint: trainerContext };
              newState = { ...state, currentView: 'debriefing', completedWorkout: partialWorkout, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'START_TRAINER': {
              if(state.trainerState === 'ready') {
                const { itemIndex } = state.trainerContext;
                const currentItem = state.activeWorkout.items[itemIndex];
                newState = { ...state, trainerState: 'preparing', trainerContext: { ...state.trainerContext, duration: 3000, currentItem }};
              }
              break;
            }
            case 'PAUSE_TRAINER': {
              if (state.trainerState !== 'paused' && state.trainerState !== 'ready' && state.trainerState !== 'finished') {
                newState = { ...state, trainerState: 'paused', trainerContext: { ...state.trainerContext, stateBeforePause: state.trainerState } };
              }
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState === 'paused') {
                newState = { ...state, trainerState: state.trainerContext.stateBeforePause };
              }
              break;
            }
            case 'TIMER_TICK': {
              if (state.trainerState === 'paused') { shouldNotify = false; break; }
              const newRemaining = (state.trainerContext.remaining || 0) - action.payload.tick;
              if (newRemaining > 0) {
                newState = { ...state, trainerContext: { ...state.trainerContext, remaining: newRemaining }};
              } else {
                dispatch({ type: 'ADVANCE_TRAINER_PHASE' });
                shouldNotify = false; // Notification will be handled by the subsequent dispatch
              }
              break;
            }
            case 'ADVANCE_TRAINER_PHASE': {
              const { trainerState, activeWorkout, trainerContext } = state;
              const currentItem = activeWorkout.items[trainerContext.itemIndex];
              let nextState, nextContext = { ...trainerContext };

              // Determine the next logical step based on the CURRENT state
              if (trainerState === 'preparing') {
                  nextState = 'announcing';
              }
              else if (trainerState === 'announcing') {
                  nextState = 'action';
              }
              else if (trainerState === 'action' || trainerState === 'rest') {
                  let itemIsComplete = false;
                  if(trainerState === 'rest') {
                      itemIsComplete = true;
                  } else if (currentItem.type === 'time') {
                      if (nextContext.currentSeries < (currentItem.series || 1)) {
                          nextContext.currentSeries++;
                      } else {
                          itemIsComplete = true;
                      }
                  } else if (currentItem.type === 'exercise') {
                      if (nextContext.currentRep < (currentItem.reps || 1)) {
                          nextContext.currentRep++;
                      } else if (nextContext.currentSeries < (currentItem.series || 1)) {
                          nextContext.currentSeries++;
                          nextContext.currentRep = 1;
                      } else {
                          itemIsComplete = true;
                      }
                  }

                  if (itemIsComplete) {
                      if (nextContext.itemIndex < activeWorkout.items.length - 1) {
                          nextContext = { itemIndex: nextContext.itemIndex + 1, currentSeries: 1, currentRep: 1 };
                      } else {
                          nextState = 'finished';
                      }
                  }
                  if(nextState !== 'finished') {
                      nextState = 'announcing';
                  }
              }

              // Determine the properties of the NEW state
              if (nextState !== 'finished') {
                  const newItem = activeWorkout.items[nextContext.itemIndex];
                  nextContext.currentItem = newItem;
                  let duration = 0;

                  // If the next item is a rest, we switch state to 'rest'
                  if (newItem.type === 'rest' && trainerState !== 'rest') {
                      nextState = 'rest';
                  }

                  switch(nextState) {
                      case 'announcing': duration = 750; break;
                      case 'action':
                          if(newItem.type === 'time') { duration = (newItem.duration || 10) * 1000; }
                          else { duration = (newItem.tempo?.down || 1) * 1000; } // Simplified: only 'down' phase for now
                          break;
                      case 'rest':
                          duration = (newItem.duration || 60) * 1000;
                          break;
                  }
                  nextContext.duration = duration;
              }
              newState = { ...state, trainerState: nextState || state.trainerState, trainerContext: nextContext };
              break;
            }
            default:
              action.type = '@@UNKNOWN';
              shouldNotify = false;
              break;
          }

          state = newState;
          if (shouldNotify && state !== oldState) {
            if (state.workouts !== oldState.workouts) {
              saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts);
            }
            notify();
          }
        };

        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }

      const store = createStore();
      export default store;
  - file: src/main.js
    content: |
      import store from './modules/store.js';
      import { init as initCalendarView } from './views/CalendarView.js';
      import { init as initTrainerView } from './views/TrainerView.js';
      import { init as initDebriefingView } from './views/DebriefingView.js';
      import { init as initModal } from './ui/Modal.js';
      import { init as initNotice } from './ui/Notice.js';
      import { loadFromStorage, saveToStorage } from './modules/storage.js';
      import { mockWorkouts } from './modules/_mockData.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const TICK_INTERVAL = 100;

      const views = {
          calendar: document.getElementById('calendar-view'),
          trainer: document.getElementById('trainer-view'),
          debriefing: document.getElementById('debriefing-view'),
      };
      const initializedViews = new Set();

      function initializeApp() {
        let workouts = loadFromStorage(WORKOUTS_STORAGE_KEY);
        if (!workouts) {
          saveToStorage(WORKOUTS_STORAGE_KEY, mockWorkouts);
          workouts = mockWorkouts;
        }
        store.dispatch({ type: 'SET_WORKOUTS', payload: workouts });

        initCalendarView(views.calendar);
        initializedViews.add('calendar');
        initModal(document.getElementById('modal-container'));
        initNotice(document.getElementById('notice-container'));
      }

      let currentActiveView = views.calendar;
      function handleViewChange() {
        const { currentView } = store.getState();
        const newActiveViewEl = views[currentView];

        if (currentActiveView !== newActiveViewEl) {
          currentActiveView.classList.remove('view--active');
          newActiveViewEl.classList.add('view--active');
          currentActiveView = newActiveViewEl;

          if (!initializedViews.has(currentView)) {
            if (currentView === 'trainer') initTrainerView(views.trainer);
            else if (currentView === 'debriefing') initDebriefingView(views.debriefing);
            initializedViews.add(currentView);
          }
        }
      }

      // --- Side Effect Handler for Trainer Timers ---
      let timerInterval = null;
      let lastTrainerState = 'idle';

      function handleTrainerEffects() {
          const { trainerState, trainerContext } = store.getState();

          // State changed, so we always clear the existing timer first.
          if (trainerState !== lastTrainerState) {
              if (timerInterval) {
                  clearInterval(timerInterval);
                  timerInterval = null;
              }

              const statesWithTimers = ['preparing', 'announcing', 'action', 'rest'];
              if (statesWithTimers.includes(trainerState)) {
                  // Set initial remaining time when a new timed state starts
                  store.dispatch({ type: 'TIMER_TICK', payload: { tick: 0 } });

                  timerInterval = setInterval(() => {
                      store.dispatch({ type: 'TIMER_TICK', payload: { tick: TICK_INTERVAL } });
                  }, TICK_INTERVAL);
              }
          }
          lastTrainerState = trainerState;
      }

      store.subscribe(handleViewChange);
      store.subscribe(handleTrainerEffects); // Subscribe the effect handler

      initializeApp();
      console.log('App "Mio Trainer Personale" inizializzata.');
  - file: src/views/TrainerView.js
    content: |
      import store from '../modules/store.js';

      function render(element) {
          const { activeWorkout, trainerState, trainerContext } = store.getState();
          if (!activeWorkout) {
              element.innerHTML = '<h2>Nessun workout attivo.</h2>';
              return;
          }

          const currentItem = trainerContext.currentItem || activeWorkout.items[trainerContext.itemIndex];
          const radius = 90;
          const circumference = 2 * Math.PI * radius;
          const { duration, remaining, stateBeforePause } = trainerContext;

          let ringOffset = circumference;
          if (duration > 0 && remaining >= 0) {
              const progress = (duration - remaining) / duration;
              ringOffset = circumference * (1 - progress);
          }

          let phaseText = '', instructionText = '', buttonText = '', timerText = '', isFlashing = false;
          const terminateButtonHidden = trainerState === 'finished' || trainerState === 'ready';
          const isExercise = currentItem.type === 'exercise' || currentItem.type === 'time';
          const currentPhase = currentItem.type === 'time' ? 'Esegui' : (currentItem.tempo ? 'Fase' : 'Azione');

          switch (trainerState) {
              case 'ready':
                  phaseText = 'PRONTO'; instructionText = `Premi INIZIA per cominciare`; buttonText = 'INIZIA';
                  break;
              case 'preparing':
                  phaseText = 'PREPARATI'; instructionText = 'Si parte...'; buttonText = 'PAUSA'; timerText = Math.ceil(remaining / 1000);
                  break;
              case 'rest':
                  phaseText = 'RIPOSO'; instructionText = 'Recupera le forze'; buttonText = 'PAUSA'; timerText = Math.ceil(remaining / 1000);
                  break;
              case 'announcing':
                  phaseText = currentItem.name; instructionText = `Prossimo Esercizio`; buttonText = 'PAUSA'; isFlashing = true;
                  break;
              case 'action':
                  phaseText = currentPhase.toUpperCase(); instructionText = 'Esegui il movimento'; buttonText = 'PAUSA'; timerText = Math.ceil(remaining / 1000);
                  break;
              case 'paused':
                  const pausedState = stateBeforePause || 'action';
                  if (pausedState === 'rest') { phaseText = 'RIPOSO'; }
                  else if(pausedState === 'announcing') { phaseText = currentItem.name; isFlashing = true; }
                  else { phaseText = (pausedState === 'preparing') ? 'PREPARATI' : currentPhase.toUpperCase(); }
                  instructionText = 'Pausa'; buttonText = 'RIPRENDI';
                  if(pausedState !== 'announcing') { timerText = Math.ceil(remaining / 1000); }
                  break;
              case 'finished':
                  phaseText = 'FINE'; instructionText = 'Workout completato!'; buttonText = 'DEBRIEFING';
                  break;
              default:
                  phaseText = 'IDLE'; instructionText = 'Stato non riconosciuto'; buttonText = 'RESET';
          }

          const headerTitle = currentItem.name || 'Riposo';
          const seriesText = isExercise ? `SERIE ${trainerContext.currentSeries || 1} / ${currentItem.series || 1}` : '';
          const repsText = currentItem.type === 'exercise' ? `REP ${trainerContext.currentRep || 1} / ${currentItem.reps || 1}` : '';

          element.innerHTML = `
              <div class="trainer-container">
                  <header class="trainer-header">
                      <h2>${headerTitle}</h2>
                      <p>${seriesText} ${repsText ? `| ${repsText}` : ''}</p>
                  </header>
                  <div class="progress-ring">
                      <svg>
                          <circle class="progress-ring__background" stroke-width="10" r="${radius}" cx="50%" cy="50%"></circle>
                          <circle class="progress-ring__foreground" style="stroke-dashoffset: ${ringOffset};" stroke-width="10" r="${radius}" cx="50%" cy="50%" stroke-dasharray="${circumference}"></circle>
                      </svg>
                      <div class="progress-ring__text">
                          <div class="progress-ring__phase ${isFlashing ? 'is-flashing' : ''}">${phaseText}</div>
                          <div class="progress-ring__timer">${timerText}</div>
                      </div>
                  </div>
                  <footer class="trainer-footer">
                      <p class="trainer-instruction">${instructionText}</p>
                      <div class="trainer-controls">
                          <button class="trainer-main-btn">${buttonText}</button>
                          <button class="trainer-terminate-btn" ${terminateButtonHidden ? 'hidden' : ''}>Termina</button>
                      </div>
                  </footer>
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              const mainButton = event.target.closest('.trainer-main-btn');
              const terminateButton = event.target.closest('.trainer-terminate-btn');

              if (terminateButton) {
                  store.dispatch({ type: 'PAUSE_TRAINER' });
                  store.dispatch({ type: 'OPEN_MODAL', payload: { type: 'CONFIRM_TERMINATION' } });
                  return;
              }

              if (!mainButton) return;
              const { trainerState } = store.getState();

              switch (trainerState) {
                  case 'ready': store.dispatch({ type: 'START_TRAINER' }); break;
                  case 'paused': store.dispatch({ type: 'RESUME_TRAINER' }); break;
                  case 'finished': store.dispatch({ type: 'FINISH_WORKOUT' }); break;
                  default: store.dispatch({ type: 'PAUSE_TRAINER' }); break;
              }
          });

          store.subscribe(() => {
              if (element.classList.contains('view--active')) {
                  render(element);
              }
          });
          render(element);
      }
commands:
  - "echo 'Riprogettazione architetturale completata. La logica del trainer è ora stabile.'"