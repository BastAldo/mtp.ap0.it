commit_message: "feat(trainer): Riprogettare il trainer con architettura a piano pre-compilato"
rationale: |
  Questo commit implementa la riprogettazione architetturale del trainer, passando da una macchina a stati complessa a un modello a "piano di esecuzione pre-compilato", come definito nell'ADR 003.

  1.  **Nuovo `planGenerator.js`**: È stato introdotto un nuovo modulo puro che prende un array di workout e lo "compila" in un unico array sequenziale (`executionPlan`) di oggetti-passo. Ogni passo contiene tutte le informazioni necessarie per l'esecuzione e la visualizzazione, isolando tutta la complessità logica.

  2.  **`store.js` Semplificato**: La logica del trainer nello store è stata drasticamente semplificata. L'azione `START_WORKOUT` ora genera il piano. L'avanzamento (`ADVANCE_PLAN`) è un semplice incremento di un indice (`currentStepIndex`), eliminando la fragile logica di transizione precedente.

  3.  **`TrainerView.js` Semplificato**: La vista è ora più "stupida" e robusta. Legge le informazioni da visualizzare (titoli, testi, durate) direttamente dall'oggetto-passo corrente nel piano, invece di calcolarle dinamicamente.

  Questa modifica aumenta significativamente la robustezza, la testabilità e la manutenibilità del core funzionale dell'applicazione.
patches:
  - file: src/modules/planGenerator.js
    content: |
      // --- Modulo Generatore di Piani di Esecuzione per il Trainer ---

      /**
       * "Srotola" un esercizio in una sequenza di passi (annuncio, azione, riposo).
       * @param {object} item - L'item di esercizio dal workout.
       * @param {number} seriesIndex - L'indice della serie corrente (1-based).
       * @returns {array} - Un array di oggetti-passo per la serie.
       */
      function unrollExerciseSeries(item, seriesIndex) {
          const steps = [];
          const totalSeries = item.series || 1;
          const totalReps = item.reps || 1;

          // 1. Annuncio Iniziale (solo per la prima serie di un esercizio)
          if (seriesIndex === 1) {
              steps.push({
                  type: 'announcing',
                  duration: 2000,
                  headerTitle: 'Prossimo Esercizio',
                  mainText: item.name,
                  item,
              });
          }

          // 2. Passi di Azione (Repetizioni e Fasi Tempo)
          for (let repIndex = 1; repIndex <= totalReps; repIndex++) {
              if (item.type === 'time') {
                  steps.push({
                      type: 'action',
                      duration: (item.duration || 10) * 1000,
                      headerTitle: item.name,
                      mainText: `Serie ${seriesIndex}/${totalSeries}`,
                      item,
                      context: { currentSeries: seriesIndex, totalSeries }
                  });
              } else { // type 'exercise' con tempo
                  const tempoPhases = Object.keys(item.tempo || { exec: 1 });
                  tempoPhases.forEach(phase => {
                      steps.push({
                          type: 'action',
                          duration: (item.tempo[phase] || 1) * 1000,
                          headerTitle: item.name,
                          mainText: phase.toUpperCase(),
                          item,
                          context: { currentSeries: seriesIndex, totalSeries, currentRep: repIndex, totalReps, phase }
                      });
                  });
              }
          }

          // 3. Riposo tra le serie (se non è l'ultima serie)
          if (seriesIndex < totalSeries) {
              steps.push({
                  type: 'rest',
                  duration: (item.defaultRest || 60) * 1000,
                  headerTitle: 'Riposo',
                  mainText: 'Recupera le forze',
                  isSeriesRest: true,
                  item,
              });
          }

          return steps;
      }

      /**
       * Compila un array di workout items in un piano di esecuzione sequenziale.
       * @param {array} workoutItems - L'array di esercizi e riposi.
       * @returns {array} - L'executionPlan completo.
       */
      export function generatePlan(workoutItems) {
          if (!workoutItems || workoutItems.length === 0) return [];

          const plan = [];

          // Passo 0: Preparazione iniziale
          plan.push({
              type: 'preparing',
              duration: 3000,
              headerTitle: 'Preparati',
              mainText: 'Si comincia...',
          });

          workoutItems.forEach((item) => {
              if (item.type === 'rest') {
                  plan.push({
                      type: 'rest',
                      duration: (item.duration || 60) * 1000,
                      headerTitle: 'Riposo',
                      mainText: 'Come da programma',
                      isSeriesRest: false,
                      item,
                  });
              } else { // 'exercise' o 'time'
                  const totalSeries = item.series || 1;
                  for (let i = 1; i <= totalSeries; i++) {
                      plan.push(...unrollExerciseSeries(item, i));
                  }
              }
          });

          // Passo Finale: Completamento
          plan.push({
              type: 'finished',
              duration: 0,
              headerTitle: 'Fine',
              mainText: 'Workout Completato!',
          });

          return plan;
      }
  - file: src/modules/store.js
    content: |
      import { saveToStorage } from './storage.js';
      import { getExerciseById } from './exerciseRepository.js';
      import { generatePlan } from './planGenerator.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const cloneWorkouts = (workouts) => JSON.parse(JSON.stringify(workouts));

      function createStore() {
        let state = {
          currentView: 'calendar',
          focusedDate: new Date(),
          workouts: {},
          isModalOpen: false,
          modalContext: null,
          notice: null,
          activeWorkout: null, // Contiene il workout originale {date, items}
          completedWorkout: null,
          trainerState: 'idle', // ready, running, paused, finished
          trainerContext: {}, // { executionPlan, currentStepIndex, remaining, stateBeforePause }
        };

        const subscribers = new Set();
        function notify() { subscribers.forEach(callback => callback()); }

        const dispatch = (action) => {
          const oldState = { ...state };
          let newState = { ...state };
          let shouldNotify = true;

          switch (action.type) {
            case 'CHANGE_VIEW': newState = { ...state, currentView: action.payload }; break;
            case 'PREV_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() - 7); newState = { ...state, focusedDate: d }; break; }
            case 'NEXT_WEEK': { const d = new Date(state.focusedDate); d.setDate(d.getDate() + 7); newState = { ...state, focusedDate: d }; break; }
            case 'SET_WORKOUTS': newState = { ...state, workouts: action.payload }; break;
            case 'OPEN_MODAL': newState = { ...state, isModalOpen: true, modalContext: action.payload }; break;
            case 'CLOSE_MODAL': newState = { ...state, isModalOpen: false, modalContext: null }; break;
            case 'SHOW_NOTICE': newState = { ...state, notice: { message: action.payload.message, id: Date.now() } }; break;
            case 'ADD_EXERCISE_ITEM': { const { date, exerciseId } = action.payload; const dateKey = `workout-${date}`; const exercise = getExerciseById(exerciseId); if (!exercise) break; const newItem = { ...exercise, id: `item-${Date.now()}`, type: exercise.type || 'exercise', exerciseId: exercise.id }; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts, modalContext: { type: 'EDIT_WORKOUT', date } }; break; }
            case 'ADD_REST_ITEM': { const { date } = action.payload; const dateKey = `workout-${date}`; const newItem = { id: `item-${Date.now()}`, type: 'rest', duration: 60 }; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; dayWorkout.push(newItem); newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts }; break; }
            case 'REMOVE_WORKOUT_ITEM': { const { date, itemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); newWorkouts[dateKey] = (newWorkouts[dateKey] || []).filter(item => item.id !== itemId); newState = { ...state, workouts: newWorkouts }; break; }
            case 'UPDATE_REST_DURATION': { const { date, itemId, newDuration } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); const dayWorkout = newWorkouts[dateKey] || []; const itemIndex = dayWorkout.findIndex(item => item.id === itemId); if (itemIndex > -1 && dayWorkout[itemIndex].type === 'rest') { dayWorkout[itemIndex].duration = newDuration; newWorkouts[dateKey] = dayWorkout; newState = { ...state, workouts: newWorkouts }; } break; }
            case 'REORDER_WORKOUT_ITEMS': { const { date, draggedItemId, targetItemId } = action.payload; const dateKey = `workout-${date}`; const newWorkouts = cloneWorkouts(state.workouts); const items = newWorkouts[dateKey] || []; const draggedIndex = items.findIndex(item => item.id === draggedItemId); const targetIndex = items.findIndex(item => item.id === targetItemId); if (draggedIndex > -1 && targetIndex > -1) { const [draggedItem] = items.splice(draggedIndex, 1); items.splice(targetIndex, 0, draggedItem); newWorkouts[dateKey] = items; newState = { ...state, workouts: newWorkouts }; } break;

            // --- TRAINER LIFECYCLE (REFACTORED) ---
            case 'START_WORKOUT': {
              const { date } = action.payload;
              const workoutItems = state.workouts[`workout-${date}`];
              if (!workoutItems || workoutItems.length === 0) break;
              const plan = generatePlan(workoutItems);
              newState = { ...state, currentView: 'trainer', activeWorkout: { date, items: workoutItems }, trainerState: 'ready', trainerContext: { executionPlan: plan, currentStepIndex: 0 } };
              break;
            }
            case 'START_TRAINER': {
              if (state.trainerState === 'ready') {
                const firstStep = state.trainerContext.executionPlan[0];
                newState = { ...state, trainerState: 'running', trainerContext: { ...state.trainerContext, remaining: firstStep.duration } };
              }
              break;
            }
            case 'ADVANCE_PLAN': {
              const { executionPlan, currentStepIndex } = state.trainerContext;
              const nextStepIndex = currentStepIndex + 1;
              if (nextStepIndex >= executionPlan.length) {
                // Should not happen due to 'finished' step, but as a safeguard:
                dispatch({ type: 'FINISH_WORKOUT' });
                shouldNotify = false;
                break;
              }
              const nextStep = executionPlan[nextStepIndex];
              if (nextStep.type === 'finished') {
                newState = { ...state, trainerState: 'finished', trainerContext: { ...state.trainerContext, currentStepIndex: nextStepIndex }};
              } else {
                newState = { ...state, trainerContext: { ...state.trainerContext, currentStepIndex: nextStepIndex, remaining: nextStep.duration }};
              }
              break;
            }
            case 'TIMER_TICK': {
              if (state.trainerState !== 'running') { shouldNotify = false; break; }
              const newRemaining = (state.trainerContext.remaining || 0) - action.payload.tick;
              if (newRemaining > 0) {
                newState = { ...state, trainerContext: { ...state.trainerContext, remaining: newRemaining } };
              } else {
                dispatch({ type: 'ADVANCE_PLAN' });
                shouldNotify = false; // ADVANCE_PLAN will trigger its own notification
              }
              break;
            }
            case 'PAUSE_TRAINER': {
              if (state.trainerState === 'running') {
                newState = { ...state, trainerState: 'paused' };
              }
              break;
            }
            case 'RESUME_TRAINER': {
              if (state.trainerState === 'paused') {
                newState = { ...state, trainerState: 'running' };
              }
              break;
            }
            case 'FINISH_WORKOUT': {
              const fullPlan = state.trainerContext.executionPlan.map(step => step.item).filter(Boolean);
              newState = { ...state, currentView: 'debriefing', completedWorkout: { ...state.activeWorkout, completed: true, fullPlan }, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            case 'TERMINATE_WORKOUT': {
              const { activeWorkout, trainerContext } = state;
              const { executionPlan, currentStepIndex } = trainerContext;
              const fullPlan = executionPlan.map(step => step.item).filter(Boolean);

              // Find the original item index from the step
              const currentItem = executionPlan[currentStepIndex].item;
              const originalItemIndex = activeWorkout.items.findIndex(i => i.id === currentItem.id);

              const partialWorkout = { ...activeWorkout, completed: false, fullPlan, terminationPoint: { itemIndex: originalItemIndex, currentSeries: executionPlan[currentStepIndex].context?.currentSeries || 1 } };
              newState = { ...state, currentView: 'debriefing', completedWorkout: partialWorkout, activeWorkout: null, trainerState: 'idle', trainerContext: {} };
              break;
            }
            default: shouldNotify = false; break;
          }

          state = newState;
          if (shouldNotify) {
            if (state.workouts !== oldState.workouts) { saveToStorage(WORKOUTS_STORAGE_KEY, state.workouts); }
            notify();
          }
        };

        return {
          getState: () => ({ ...state }),
          subscribe: (callback) => { subscribers.add(callback); return () => subscribers.delete(callback); },
          dispatch,
        };
      }
      const store = createStore();
      export default store;
  - file: src/views/TrainerView.js
    content: |
      import store from '../modules/store.js';

      function render(element) {
          const { trainerState, trainerContext } = store.getState();
          const { executionPlan, currentStepIndex, remaining } = trainerContext;

          if (!executionPlan || executionPlan.length === 0) {
              element.innerHTML = '<h2>Nessun piano di workout attivo.</h2>';
              return;
          }

          const currentStep = executionPlan[currentStepIndex];
          const { type, duration, headerTitle, mainText, context = {} } = currentStep;

          const radius = 90;
          const circumference = 2 * Math.PI * radius;
          let ringOffset = circumference;
          if (duration > 0 && remaining >= 0) {
              const progress = (duration - remaining) / duration;
              ringOffset = circumference * (1 - progress);
          }

          let timerText = '', buttonText = '', instructionText = '';
          const isFlashing = type === 'announcing';
          const terminateButtonHidden = trainerState === 'finished' || trainerState === 'ready';

          if (duration > 0 && trainerState !== 'paused') {
              timerText = Math.ceil(remaining / 1000);
          } else if (trainerState === 'paused' && duration > 0) {
              timerText = Math.ceil(remaining / 1000);
          }

          switch (trainerState) {
              case 'ready': buttonText = 'INIZIA'; instructionText = 'Premi INIZIA per cominciare'; break;
              case 'running': buttonText = 'PAUSA'; instructionText = 'Esegui'; break;
              case 'paused': buttonText = 'RIPRENDI'; instructionText = 'Pausa'; break;
              case 'finished': buttonText = 'DEBRIEFING'; instructionText = 'Ben fatto!'; break;
              default: buttonText = '...';
          }
          
          let subHeaderText = '';
          if (context.totalSeries) {
              subHeaderText = `SERIE ${context.currentSeries}/${context.totalSeries}`;
              if (context.totalReps) {
                  subHeaderText += ` | REP ${context.currentRep}/${context.totalReps}`;
              }
          }

          element.innerHTML = `
              <div class="trainer-container">
                  <header class="trainer-header">
                      <h2>${headerTitle}</h2>
                      <p>${subHeaderText}</p>
                  </header>
                  <div class="progress-ring">
                      <svg>
                          <circle class="progress-ring__background" stroke-width="10" r="${radius}" cx="50%" cy="50%"></circle>
                          <circle class="progress-ring__foreground" style="stroke-dashoffset: ${ringOffset};" stroke-width="10" r="${radius}" cx="50%" cy="50%" stroke-dasharray="${circumference}"></circle>
                      </svg>
                      <div class="progress-ring__text">
                          <div class="progress-ring__phase ${isFlashing ? 'is-flashing' : ''}">${mainText}</div>
                          <div class="progress-ring__timer">${timerText}</div>
                      </div>
                  </div>
                  <footer class="trainer-footer">
                      <p class="trainer-instruction">${instructionText}</p>
                      <div class="trainer-controls">
                          <button class="trainer-main-btn">${buttonText}</button>
                          <button class="trainer-terminate-btn" ${terminateButtonHidden ? 'hidden' : ''}>Termina</button>
                      </div>
                  </footer>
              </div>
          `;
      }

      export function init(element) {
          element.addEventListener('click', (event) => {
              const mainButton = event.target.closest('.trainer-main-btn');
              const terminateButton = event.target.closest('.trainer-terminate-btn');

              if (terminateButton) {
                  store.dispatch({ type: 'PAUSE_TRAINER' });
                  store.dispatch({ type: 'OPEN_MODAL', payload: { type: 'CONFIRM_TERMINATION' } });
                  return;
              }

              if (!mainButton) return;
              const { trainerState } = store.getState();

              switch (trainerState) {
                  case 'ready': store.dispatch({ type: 'START_TRAINER' }); break;
                  case 'running': store.dispatch({ type: 'PAUSE_TRAINER' }); break;
                  case 'paused': store.dispatch({ type: 'RESUME_TRAINER' }); break;
                  case 'finished': store.dispatch({ type: 'FINISH_WORKOUT' }); break;
              }
          });

          store.subscribe(() => {
              if (element.classList.contains('view--active')) {
                  render(element);
              }
          });

          if (element.classList.contains('view--active')) {
            render(element);
          }
      }
  - file: src/main.js
    content: |
      import store from './modules/store.js';
      import { init as initCalendarView } from './views/CalendarView.js';
      import { init as initTrainerView } from './views/TrainerView.js';
      import { init as initDebriefingView } from './views/DebriefingView.js';
      import { init as initModal } from './ui/Modal.js';
      import { init as initNotice } from './ui/Notice.js';
      import { loadFromStorage, saveToStorage } from './modules/storage.js';
      import { mockWorkouts } from './modules/_mockData.js';

      const WORKOUTS_STORAGE_KEY = 'workouts';
      const TICK_INTERVAL = 100;

      const views = {
          calendar: document.getElementById('calendar-view'),
          trainer: document.getElementById('trainer-view'),
          debriefing: document.getElementById('debriefing-view'),
      };
      const initializedViews = new Set();

      function initializeApp() {
        let workouts = loadFromStorage(WORKOUTS_STORAGE_KEY);
        if (!workouts) {
          saveToStorage(WORKOUTS_STORAGE_KEY, mockWorkouts);
          workouts = mockWorkouts;
        }
        store.dispatch({ type: 'SET_WORKOUTS', payload: workouts });

        initCalendarView(views.calendar);
        initializedViews.add('calendar');
        initModal(document.getElementById('modal-container'));
        initNotice(document.getElementById('notice-container'));
      }

      let currentActiveView = views.calendar;
      function handleViewChange() {
        const { currentView } = store.getState();
        const newActiveViewEl = views[currentView];

        if (currentActiveView !== newActiveViewEl) {
          currentActiveView.classList.remove('view--active');
          newActiveViewEl.classList.add('view--active');
          currentActiveView = newActiveViewEl;

          if (!initializedViews.has(currentView)) {
            if (currentView === 'trainer') initTrainerView(views.trainer);
            else if (currentView === 'debriefing') initDebriefingView(views.debriefing);
            initializedViews.add(currentView);
          }
        }
      }

      // --- Side Effect Handler for Trainer Timers (REFACTORED) ---
      let timerInterval = null;

      function handleTrainerEffects() {
          const { trainerState } = store.getState();

          // Pulisci sempre il timer se non siamo in 'running'
          if (trainerState !== 'running' && timerInterval) {
              clearInterval(timerInterval);
              timerInterval = null;
          }

          // Avvia il timer solo se siamo in 'running' e non c'è già un timer attivo
          if (trainerState === 'running' && !timerInterval) {
              timerInterval = setInterval(() => {
                  store.dispatch({ type: 'TIMER_TICK', payload: { tick: TICK_INTERVAL } });
              }, TICK_INTERVAL);
          }
      }


      store.subscribe(handleViewChange);
      store.subscribe(handleTrainerEffects);

      initializeApp();
      console.log('App "Mio Trainer Personale" inizializzata.');
commands:
  - "echo 'Architettura del trainer aggiornata con successo. Il sistema è ora più robusto e manutenibile.'"